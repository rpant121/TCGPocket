<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TCG Pocket – Effect Test Runner</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #020617;
    color: #e5e7eb;
  }
  header {
    padding: 14px 20px;
    background: #0f172a;
    border-bottom: 1px solid #1f2937;
    display: flex;
    align-items: baseline;
    justify-content: space-between;
  }
  header h1 {
    margin: 0;
    font-size: 20px;
  }
  header .sub {
    font-size: 12px;
    color: #9ca3af;
  }
  main {
    padding: 16px;
    max-width: 1200px;
    margin: 0 auto 40px auto;
  }
  .section {
    background: #020617;
    border-radius: 12px;
    border: 1px solid #1f2937;
    box-shadow: 0 8px 30px rgba(0,0,0,.6);
    padding: 12px 14px 14px;
    margin-bottom: 18px;
  }
  .section h2 {
    margin: 0 0 8px;
    font-size: 17px;
  }
  .section small {
    color: #9ca3af;
  }
  .section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 6px;
  }
  .badges {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  .badge {
    border-radius: 999px;
    padding: 2px 8px;
    font-size: 11px;
    border: 1px solid transparent;
  }
  .badge-muted {
    background: #020617;
    border-color: #1f2937;
    color: #9ca3af;
  }
  .badge-ok {
    background: rgba(22,163,74,0.1);
    border-color: #16a34a;
    color: #bbf7d0;
  }
  .badge-warn {
    background: rgba(234,179,8,0.05);
    border-color: #eab308;
    color: #facc15;
  }
  .badge-err {
    background: rgba(220,38,38,0.08);
    border-color: #ef4444;
    color: #fecaca;
  }
  .controls {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
  }
  button {
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 12px;
    border: 1px solid #1d4ed8;
    background: linear-gradient(90deg,#1d4ed8,#4f46e5);
    color: white;
    cursor: pointer;
  }
  button:hover {
    filter: brightness(1.05);
  }
  button:disabled {
    opacity: 0.5;
    cursor: default;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
  }
  thead {
    background: #020617;
    position: sticky;
    top: 0;
    z-index: 1;
  }
  th, td {
    padding: 6px 6px;
    border-bottom: 1px solid #0f172a;
  }
  th {
    text-align: left;
    font-weight: 600;
    color: #9ca3af;
    font-size: 11px;
  }
  tbody tr:nth-child(even) {
    background: rgba(15,23,42,0.6);
  }
  tbody tr:nth-child(odd) {
    background: rgba(15,23,42,0.9);
  }
  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  .status {
    font-size: 11px;
    border-radius: 999px;
    padding: 2px 6px;
    display: inline-block;
  }
  .status-ok {
    background: rgba(22,163,74,0.15);
    color: #bbf7d0;
  }
  .status-missing {
    background: rgba(248,113,113,0.12);
    color: #fecaca;
  }
  .status-na {
    background: rgba(148,163,184,0.1);
    color: #cbd5f5;
  }
  .status-run-ok {
    background: rgba(34,197,94,0.18);
    color: #bbf7d0;
  }
  .status-run-err {
    background: rgba(248,113,113,0.18);
    color: #fecaca;
  }
  .runtime-msg {
    font-size: 12px;
    margin-top: -2px;
    margin-bottom: 4px;
    color: #e5e7eb;
  }
  .runtime-msg span {
    font-weight: 600;
  }
  .console {
    margin-top: 18px;
    background: #020617;
    border-radius: 10px;
    border: 1px solid #1f2937;
    padding: 8px 10px;
    font-size: 11px;
    max-height: 160px;
    overflow-y: auto;
  }
  .console h3 {
    margin: 0 0 6px;
    font-size: 12px;
    color: #9ca3af;
  }
  .log-line {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    white-space: pre;
    color: #9ca3af;
  }
</style>
</head>
<body>
<header>
  <div>
    <h1>Effect Test Runner</h1>
    <div class="sub">trainer_effects.csv · move_effects.csv · effects.js</div>
  </div>
</header>

<main>
  <!-- TRAINER EFFECTS -->
  <section class="section" id="trainerSection">
    <div class="section-header">
      <div>
        <h2>Trainer Effects (trainer_effects.csv)</h2>
        <small>Coverage + runtime smoke test</small>
      </div>
      <div class="badges">
        <span class="badge badge-muted" id="trainerTotalBadge">Total 0</span>
        <span class="badge badge-ok" id="trainerWithHandlerBadge">With handler 0</span>
        <span class="badge badge-warn" id="trainerMissingHandlerBadge">Missing handler 0</span>
        <span class="badge badge-ok" id="trainerRunOkBadge">Run OK 0</span>
      </div>
    </div>
    <div class="runtime-msg" id="trainerRuntimeMsg">
      Runtime check pending. Click “Run trainer tests”.
    </div>
    <div class="controls">
      <button id="runTrainerBtn">Run trainer tests</button>
    </div>
    <div style="max-height:260px;overflow:auto;border-radius:8px;border:1px solid #111827;">
      <table id="trainerTable">
        <thead>
          <tr>
            <th style="width:70px;">id</th>
            <th style="width:160px;">Name</th>
            <th>effect_type</th>
            <th style="width:120px;">Handler</th>
            <th style="width:80px;">Run</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- MOVE EFFECTS -->
  <section class="section" id="moveSection">
    <div class="section-header">
      <div>
        <h2>Move Effects (move_effects.csv)</h2>
        <small>CSV → MOVE_HANDLERS?. + runMoveEffect</small>
      </div>
      <div class="badges">
        <span class="badge badge-muted" id="moveTotalBadge">Total 0</span>
        <span class="badge badge-ok" id="moveWithHandlerBadge">With handler 0</span>
        <span class="badge badge-warn" id="moveMissingHandlerBadge">Missing handler 0</span>
        <span class="badge badge-ok" id="moveRunOkBadge">Run OK 0</span>
      </div>
    </div>
    <div class="runtime-msg" id="moveRuntimeMsg">
      Runtime check pending. Click “Run move tests”.
    </div>
    <div class="controls">
      <button id="runMoveBtn">Run move tests</button>
    </div>
    <div style="max-height:260px;overflow:auto;border-radius:8px;border:1px solid #111827;">
      <table id="moveTable">
        <thead>
          <tr>
            <th style="width:70px;">id / set-num</th>
            <th style="width:210px;">Pokémon / Attack</th>
            <th>effect_type</th>
            <th style="width:120px;">Handler</th>
            <th style="width:80px;">Run</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- SHARED CONSOLE -->
  <section class="console" id="consoleBox">
    <h3>Log</h3>
    <div id="consoleLines"></div>
  </section>
</main>

<!-- effects.js must expose TRAINER_EFFECTS, MOVE_HANDLERS?., runMoveEffect, loadMoveEffects on globalThis -->
<script src="./effects.js"></script>

<script>
/* ======================= helpers ======================= */

function logLine(msg) {
  const box = document.getElementById('consoleLines');
  const div = document.createElement('div');
  div.className = 'log-line';
  div.textContent = msg;
  box.appendChild(div);
  box.scrollTop = box.scrollHeight;
}

function parseCSV(text) {
  const rows = [];
  let i = 0, f = '', row = [], q = false;
  const pf = () => { row.push(f); f=''; };
  const pr = () => { if (row.length) rows.push(row); row=[]; };
  while (i < text.length) {
    const c = text[i];
    if (q) {
      if (c === '"' && text[i+1] === '"') { f+='"'; i+=2; continue; }
      if (c === '"') { q=false; i++; continue; }
      f += c; i++; continue;
    } else {
      if (c === '"') { q=true; i++; continue; }
      if (c === ',') { pf(); i++; continue; }
      if (c === '\r') { i++; continue; }
      if (c === '\n') { pf(); pr(); i++; continue; }
      f += c; i++; continue;
    }
  }
  if (f.length || row.length) { pf(); pr(); }
  const [head, ...body] = rows;
  if (!head) return [];
  return body.map(r => Object.fromEntries(head.map((k,ix)=>[k.trim(), (r[ix]||'').trim()])));
}

/* ======================= global stubs for effects.js ======================= */

// Do not overwrite real implementations if effects.js already set them.
if (!globalThis.showPopup) {
  globalThis.showPopup = function(msg){ logLine('[popup] ' + msg); };
}
if (!globalThis.addLog) {
  globalThis.addLog = function(pk, htmlText){
    logLine('[battle-log ' + pk + '] ' + htmlText.replace(/<[^>]+>/g,''));
  };
}
if (!globalThis.selectPokemon) {
  globalThis.selectPokemon = function(state, pk, zone) {
    const p = state[pk] || {};
    const hp = 100;
    return { name: 'Dummy', hp, maxHP: hp };
  };
}
if (!globalThis.drawCards) {
  globalThis.drawCards = function(state, pk, n) {
    const p = state[pk]; if (!p) return;
    const count = Math.max(0, Math.min(n, p.deck.length));
    const drawn = p.deck.splice(0, count);
    p.hand.push(...drawn);
  };
}
if (!globalThis.shuffleIntoDeck) {
  globalThis.shuffleIntoDeck = function(hand, deck) {
    deck.push(...hand);
    hand.length = 0;
    // fisher-yates
    for (let i = deck.length-1; i>0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [deck[i],deck[j]] = [deck[j],deck[i]];
    }
  };
}
if (!globalThis.findPokemonByName) {
  globalThis.findPokemonByName = function(state, name) {
    return { name: name || 'Dummy' };
  };
}
if (!globalThis.promoteFromBench) {
  globalThis.promoteFromBench = function(state, pk, requireChoice=true) {
    // pretend success
    return true;
  };
}
if (!globalThis.setTempRetreatFor) {
  globalThis.setTempRetreatFor = function(pk, k, mode){};
}
if (!globalThis.damageActiveOf) {
  globalThis.damageActiveOf = function(pk, amount) {
    // simple stub; never knocks out
    return { knocked:false };
  };
}

/* ======================= CSV state ======================= */

let TRAINER_ROWS = [];
let MOVE_ROWS    = [];

const TRAINER_RESULTS = {}; // id -> { hasHandler, runStatus, error }
const MOVE_RESULTS    = {}; // id -> { hasHandler, runStatus, error }

/* ======================= fake battle state ======================= */

function makeFakeState() {
  const mk = (name,set,num)=>({ name, set, number:num });
  return {
    p1: {
      deck: [
        mk('Pikachu','A1','025'),
        mk('Bulbasaur','A1','001'),
        mk('Charmander','A1','004'),
        mk('Squirtle','A1','007')
      ],
      hand: []
    },
    p2: {
      deck: [
        mk('Geodude','A1','074'),
        mk('Onix','A1','095')
      ],
      hand: []
    }
  };
}

/* ======================= TRAINER section ======================= */

const TRAINER_EFFECTS = globalThis.TRAINER_EFFECTS || {};

async function loadTrainerCsv() {
  const text = await fetch('trainer_effects.csv').then(r=>r.text());
  TRAINER_ROWS = parseCSV(text);
  renderTrainerTable();
  updateTrainerCoverageBadges();
}

function renderTrainerTable() {
  const tbody = document.querySelector('#trainerTable tbody');
  tbody.innerHTML = '';
  TRAINER_ROWS.forEach(row => {
    const tr = document.createElement('tr');
    const idCell = document.createElement('td');
    idCell.textContent = row.id || '';
    idCell.className = 'mono';
    const nmCell = document.createElement('td');
    nmCell.textContent = row.name || '';
    const typeCell = document.createElement('td');
    typeCell.textContent = row.effect_type || '';
    const handlerCell = document.createElement('td');
    const runCell = document.createElement('td');

    const handlerKey = row.effect_type || row.effect_name;
    const hasHandler = !!TRAINER_EFFECTS[handlerKey];

    const hSpan = document.createElement('span');
    hSpan.className = 'status ' + (hasHandler ? 'status-ok' : 'status-missing');
    hSpan.textContent = hasHandler ? 'ok' : 'missing';
    handlerCell.appendChild(hSpan);

    const rSpan = document.createElement('span');
    rSpan.className = 'status status-na';
    rSpan.textContent = 'n/a';
    runCell.appendChild(rSpan);

    tr.dataset.rowId = row.id;
    tr.appendChild(idCell);
    tr.appendChild(nmCell);
    tr.appendChild(typeCell);
    tr.appendChild(handlerCell);
    tr.appendChild(runCell);
    tbody.appendChild(tr);

    TRAINER_RESULTS[row.id] = {
      hasHandler,
      runStatus: 'na',
      error: null
    };
  });
}

function updateTrainerCoverageBadges() {
  const total = TRAINER_ROWS.length;
  const withHandler = TRAINER_ROWS.filter(r=>{
    const key = r.effect_type || r.effect_name;
    return !!TRAINER_EFFECTS[key];
  }).length;
  const missing = total - withHandler;

  document.getElementById('trainerTotalBadge').textContent = 'Total ' + total;
  document.getElementById('trainerWithHandlerBadge').textContent = 'With handler ' + withHandler;
  document.getElementById('trainerMissingHandlerBadge').textContent = 'Missing handler ' + missing;
}

function updateTrainerRuntimeBadges() {
  const total = TRAINER_ROWS.length;
  const ok = TRAINER_ROWS.filter(r => TRAINER_RESULTS[r.id]?.runStatus === 'ok').length;
  document.getElementById('trainerRunOkBadge').textContent = 'Run OK ' + ok;
  const msg = document.getElementById('trainerRuntimeMsg');
  msg.innerHTML = `<span>${ok} / ${total}</span> trainer effects with handlers ran without throwing.`;
}

function refreshTrainerRunCells() {
  const rows = document.querySelectorAll('#trainerTable tbody tr');
  rows.forEach(tr => {
    const id = tr.dataset.rowId;
    const res = TRAINER_RESULTS[id];
    const runCell = tr.children[4];
    runCell.innerHTML = '';
    const span = document.createElement('span');
    if (!res || res.runStatus === 'na') {
      span.className = 'status status-na';
      span.textContent = 'n/a';
    } else if (res.runStatus === 'ok') {
      span.className = 'status status-run-ok';
      span.textContent = 'ok';
    } else {
      span.className = 'status status-run-err';
      span.textContent = 'err';
      span.title = res.error || 'error';
    }
    runCell.appendChild(span);
  });
}

async function runSingleTrainer(row) {
  const key = row.effect_type || row.effect_name;
  const handler = TRAINER_EFFECTS[key];
  const res = TRAINER_RESULTS[row.id];

  if (!handler) {
    res.runStatus = 'na';
    res.error = null;
    return;
  }

  const state = makeFakeState();
  const pk = 'p1';
  try {
    await handler(state, pk, { param1: row.param1, param2: row.param2 });
    res.runStatus = 'ok';
    res.error = null;
  } catch (err) {
    res.runStatus = 'err';
    res.error = err && err.message ? err.message : String(err);
    logLine('[trainer error] ' + row.id + ' ' + (row.name||'') + ' → ' + res.error);
  }
}

async function runAllTrainers() {
  const btn = document.getElementById('runTrainerBtn');
  btn.disabled = true;
  logLine('Running trainer tests...');
  for (const row of TRAINER_ROWS) {
    await runSingleTrainer(row);
  }
  refreshTrainerRunCells();
  updateTrainerRuntimeBadges();
  btn.disabled = false;
}

/// ---- SAFE IMPORTS FROM GLOBALTHIS ----
// (Do NOT redeclare loadMoveEffects, runMoveEffect, MOVE_HANDLERS?.)

// Move handlers
const MOVE_HANDLERS = globalThis.MOVE_EFFECT_HANDLERS || {};


// CSV loader
const loadMoveEffects = globalThis.loadMoveEffects;

// Dispatcher
const runMoveEffect = globalThis.runMoveEffect;

async function loadMoveCsv() {
  const text = await fetch('move_effects.csv').then(r=>r.text());
  MOVE_ROWS = parseCSV(text);
  renderMoveTable();
  updateMoveCoverageBadges();
}

function renderMoveTable() {
  const tbody = document.querySelector('#moveTable tbody');
  tbody.innerHTML = '';
  MOVE_ROWS.forEach(row => {
    const tr = document.createElement('tr');
    const idCell = document.createElement('td');
    idCell.textContent = row.id || '';
    idCell.className = 'mono';
    const nmCell = document.createElement('td');
    nmCell.innerHTML = `
      <div>${row.pokemonName || ''}</div>
      <div style="color:#9ca3af;font-size:11px;">${row.attackName || ''}</div>
    `;
    const typeCell = document.createElement('td');
    typeCell.textContent = row.effect_type || '';
    const handlerCell = document.createElement('td');
    const runCell = document.createElement('td');

    const handler = MOVE_HANDLERS?.[row.effect_type];
    const hasHandler = !!handler;

    const hSpan = document.createElement('span');
    hSpan.className = 'status ' + (hasHandler ? 'status-ok' : 'status-missing');
    hSpan.textContent = hasHandler ? 'ok' : 'missing';
    handlerCell.appendChild(hSpan);

    const rSpan = document.createElement('span');
    rSpan.className = 'status status-na';
    rSpan.textContent = 'n/a';
    runCell.appendChild(rSpan);

    tr.dataset.rowId = row.id;
    tr.appendChild(idCell);
    tr.appendChild(nmCell);
    tr.appendChild(typeCell);
    tr.appendChild(handlerCell);
    tr.appendChild(runCell);
    tbody.appendChild(tr);

    MOVE_RESULTS[row.id] = {
      hasHandler,
      runStatus: 'na',
      error: null
    };
  });
}

function updateMoveCoverageBadges() {
  const total = MOVE_ROWS.length;
  const withHandler = MOVE_ROWS.filter(r=>!!MOVE_HANDLERS?.[r.effect_type]).length;
  const missing = total - withHandler;

  document.getElementById('moveTotalBadge').textContent = 'Total ' + total;
  document.getElementById('moveWithHandlerBadge').textContent = 'With handler ' + withHandler;
  document.getElementById('moveMissingHandlerBadge').textContent = 'Missing handler ' + missing;
}

function updateMoveRuntimeBadges() {
  const total = MOVE_ROWS.length;
  const ok = MOVE_ROWS.filter(r => MOVE_RESULTS[r.id]?.runStatus === 'ok').length;
  document.getElementById('moveRunOkBadge').textContent = 'Run OK ' + ok;
  const msg = document.getElementById('moveRuntimeMsg');
  msg.innerHTML = `<span>${ok} / ${total}</span> move effects with handlers ran successfully in both preview + final.`;
}

function refreshMoveRunCells() {
  const rows = document.querySelectorAll('#moveTable tbody tr');
  rows.forEach(tr => {
    const id = tr.dataset.rowId;
    const res = MOVE_RESULTS[id];
    const runCell = tr.children[4];
    runCell.innerHTML = '';
    const span = document.createElement('span');
    if (!res || res.runStatus === 'na') {
      span.className = 'status status-na';
      span.textContent = 'n/a';
    } else if (res.runStatus === 'ok') {
      span.className = 'status status-run-ok';
      span.textContent = 'ok';
    } else {
      span.className = 'status status-run-err';
      span.textContent = 'err';
      span.title = res.error || 'error';
    }
    runCell.appendChild(span);
  });
}

async function runSingleMove(row) {
  const handler = MOVE_HANDLERS?.[row.effect_type];
  const res = MOVE_RESULTS[row.id];
  if (!handler) {
    res.runStatus = 'na';
    res.error = null;
    return;
  }

  const state = makeFakeState();
  const pk = 'p1';
  const baseDamage = 30;

  try {
    await loadMoveEffects();

    // Preview phase
    const preview = await runMoveEffect(state, pk, row.attackName, baseDamage, { isFinal:false });

    // Final phase – pass previous damage as damageDealt if needed
    const finalDamage = await runMoveEffect(
      state,
      pk,
      row.attackName,
      baseDamage,
      { isFinal:true, damageDealt: preview }
    );

    if (typeof finalDamage !== 'number' || !isFinite(finalDamage)) {
      throw new Error('non-numeric damage result');
    }

    res.runStatus = 'ok';
    res.error = null;
  } catch (err) {
    res.runStatus = 'err';
    res.error = err && err.message ? err.message : String(err);
    logLine('[move error] ' + row.id + ' ' + (row.pokemonName||'') + ' / ' +
      (row.attackName||'') + ' → ' + res.error);
  }
}

async function runAllMoves() {
  const btn = document.getElementById('runMoveBtn');
  btn.disabled = true;
  logLine('Running move tests...');
  for (const row of MOVE_ROWS) {
    await runSingleMove(row);
  }
  refreshMoveRunCells();
  updateMoveRuntimeBadges();
  btn.disabled = false;
}

/* ======================= init ======================= */

async function init() {
  await loadTrainerCsv();
  await loadMoveCsv();

  document.getElementById('runTrainerBtn').addEventListener('click', runAllTrainers);
  document.getElementById('runMoveBtn').addEventListener('click', runAllMoves);

  logLine('Effect test runner ready.');
}

window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
