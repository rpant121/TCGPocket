<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pokémon TCG Pocket Battle</title>
<link rel="icon" type="image/png" href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Pok%C3%A9_Ball_icon.svg/768px-Pok%C3%A9_Ball_icon.svg.png?20161023215848"/>
<style>
:root{--card-w:85px;--card-h:120px}

/* ===========================
   GLOBAL BASE THEME
=========================== */
body{
  font-family:'Segoe UI',Arial,sans-serif;
  background:radial-gradient(circle at top,#2b2f34,#1c1f24);
  margin:0;
  padding:0;
  color:#e5e7eb;
  height:100vh;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  align-items:center;
}
h1{
  margin:0;
  width:100%;
  padding:.4rem 0;
  text-align:center;
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  font-size:1.05rem;
  letter-spacing:.2px;
}

/* ===========================
   MAIN LAYOUT
=========================== */
.main-layout{
  display:flex;
  justify-content:center;
  align-items:center;
  width:100%;
  height:calc(100vh - 52px);
  position:relative;
}
.battlefield{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-evenly;
  max-width:980px;
  width:100%;
  height:95%;
}
.player-area{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:6px 0;
  position:relative;
}
.hand,.bench,.active{
  display:flex;
  justify-content:center;
  gap:8px;
  flex-wrap:wrap;
  position:relative;
}
.bench,.active{
  min-height:calc(var(--card-h) + 6px);
}

/* ===========================
   CARD SLOTS + CARDS
=========================== */
.card-slot{
  width:var(--card-w);
  height:var(--card-h);
  border-radius:6px;
  background:#2f3238;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:10px;
  color:#a1a1aa;
  box-shadow:0 1px 3px rgba(0,0,0,.5);
  position:relative;
  flex-shrink:0;
  border:1px solid #3a3f46;
}
.slot-label{
  position:absolute;
  inset:auto 0 6px 0;
  text-align:center;
  font-weight:700;
  background:rgba(0,0,0,.7);
  color:#fff;
  border-radius:12px;
  line-height:1;
  padding:3px 8px;
  width:70px;
  margin:auto;
  font-size:10px;
  pointer-events:none;
}

/* base card image */
.card-img{
  width:var(--card-w);
  height:var(--card-h);
  object-fit:contain;
  border-radius:6px;
  cursor:pointer;
  transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
  z-index:2;
  position:relative;
  transform:perspective(700px) rotateX(0deg);
}

/* T-A tilt model (TCGL-style) */
.active .card-img{
  border:2px solid #ffd700;
  box-shadow:0 0 8px rgba(255,215,0,.6);
  transform:perspective(700px) rotateX(12deg);
}
.bench .card-img{
  transform:perspective(700px) rotateX(6deg);
}
.hand .card-img{
  transform:perspective(700px) rotateX(3deg);
}

/* subtle hover scaling per zone */
.active .card-img:hover{
  transform:perspective(700px) rotateX(12deg) scale(1.05);
}
.bench .card-img:hover{
  transform:perspective(700px) rotateX(6deg) scale(1.04);
}
.hand .card-img:hover{
  transform:perspective(700px) rotateX(3deg) scale(1.03);
}

/* player outlines */
#p1Active,#p1Bench{
  outline:1.5px solid #4da3ff;
  outline-offset:3px;
  border-radius:5px;
}
#p2Active,#p2Bench{
  outline:1.5px solid #ff6b6b;
  outline-offset:3px;
  border-radius:5px;
}

/* ===========================
   DECK BUBBLES + POINTS
=========================== */
.deck-bubble{
  position:absolute;
  width:32px;
  height:32px;
  border-radius:50%;
  background:#0b0f14;
  color:#fff;
  font-weight:700;
  font-size:12px;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 2px 6px rgba(0,0,0,.5);
  border:1px solid #334155;
}
#p1Bubble{left:-40px;top:50%;transform:translateY(-50%);}
#p2Bubble{right:-40px;top:50%;transform:translateY(-50%);}

.points-indicator{
  position:absolute;
  top:calc(50% + 26px);
  transform:translateY(-50%);
  display:flex;
  gap:6px;
  align-items:center;
  z-index:5;
}
#p1Points{left:4px;transform:translateX(-50%);}
#p2Points{right:4px;transform:translateX(50%);}
.point-bubble{
  width:14px;
  height:14px;
  border-radius:50%;
  border:1.5px solid #94a3b8;
  background:#0b0f14;
  box-shadow:0 0 4px rgba(0,0,0,.5);
  transition:background .25s,border-color .25s,box-shadow .25s;
}
.point-bubble.filled{
  background:#facc15;
  border-color:#fde047;
  box-shadow:0 0 6px 2px rgba(250,204,21,.65);
}

/* ===========================
   ENERGY ZONES
=========================== */
.energy-zone{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  justify-content:center;
}
.energy{
  width:28px;
  height:28px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  cursor:pointer;
  border:2px solid #3b3f46;
  box-shadow:0 1px 3px rgba(0,0,0,.6);
}
.energy-pips{
  position:absolute;
  left:3px;
  bottom:3px;
  height:16px;
  display:flex;
  gap:2px;
  z-index:3;
}
.energy-pip{
  width:16px;
  height:16px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #1f2937;
}

/* ===========================
   HP OVERLAY
=========================== */
.hp-overlay{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:22px;
  min-width:72px;
  text-align:center;
  background:rgba(0,0,0,.85);
  color:#fff;
  font-weight:800;
  font-size:10px;
  padding:2px 8px;
  border-radius:12px;
  z-index:3;
  line-height:1;
  white-space:nowrap;
  pointer-events:none;
}

/* ===========================
   TOOL THUMB + ZOOM TOOL PREVIEW
=========================== */
.tool-thumb{
  position:absolute;
  top:30px;
  left:6px;
  width:34px;
  height:44px;
  border-radius:4px;
  box-shadow:0 2px 6px rgba(0,0,0,.6);
  border:1px solid #111827;
  background-color:#0b0f14;
  z-index:4;
  cursor:pointer;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 5% 45% 5%);
  transition:transform .15s ease;
}
.tool-thumb:hover{transform:scale(1.12);}
#zoomTools img{
  width:88px;
  height:108px;
  border-radius:8px;
  border:1px solid #444;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 10% 45% 10%);
  box-shadow:0 0 8px rgba(0,0,0,.4);
  margin-top:8px;
}
#zoomTools{
  display:flex;
  align-items:center;
  gap:10px;
  padding:8px 0;
}

/* ===========================
   SIDE PANEL + COIN + BUTTONS
=========================== */
.side-panel{
  position:fixed;
  top:20px;
  right:20px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.6rem;
  z-index:10;
}
.coin{
  width:70px;
  height:70px;
  position:relative;
  transform-style:preserve-3d;
  transition:transform 1.5s ease-in-out;
}
.coin img{
  width:100%;
  height:100%;
  border-radius:50%;
  position:absolute;
  backface-visibility:hidden;
}
.coin .back{transform:rotateY(180deg);}
@keyframes flipCoin{
  0%{transform:rotateY(0);}
  50%{transform:rotateY(900deg);}
  100%{transform:rotateY(180deg);}
}
.coin.flip{animation:flipCoin 1.5s ease-in-out;}
#coinResult{
  text-align:center;
  font-weight:700;
  font-size:13px;
  min-height:35px;
}
button{
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  border:none;
  padding:8px 14px;
  border-radius:10px;
  cursor:pointer;
  font-size:.9rem;
  min-width:150px;
  box-shadow:0 4px 16px rgba(0,0,0,.35);
  border:1px solid #1f2937;
}
button:hover{opacity:.95;}
.turnbox{
  width:150px;
  border:1px solid #3b3f46;
  background:#23272e;
  border-radius:12px;
  padding:10px;
  text-align:center;
  font-size:.92rem;
  box-shadow:0 1px 3px rgba(0,0,0,.4);
  color:#e5e7eb;
}
.turnbox .big{
  font-weight:800;
  font-size:1.05rem;
}
#popup{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  background:rgba(17,17,17,.9);
  color:#fff;
  padding:10px 16px;
  border-radius:10px;
  font-size:14px;
  font-weight:800;
  opacity:0;
  z-index:200;
  transition:opacity .35s;
}
#popup.show{opacity:1;}
.disable-clicks{
  pointer-events:none;
  filter:saturate(.9) brightness(.98);
}
@keyframes glowPulse{
  0%{box-shadow:0 0 6px 2px rgba(59,130,246,.7);}
  100%{box-shadow:0 0 18px 6px rgba(59,130,246,1);}
}
.glow-evo{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(255,215,0,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(255,215,0,.85));
}
.promote-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(59,130,246,.95);
  border-radius:8px;
}

/* ===========================
   ATTACK MENU
=========================== */
.attack-menu{
  position:absolute;
  left:calc(100% + 8px);
  top:0;
  background:#1f232a;
  border:1px solid #3b3f46;
  border-radius:12px;
  box-shadow:0 14px 38px rgba(0,0,0,.5);
  padding:10px;
  min-width:230px;
  z-index:50;
  opacity:0;
  transform:translateY(-4px);
  transition:opacity .2s ease,transform .2s ease;
  color:#e5e7eb;
}
.attack-menu.show{
  opacity:1;
  transform:translateY(0);
}
.attack-item{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  padding:8px;
  border-radius:10px;
  cursor:pointer;
  background:linear-gradient(180deg,#2a2f36,#262b32);
  border:1px solid #3b3f46;
}
.attack-item.payable{
  background:linear-gradient(180deg,#1f3a4d,#1c3344);
}
.attack-item:hover{filter:brightness(.98);}
.attack-name{
  font-size:13px;
  font-weight:800;
  color:#e5e7eb;
}
.attack-cost{
  display:flex;
  gap:4px;
}
.cost-icon{
  width:16px;
  height:16px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
}
.cost-icon.missing{
  filter:grayscale(100%) brightness(50%);
}

/* damage flash */
@keyframes damageFlash{
  0%{filter:none;}
  50%{filter:hue-rotate(330deg) saturate(1.8);}
  100%{filter:none;}
}
.damage-flash{animation:damageFlash .4s ease;}

/* ===========================
   ZOOM MODAL (POKÉMON)
=========================== */
.zoom-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1000;
}
.zoom-backdrop.show{display:flex;}
.zoom-modal{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:1180px;
}
.zoom-modal img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
}
.zoom-panel{
  min-width:470px;
  max-width:520px;
  background:#1f232a;
  border:1px solid #3b3f46;
  border-radius:16px;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb;
}
.zoom-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:10px;
}
.zoom-title{
  font-weight:900;
  font-size:20px;
  color:#fff;
}
.zoom-hp{
  font-size:12px;
  color:#e5e7eb;
}
.zoom-type{
  width:24px;
  height:24px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
}
.hpbar-container{
  width:100%;
  height:12px;
  background:#2f343c;
  border-radius:8px;
  overflow:hidden;
  margin:8px 0 6px;
}
.hpbar-fill{
  height:100%;
  width:0;
  border-radius:8px;
  transition:width .2s ease, background .2s ease;
  background:linear-gradient(90deg,#22c55e,#16a34a);
}
.zoom-section{
  border-top:1px solid #3b3f46;
  margin-top:12px;
  padding-top:12px;
}
.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  margin:4px 0;
}
.chip{
  font-size:12px;
  background:#2a2f36;
  border:1px solid #3b3f46;
  border-radius:999px;
  padding:2px 8px;
  color:#e5e7eb;
}
.icon-row{
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:wrap;
}
.mini-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  display:inline-block;
}
.mini-badge{
  font-size:11px;
  color:#cbd5e1;
  margin-left:4px;
}

/* zoom attacks cards */
.zoom-attack{
  border:1px solid #3b3f46;
  border-radius:12px;
  padding:10px;
  margin:10px 0;
  cursor:pointer;
  transition:filter .15s,border-color .15s;
  background:#23272e;
}
.zoom-attack .top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  border-radius:10px;
  padding:8px 10px;
}
.zoom-attack .name{font-weight:800;}
.zoom-attack .dmg{font-weight:900;}
.thin{
  height:1px;
  background:#3b3f46;
  margin:8px 0;
}
.effect{
  font-size:12px;
  color:#cbd5e1;
  line-height:1.25;
}
.muted{opacity:.45;cursor:not-allowed;}
.mini-icon.missing{
  filter:grayscale(100%) brightness(65%);
}

/* ===========================
   DISCARD DRAWERS
=========================== */
.discard-btn{
  position:absolute;
  left:12px;
  top:50%;
  transform:translateY(-50%);
  z-index:9;
}
.discard-btn.right{
  left:auto;
  right:12px;
}
.discard-drawer{
  position:fixed;
  top:0;
  bottom:0;
  width:310px;
  background:#1f232a;
  border-right:1px solid #3b3f46;
  box-shadow:18px 0 30px rgba(0,0,0,.5);
  z-index:1200;
  padding:14px;
  display:none;
  overflow:auto;
  color:#e5e7eb;
}
.discard-drawer.right{
  right:0;
  left:auto;
  border-right:none;
  border-left:1px solid #3b3f46;
  box-shadow:-18px 0 30px rgba(0,0,0,.5);
}
.discard-drawer.show{display:block;}
.discard-item{
  display:flex;
  align-items:center;
  gap:10px;
  margin:10px 0;
}
.discard-item img{
  width:60px;
  height:84px;
  border-radius:8px;
  box-shadow:0 8px 18px rgba(0,0,0,.5);
}
.discard-group{
  display:flex;
  align-items:center;
  gap:10px;
}
.discard-count{
  font-weight:800;
  color:#e5e7eb;
  background:#2a2f36;
  border:1px solid #3b3f46;
  border-radius:999px;
  padding:2px 10px;
}

/* ===========================
   VICTORY OVERLAY
=========================== */
#victoryOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.68);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
#victoryCard{
  width:min(540px,92vw);
  background:#101418;
  border:1px solid #334155;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  padding:22px;
  color:#e5e7eb;
  text-align:center;
}
#victoryCard h2{
  margin:4px 0 8px 0;
  font-size:24px;
}
#victoryCard p{
  margin:6px 0 16px 0;
  color:#cbd5e1;
}
#victoryBtns{
  display:flex;
  gap:10px;
  justify-content:center;
}
#victoryOverlay,#victoryOverlay *{pointer-events:auto;}

/* ===========================
   TOOL FULLSCREEN MODAL
=========================== */
#toolBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1100;
}
#toolBackdrop.show{display:flex;}
#toolCard{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:980px;
}
#toolCard img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
}
#toolPanel{
  min-width:360px;
  max-width:420px;
  background:#1f232a;
  border:1px solid #3b3f46;
  border-radius:16px;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb;
}
#toolPanel h3{margin:0 0 8px 0;}

/* compress below Attached Energy/Tools in zoom */
#zoomAttached{padding-bottom:0!important;margin-bottom:0!important;}
#zoomAttached .row{margin:0 0 4px 0!important;}
#zoomTools{padding:0!important;}
#zoomTools img{margin-top:0!important;}
#zoomAttached+.zoom-section{margin-top:6px!important;padding-top:8px!important;}

/* ===========================
   ABILITY BOX (COMPACT)
=========================== */
.ability-box{
  border:1px solid #3b3f46;
  border-radius:10px;
  background:#23272e;
  margin:6px 0;
  padding:6px 8px;
}
.ability-head{
  display:flex;
  align-items:center;
  gap:6px;
  border-radius:8px;
  padding:6px 8px;
  font-weight:800;
  color:#0b0f14;
}
.ability-head img{
  width:60px;
  height:18px;
  border-radius:3px;
  display:block;
}
.ability-name{font-size:13px;}
.ability-text{
  font-size:12px;
  color:#cbd5e1;
  margin-top:6px;
  line-height:1.25;
}
.heal-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(74,222,128,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(74,222,128,.85));
}

/* ===========================
   FULL CLICKABLE RETREAT BAR
=========================== */
#zoomRetreatRow{
  border:1px solid #3b3f46;
  border-radius:10px;
  background:linear-gradient(180deg,#2a2f36,#262b32);
  transition:all .2s ease;
  margin-top:10px;
  padding:8px 10px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:700;
  color:#e5e7eb;
  user-select:none;
}
#zoomRetreatRow.enabled{cursor:pointer;}
#zoomRetreatRow.enabled:hover{
  filter:brightness(1.08);
  transform:scale(1.02);
}
#zoomRetreatRow.disabled{
  opacity:.5;
  cursor:not-allowed;
  filter:grayscale(80%);
}

/* hand modal type chip */
#handType{
  color:#fff;
  font-weight:700;
  border:none;
  text-transform:capitalize;
}

/* ===========================
   LOGGING PANEL (TCGL-STYLE)
=========================== */

/* toggle button */
#logToggleBtn{
  position:fixed;
  right:30px;
  top: 355px;
  z-index:1500;
  background:linear-gradient(90deg,#2a2f36,#1f232a);
  border:1px solid #334155;
  padding:8px 14px;
  color:#e5e7eb;
  border-radius:10px;
  font-size:.85rem;
  cursor:pointer;
  box-shadow:0 4px 10px rgba(0,0,0,.4);
}
#logToggleBtn:hover{filter:brightness(1.08);}

/* sliding panel */
#logPanel{
  position:fixed;
  top:100px;
  right:-360px;
  width:340px;
  height:calc(100vh - 140px);
  background:#101418;
  border-left:1px solid #334155;
  box-shadow:-12px 0 28px rgba(0,0,0,.55);
  padding:12px 12px 20px 12px;
  overflow-y:auto;
  transition:right .25s ease;
  z-index:1200;
  color:#e5e7eb;
}
#logPanel.show{right:20px;}

/* close button inside panel */
#closeLogBtn{
  background:#d92d2d;
  color:white;
  border:none;
  padding:6px 10px;
  border-radius:6px;
  cursor:pointer;
  font-size:12px;
  width:100%;
  margin-bottom:10px;
}
#closeLogBtn:hover{filter:brightness(.95);}

/* header bar */
#logPanelHeader{
  background:linear-gradient(90deg,#d92d2d,#a61c1c);
  color:white;
  padding:12px 14px;
  font-size:15px;
  font-weight:700;
  letter-spacing:.5px;
  border-bottom:2px solid #8a1414;
  margin-bottom:8px;
}

/* turn divider bar */
.turn-bar{
  background:linear-gradient(90deg,#2f343c,#242a31);
  border-top:1px solid #3b3f46;
  border-bottom:1px solid #3b3f46;
  padding:10px 14px;
  font-size:13px;
  font-weight:800;
  color:#e5e7eb;
  display:flex;
  align-items:center;
  gap:8px;
  box-shadow:0 2px 4px rgba(0,0,0,.12);
  margin-top:6px;
}
.turn-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  background:#d92d2d;
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-size:11px;
  font-weight:900;
}

/* live log entries */
.log-entry{
  background:#1f232a;
  border:1px solid #334155;
  border-left:4px solid #334155;
  padding:10px 12px;
  margin-bottom:12px;
  border-radius:10px;
  font-size:12px;
  line-height:1.35;
  color:#e5e7eb;
  box-shadow:0 2px 6px rgba(0,0,0,.35);
}
.log-entry.p1{border-left-color:#3b82f6;}
.log-entry.p2{border-left-color:#ef4444;}
.log-entry.sys{border-left-color:#9ca3af;}

.entry-player{
  font-weight:800;
  margin-bottom:4px;
}
.entry-player.p1{color:#1e73d8;}
.entry-player.p2{color:#d82020;}
.entry-player.sys{color:#888;}
.entry-text{line-height:1.35;}

/* card thumbnail inside log */
.log-thumb{
  width:48px;
  height:67px;
  border-radius:6px;
  margin-top:8px;
  box-shadow:0 2px 6px rgba(0,0,0,.45);
  border:1px solid #1f2937;
  cursor:pointer;
  align-self:flex-start;
}

/* ===========================
   MATCH HISTORY MODAL
=========================== */
#historyBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.7);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
#historyBackdrop.show{display:flex;}
#historyCard{
  width:min(600px,90vw);
  background:#101418;
  border:1px solid #334155;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  border-radius:16px;
  padding:20px;
  color:#e5e7eb;
  max-height:80vh;
  overflow-y:auto;
}
#historyCard h2{
  margin:0 0 10px 0;
  font-size:22px;
  text-align:center;
}
#fullHistory{
  font-size:13px;
  line-height:1.32;
}
.match-log-entry{
  background:#111827;
  border:1px solid #374151;
  border-left:4px solid #9ca3af;
  border-radius:8px;
  padding:8px 10px;
  box-shadow:0 2px 6px rgba(0,0,0,.4);
  margin-bottom:12px;
  color:#e5e7eb;
}

.ability-glow {
    animation: glowPulse 1.2s infinite;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(255,255,255,0.6);
}

@keyframes glowPulse {
    0% { box-shadow: 0 0 6px 2px rgba(255,255,255,0.4); }
    50% { box-shadow: 0 0 14px 4px rgba(255,255,255,0.8); }
    100% { box-shadow: 0 0 6px 2px rgba(255,255,255,0.4); }
}

.ability-disabled {
    opacity: 0.45;
    filter: grayscale(70%);
    pointer-events: none;
}


</style>

</head>
<body>
<h1>Pokémon TCG Pocket Battle</h1>
<div id="popup"></div>
<div class="main-layout">
  <div class="battlefield">
    <div class="player-area" id="player2">
      <div id="p2Bubble" class="deck-bubble">0</div>
      <div class="points-indicator" id="p2Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="hand" id="p2Hand"></div>
      <div class="bench" id="p2Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="active" id="p2Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <button class="discard-btn right" id="p2DiscardBtn">View Discard</button>
    </div>

    <div class="player-area" id="player1">
      <div id="p1Bubble" class="deck-bubble">0</div>
      <div class="points-indicator" id="p1Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="active" id="p1Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="bench" id="p1Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="hand" id="p1Hand"></div>
      <button class="discard-btn" id="p1DiscardBtn">View Discard</button>
    </div>
  </div>

  <div class="side-panel">
    <div class="coin" id="coin">
      <img class="front" src="https://archives.bulbagarden.net/media/upload/f/f5/TCGP_Coin_Special_Set_02.png" alt="Coin front">
      <img class="back" src="https://archives.bulbagarden.net/media/upload/a/aa/Coin_Back_TM.png" alt="Coin back">
    </div>
    <div id="coinResult"></div>
    <button id="mainButton">Draw Hands</button>
    <div class="turnbox">
      <div>Turn</div>
      <div id="turnNum" class="big">1</div>
      <div id="turnPlayer">Current: —</div>
    </div>
    <h4 style="margin:0 .25rem;">Energy Zone</h4>
    <div class="energy-zone" id="energyZone"></div>
    <button id="logToggleBtn">Show Log</button>
  </div>
</div>

<!-- Pokémon zoom modal -->
<div id="zoomBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <img id="zoomImg" src="" alt="Card zoom">
    <div class="zoom-panel">
      <div class="zoom-header">
        <div id="zoomTitle" class="zoom-title"></div>
        <div style="display:flex;align-items:center;gap:8px">
          <div id="zoomHp" class="zoom-hp"></div>
          <div id="zoomType" class="zoom-type"></div>
        </div>
      </div>
      <div class="hpbar-container"><div id="zoomHpBar" class="hpbar-fill"></div></div>
      <div class="zoom-section" id="zoomAttached">
        <div class="row">
          <div><strong>Attached Energy</strong></div>
          <div id="zoomEnergyCount" class="chip">x0</div>
        </div>
        <div id="zoomEnergyIcons" class="icon-row"></div>
        <div class="row" style="margin-top:10px">
          <div><strong>Attached Tools</strong></div>
          <div id="zoomTools" class="icon-row"></div>
        </div>
      </div>
      <div class="zoom-section" id="zoomAbilities" style="display:none"></div>
      <div class="zoom-section">
        <div><strong>Attacks</strong></div>
        <div id="zoomAttacks"></div>
      </div>
      <div class="zoom-section">
        <div class="row">
          <div><strong>Weakness</strong></div>
          <div id="zoomWeakness" class="icon-row"></div>
        </div>
        <div class="row" id="zoomRetreatRow">
          <div><strong>Retreat</strong></div>
          <div id="zoomRetreat" class="icon-row"></div>
        </div>
        <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:6px">Right-click anywhere or press Esc.</div>
      </div>
    </div>
  </div>
</div>

<!-- Tool modal -->
<div id="toolBackdrop">
  <div id="toolCard">
    <img id="toolImg" src="" alt="Tool Card">
    <div id="toolPanel">
      <h3 id="toolTitle">Tool</h3>
      <div id="toolMeta" class="chip" style="margin-bottom:8px"></div>
      <div class="thin" style="height:1px;background:#3b3f46;margin:8px 0"></div>
      <div id="toolText" style="font-size:13px;color:#cbd5e1;line-height:1.25"></div>
      <div style="margin-top:12px;font-size:12px;color:#9ca3af">Click outside to close.</div>
    </div>
  </div>
</div>

<!-- Hand Card modal -->
<div id="handBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <img id="handImg" src="" alt="Card image">
    <div class="zoom-panel" id="handPanel">
      <div id="handTitle" class="zoom-title"></div>
      <div id="handType" class="chip" style="margin-top:6px;"></div>
      <div id="handEffect" style="font-size:13px;color:#cbd5e1;margin-top:10px;line-height:1.4"></div>
      <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:12px">
        Right-click anywhere or press Esc to close.
      </div>
    </div>
  </div>
</div>

<!-- victory overlay -->
<div id="victoryOverlay">
  <div id="victoryCard">
    <h2 id="victoryTitle">Player Wins!</h2>
    <p id="victoryDesc">Game over</p>
    <div style="display:flex;justify-content:center;gap:12px;margin:10px 0 18px 0">
      <div class="chip">P1 Points: <span id="p1Pts">0</span></div>
      <div class="chip">P2 Points: <span id="p2Pts">0</span></div>
    </div>
    <div id="victoryBtns">
      <button id="playAgainBtn">Play again</button>
      <button id="chooseDecksBtn">Choose new decks</button>
      <button id="victoryShowLogBtn">Show Match Log</button>
    </div>
  </div>
</div>

<!-- discard drawers -->
<div class="discard-drawer" id="p1DiscardDrawer"></div>
<div class="discard-drawer right" id="p2DiscardDrawer"></div>

<!-- LOG PANEL (right slide) -->
<div id="logPanel">
  <div id="logPanelHeader">Battle Log</div>
  <button id="closeLogBtn" style="margin:8px 14px 10px;width:calc(100% - 28px);background:#e5e7eb;border:1px solid #c2c4c6;color:#111;padding:6px;border-radius:6px;cursor:pointer;">
    Close Log
  </button>
  <div id="logEntries"></div>
</div>


<!-- FULL MATCH HISTORY MODAL -->
<div id="historyBackdrop">
  <div id="historyCard">
    <h2>Match History</h2>
    <div id="fullHistory"></div>
    <div style="text-align:center;margin-top:14px;">
      <button onclick="document.getElementById('historyBackdrop').classList.remove('show')">
        Close
      </button>
    </div>
  </div>
</div>

<script type="module">
/* ========= imports ========= */
import { TRAINER_EFFECTS, applyMoveEffectFromCsv } from './effects.js';

/* ========= trainer CSV ========= */
let TRAINER_EFFECT_DATA=[];
fetch('trainer_effects.csv')
  .then(r=>r.text())
  .then(t=>{
    TRAINER_EFFECT_DATA=parseCSV(t);
    console.log('[trainer] CSV loaded:',TRAINER_EFFECT_DATA.length,'rows');
  });

function parseCSV(text){
  const rows=[];let i=0,f='',row=[],q=false;
  const pf=()=>{row.push(f);f=''},pr=()=>{if(row.length)rows.push(row);row=[]};
  while(i<text.length){
    const c=text[i];
    if(q){
      if(c==='"'&&text[i+1]==='"'){f+='"';i+=2;continue}
      if(c==='"'){q=false;i++;continue}
      f+=c;i++;continue;
    }else{
      if(c==='"'){q=true;i++;continue}
      if(c===','){pf();i++;continue}
      if(c==='\r'){i++;continue}
      if(c==='\n'){pf();pr();i++;continue}
      f+=c;i++;continue;
    }
  }
  if(f.length||row.length){pf();pr()}
  const [h,...b]=rows;
  if(!h) return[];
  return b.map(r=>Object.fromEntries(h.map((k,ix)=>[k.trim(),(r[ix]??'').trim()])));
}
const csvIdFor=(set,num)=>`${set}-${String(num).padStart(3,'0')}`;

/* ========= constants ========= */
const ENERGY_ICONS={
  fire:'https://archives.bulbagarden.net/media/upload/thumb/a/ad/Fire-attack.png/20px-Fire-attack.png',
  water:'https://archives.bulbagarden.net/media/upload/thumb/1/11/Water-attack.png/20px-Water-attack.png',
  grass:'https://archives.bulbagarden.net/media/upload/thumb/2/2e/Grass-attack.png/20px-Grass-attack.png',
  lightning:'https://archives.bulbagarden.net/media/upload/thumb/0/04/Lightning-attack.png/20px-Lightning-attack.png',
  psychic:'https://archives.bulbagarden.net/media/upload/thumb/e/ef/Psychic-attack.png/20px-Psychic-attack.png',
  fighting:'https://archives.bulbagarden.net/media/upload/thumb/4/48/Fighting-attack.png/20px-Fighting-attack.png',
  darkness:'https://archives.bulbagarden.net/media/upload/thumb/a/ab/Darkness-attack.png/20px-Darkness-attack.png',
  metal:'https://archives.bulbagarden.net/media/upload/thumb/6/64/Metal-attack.png/20px-Metal-attack.png',
  colorless:'https://archives.bulbagarden.net/media/upload/thumb/1/1d/Colorless-attack.png/30px-Colorless-attack.png'
};
const TYPE_HEX={
  fire:'#f08030',water:'#6890f0',grass:'#78c850',lightning:'#f8d030',
  psychic:'#f85888',fighting:'#c03028',darkness:'#705848',
  metal:'#b8b8d0',colorless:'#c6c6a7'
};
const ABILITY_BADGE='https://archives.bulbagarden.net/media/upload/thumb/0/06/TCGAbilityIcon.png/150px-TCGAbilityIcon.png';

/* ========= DOM ========= */
const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));

const popup=$('#popup'),
      energyZoneDiv=$('#energyZone'),
      coinEl=$('#coin'),
      coinResult=$('#coinResult'),
      mainButton=$('#mainButton'),
      turnNumEl=$('#turnNum'),
      turnPlayerEl=$('#turnPlayer');

const p1HandDiv=$('#p1Hand'),
      p2HandDiv=$('#p2Hand'),
      p1Active=$('#p1Active'),
      p2Active=$('#p2Active'),
      p1Bench=$('#p1Bench'),
      p2Bench=$('#p2Bench'),
      p1Bubble=$('#p1Bubble'),
      p2Bubble=$('#p2Bubble');

const zoomBackdrop=$('#zoomBackdrop'),
      zoomImg=$('#zoomImg'),
      zoomTitle=$('#zoomTitle'),
      zoomHp=$('#zoomHp'),
      zoomHpBar=$('#zoomHpBar'),
      zoomType=$('#zoomType'),
      zoomAttacks=$('#zoomAttacks'),
      zoomEnergyCount=$('#zoomEnergyCount'),
      zoomEnergyIcons=$('#zoomEnergyIcons'),
      zoomWeakness=$('#zoomWeakness'),
      zoomRetreat=$('#zoomRetreat'),
      zoomTools=$('#zoomTools'),
      zoomAbilities=$('#zoomAbilities');

const p1DiscardBtn=$('#p1DiscardBtn'),
      p2DiscardBtn=$('#p2DiscardBtn'),
      p1DiscardDrawer=$('#p1DiscardDrawer'),
      p2DiscardDrawer=$('#p2DiscardDrawer');

const victoryOverlay=$('#victoryOverlay'),
      victoryTitle=$('#victoryTitle'),
      victoryDesc=$('#victoryDesc'),
      p1PtsText=$('#p1Pts'),
      p2PtsText=$('#p2Pts'),
      playAgainBtn=$('#playAgainBtn'),
      chooseDecksBtn=$('#chooseDecksBtn');

const toolBackdrop=$('#toolBackdrop'),
      toolImg=$('#toolImg'),
      toolTitle=$('#toolTitle'),
      toolMeta=$('#toolMeta'),
      toolText=$('#toolText');

const handBackdrop=$('#handBackdrop'),
      handImg=$('#handImg'),
      handTitle=$('#handTitle'),
      handType=$('#handType'),
      handEffect=$('#handEffect');

/* log panel dom */
const logPanel=$('#logPanel'),
      logEntriesDiv=$('#logEntries'),
      logToggleBtn=$('#logToggleBtn'),
      historyBackdrop=$('#historyBackdrop'),
      fullHistoryDiv=$('#fullHistory');

/* ========= state ========= */
let turnNumber=1,currentPlayer=null,firstPlayer=null;
let hasAttachedEnergyThisTurn=false,selectedEnergy=null,isSetupPhase=true;
let isEvoMode=false,evoMeta=null,evoOwner=null,evoHandCard=null;
let isPromotionPhase=false,openAttackMenu=null,gameOver=false,hasRetreatedThisTurn=false;
const hasPlayedSupporterThisTurn={player1:false,player2:false};
let p1Points=0,p2Points=0,toolAttachPending=null,currentZoom={img:null,meta:null};

const playerState={
  player1:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player1Energy')||'[]'),discard:{cards:[],energyCounts:{}} },
  player2:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player2Energy')||'[]'),discard:{cards:[],energyCounts:{}} }
};

function expandDeck(raw){
  const out=[];
  (raw||[]).forEach(c=>{
    if(!c||!c.name||!c.set||(c.number??c.num)==null)return;
    const n=Number(c.quantity)||1;
    for(let i=0;i<n;i++)out.push({...c,quantity:1});
  });
  return out;
}
playerState.player1.deck=expandDeck(JSON.parse(localStorage.getItem('player1Deck')||'[]'));
playerState.player2.deck=expandDeck(JSON.parse(localStorage.getItem('player2Deck')||'[]'));

/* ========= logging ========= */

let fullHistoryLog=[];
let logCounter=1;

function highImgUrl(set,num){
  if(!set || num==null) return null;
  return `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3,'0')}/high.png`;
}

function logEvent({ player, text, cardSet = null, cardNum = null }) {
  const id = logCounter++;
  const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  const who =
    player === 'player1' ? 'Player 1' :
    player === 'player2' ? 'Player 2' : 'System';

  const cls =
    player === 'player1' ? 'p1' :
    player === 'player2' ? 'p2' : 'sys';

  // build image URL if we have set/num
  const imgUrl = (cardSet && cardNum) ? highImgUrl(cardSet, cardNum) : null;

  // create the log entry element
  const div = document.createElement('div');
  div.className = `log-entry ${cls}`;
  div.dataset.id = id;

  div.innerHTML = `
    <div class="entry-player ${cls}">${who}</div>
    <div class="entry-text">${text}</div>
    ${imgUrl ? `<img class="log-thumb" src="${imgUrl}" alt="card">` : '' }
  `;

  logEntriesDiv.appendChild(div);
  logEntriesDiv.scrollTop = logEntriesDiv.scrollHeight;

  // store for match history modal
  fullHistoryLog.push({ id, ts, player: who, text, cardSet, cardNum, imgUrl });
}

/* === CLICK CARD IN LOG → OPEN FULLSCREEN MODAL (FULLY POPULATED FIELDS) === */
logEntriesDiv.addEventListener("click", async (e) => {
  const thumb = e.target.closest(".log-thumb");
  if (!thumb) return;

  // Extract set + num from image URL
  const match = thumb.src.match(/tcgp\/([^\/]+)\/(\d{3})/i);
  if (!match) return;

  const set = match[1];
  const num = match[2];

  let meta;
  try {
    meta = await fetchCardMeta(set, num);
  } catch (err) {
    console.error("Failed to fetch meta", err);
    showPopup("Unable to load card details.");
    return;
  }

  const category = (meta.category || "").toLowerCase();

  // === Create a FAKE BOARD IMAGE so buildZoomPanel() can populate all fields ===
  const fakeImg = document.createElement("img");
  fakeImg.dataset.set = set;
  fakeImg.dataset.num = num;
  fakeImg.dataset.hp = meta.hp || "0";
  fakeImg.dataset.chp = meta.hp || "0";
  fakeImg.src = thumb.src;
  fakeImg.alt = meta.name;

  // Wrap in a temporary fake card-slot with no energies or tools
  const fakeSlot = document.createElement("div");
  fakeSlot.className = "card-slot";
  fakeSlot.appendChild(fakeImg);

  // Add empty energy & tool containers so zoom panel displays correctly
  const fakePips = document.createElement("div");
  fakePips.className = "energy-pips";
  fakeSlot.appendChild(fakePips);

  const fakeHP = document.createElement("div");
  fakeHP.className = "hp-overlay";
  fakeHP.textContent = `${meta.hp} / ${meta.hp}`;
  fakeSlot.appendChild(fakeHP);

  // === Pokémon handling ===
  if (category === "pokemon") {
    zoomImg.src = thumb.src;
    zoomBackdrop.classList.add("show");

    // Create a hidden container so fake card-slot exists in the DOM
    const tempWrap = document.createElement("div");
    tempWrap.style.display = "none";
    tempWrap.appendChild(fakeSlot);
    document.body.appendChild(tempWrap);

    await buildZoomPanel(meta, fakeImg);

    // Clean up after zoom closes
    zoomBackdrop.addEventListener("transitionend", () => {
      if (!zoomBackdrop.classList.contains("show")) {
        tempWrap.remove();
      }
    }, { once: true });

    return;

  }

  // === Trainer handling ===
  handImg.src = thumb.src;
  handBackdrop.classList.add("show");
  handTitle.textContent = meta.name || "Trainer Card";
  handType.textContent = meta.trainerType || "Trainer";
  handType.style.background = trainerColor(meta.trainerType || "trainer");
  handEffect.textContent = meta.effect || meta.description || "No effect listed.";
});


if(logToggleBtn){
  logToggleBtn.onclick = () => {
    logPanel.classList.toggle('show');
  };
}
/* === log panel close logic === */
const closeLogBtn = document.getElementById("closeLogBtn");

if (closeLogBtn) {
  closeLogBtn.onclick = () => {
    logPanel.classList.remove("show");
  };
}

// Escape closes log
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    logPanel.classList.remove("show");
  }
});

if(historyBackdrop){
  historyBackdrop.addEventListener('click',e=>{
    if(e.target===historyBackdrop) historyBackdrop.classList.remove('show');
  });
}

/* ========= utils ========= */
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
function showPopup(msg){if(!popup)return;popup.textContent=msg;popup.classList.add('show');setTimeout(()=>popup.classList.remove('show'),1100)}
function updateDeckBubbles(){if(p1Bubble)p1Bubble.textContent=playerState.player1.deck.length;if(p2Bubble)p2Bubble.textContent=playerState.player2.deck.length}
function updatePointsUI(){
  const f=(id,pts)=>{$$(`#${id} .point-bubble`).forEach(b=>b.classList.toggle('filled',Number(b.dataset.i)<=pts))};
  f('p1Points',p1Points);f('p2Points',p2Points);
}
function updateTurnBox(){
  if(turnNumEl)turnNumEl.textContent=turnNumber;
  if(turnPlayerEl)turnPlayerEl.textContent=`Current: ${currentPlayer?currentPlayer.replace('player','Player '):'—'}`;
}
const activeFor=p=>p==='player1'?p1Active:p2Active;
const benchFor=p=>p==='player1'?p1Bench:p2Bench;
const handDivFor=p=>p==='player1'?p1HandDiv:p2HandDiv;
const opponentOf=p=>p==='player1'?'player2':'player1';

// also add in the state section:
let damageBoostThisTurn = {
  player1: { flatAll: 0, flatByName: {} },
  player2: { flatAll: 0, flatByName: {} }
};
globalThis.damageBoostThisTurn = damageBoostThisTurn;
globalThis.resetDamageBoostsFor = function (playerKey) {
  const slot = damageBoostThisTurn[playerKey];
  if (!slot) return;
  slot.flatAll = 0;
  slot.flatByName = {};
};

function markSlot(slot,has){
  const lab=slot.querySelector('.slot-label');
  slot.dataset.empty=has?'0':'1';
  if(lab)lab.style.display=has?'none':'block';
}

const metaCache={};
async function fetchCardMeta(set,num){
  const key=`${set}-${num}`;
  if(metaCache[key])return metaCache[key];
  const r=await fetch(`https://api.tcgdex.net/v2/en/sets/${set}/${num}`);
  if(!r.ok)throw new Error('meta');
  const d=await r.json();
  metaCache[key]=d;
  return d;
}
async function isBasicPokemon(set,num){
  try{
    const d=await fetchCardMeta(set,num);
    return String(d.category||'').toLowerCase()==='pokemon' &&
           String(d.stage||'').toLowerCase()==='basic';
  }catch{return false}
}

function setHpOnImage(img,baseHp,chp){
  img.dataset.hp=String(baseHp);
  img.dataset.chp=String(chp);
  const slot=img.closest('.card-slot');
  if(!slot)return;
  let hpDiv=slot.querySelector('.hp-overlay');
  if(!hpDiv){
    hpDiv=document.createElement('div');
    hpDiv.className='hp-overlay';
    slot.appendChild(hpDiv);
  }
  hpDiv.textContent=`${chp} / ${baseHp}`;
}

/* ========= hand render ========= */
function renderHand(div,cards,hide=false){
  const owner=div.id==='p1Hand'?'player1':'player2';
  div.innerHTML=(cards||[]).map(c=>{
    const src=hide?'https://archives.bulbagarden.net/media/upload/1/17/Cardback.jpg':(c.image||'https://archives.bulbagarden.net/media/upload/1/17/Cardback.jpg');
    return `<div class="card-slot" data-empty="0"><img class="card-img" src="${src}" alt="${c.name}" data-owner="${owner}" data-set="${c.set}" data-num="${c.number||c.num}"></div>`;
  }).join('');
}
function removeFromHand(owner,set,num){
  const h=playerState[owner].hand;
  const i=h.findIndex(c=>c.set===set&&String(c.number||c.num)===String(num));
  if(i>=0)h.splice(i,1);
}
function renderAllHands(){
  const p1Hide=currentPlayer==='player2',
        p2Hide=currentPlayer==='player1';
  renderHand(p1HandDiv,playerState.player1.hand,p1Hide);
  renderHand(p2HandDiv,playerState.player2.hand,p2Hide);
  p1HandDiv.classList.toggle('disable-clicks',currentPlayer==='player2');
  p2HandDiv.classList.toggle('disable-clicks',currentPlayer==='player1');
}

/* ========= tools ========= */
function getToolDataFromSlot(slot){
  const set=slot.dataset.toolSet||null,
        num=slot.dataset.toolNum||null,
        src=slot.dataset.toolSrc||null;
  return set&&num&&src?{set,num,src}:null;
}
function setToolDataOnSlot(slot,tool){
  if(tool){
    slot.dataset.toolSet=tool.set;
    slot.dataset.toolNum=tool.num;
    slot.dataset.toolSrc=tool.src;
  }else{
    delete slot.dataset.toolSet;
    delete slot.dataset.toolNum;
    delete slot.dataset.toolSrc;
  }
}
function ensureToolThumb(slot){
  let th=slot.querySelector('.tool-thumb');
  if(!th){
    th=document.createElement('img');
    th.className='tool-thumb';
    th.title='Tool';
    slot.appendChild(th);
  }
  return th;
}
function removeToolThumb(slot){
  const th=slot.querySelector('.tool-thumb');
  if(th)th.remove();
}
async function attachToolToSlot(owner,slot,toolObj){
  if(!slot||!toolObj)return;
  const img=slot.querySelector('img');
  if(!img){showPopup('Attach to a Pokémon in play.');return}
  if(getToolDataFromSlot(slot)){showPopup('This Pokémon already has a Tool attached.');return}
  try{
    const metaP=await fetchCardMeta(img.dataset.set,img.dataset.num);
    if(String(metaP.category||'').toLowerCase()!=='pokemon'){
      showPopup('Attach only to Pokémon.');
      return;
    }
  }catch{
    showPopup('Error verifying Pokémon.');
    return;
  }
  setToolDataOnSlot(slot,toolObj);
  const th=ensureToolThumb(slot);
  th.src=toolObj.src;
  th.onclick=async ev=>{
    ev.stopPropagation();
    await openToolModal(toolObj.set,toolObj.num,toolObj.src);
  };
  showPopup('Tool attached');
}

/* ========= hand modal ========= */
if(handBackdrop){
  handBackdrop.addEventListener('click',e=>{
    if(e.target===handBackdrop)handBackdrop.classList.remove('show');
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape')handBackdrop.classList.remove('show');
  });
}
function trainerColor(type){
  const t=String(type||'').toLowerCase();
  if(t.includes('supporter'))return'#e45803';
  if(t.includes('item'))return'#0167b6';
  if(t.includes('tool'))return'#6e4e9c';
  return'#3b3f46';
}

/* ========= energy + costs ========= */
function countPipsOn(slot){
  const out={total:0};
  slot.querySelectorAll('.energy-pip').forEach(p=>{
    const t=(p.dataset.type||'colorless').toLowerCase();
    out[t]=(out[t]||0)+1;
    out.total++;
  });
  return out;
}
function satisfiedFlags(pips,costArr){
  const cnt={...pips};const keys=Object.keys(cnt).filter(k=>k!=='total');const f=[];
  (costArr||[]).forEach(t=>{
    const k=String(t||'').toLowerCase();
    if(k==='colorless'){
      let ok=false;
      for(const tp of keys){
        if((cnt[tp]||0)>0){
          cnt[tp]--;cnt.total--;ok=true;break;
        }
      }
      f.push(ok);
    }else{
      if((cnt[k]||0)>0){cnt[k]--;cnt.total--;f.push(true)}
      else f.push(false);
    }
  });
  return f;
}
function canPayCostFromAPI(slot,costArr){
  return satisfiedFlags(countPipsOn(slot),costArr||[]).every(Boolean);
}
const energyIconUrl=k=>ENERGY_ICONS[k==='electric'?'lightning':k]||ENERGY_ICONS.colorless;
function extractAbilities(meta) {
  if (!meta) return [];
  // Standard case: array of abilities
  if (Array.isArray(meta.abilities)) return meta.abilities;
  // Some cards might expose a single ability object
  if (meta.abilities && typeof meta.abilities === 'object') return [meta.abilities];
  // Fallback if the API ever uses a single "ability" field
  if (meta.ability) return [meta.ability];
  return [];
}

function makeCostIcons(costArr,slot){
  const wrap=document.createElement('div');
  wrap.className='attack-cost';
  const flags=satisfiedFlags(countPipsOn(slot),costArr||[]);
  (costArr||[]).forEach((t,i)=>{
    const ic=document.createElement('div');
    ic.className='cost-icon';
    ic.style.backgroundImage=`url('${energyIconUrl(String(t||'').toLowerCase())}')`;
    if(!flags[i])ic.classList.add('missing');
    wrap.appendChild(ic);
  });
  return wrap;
}

/* ========= damage / KO ========= */
const parseDamage=v=>{const m=String(v??'').match(/\d+/);return m?parseInt(m[0],10):0};
const getActiveImage=p=>activeFor(p).querySelector('img')||null;

function pushCardToDiscard(owner,img){
  playerState[owner].discard.cards.push({set:img.dataset.set,num:img.dataset.num,src:img.src});
}
function moveCardToDiscard(owner,img){
  const slot=img.closest('.card-slot');
  const tool=getToolDataFromSlot(slot);
  if(tool){
    playerState[owner].discard.cards.push({set:tool.set,num:tool.num,src:tool.src});
    removeToolThumb(slot);
    setToolDataOnSlot(slot,null);
  }
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  pushCardToDiscard(owner,img);
  const pips=countPipsOn(slot);
  Object.keys(pips).forEach(k=>{
    if(k==='total')return;
    playerState[owner].discard.energyCounts[k]=(playerState[owner].discard.energyCounts[k]||0)+pips[k];
  });
  slot.innerHTML='';
  slot.classList.remove('damage-flash');
  const lab=document.createElement('span');
  lab.className='slot-label';
  lab.textContent='Empty';
  slot.appendChild(lab);
  markSlot(slot,false);
  if(drawer.classList.contains('show'))renderDiscard(owner);
}
async function pointsForCard(set,num){
  try{
    const meta=await fetchCardMeta(set,num);
    const s=(meta.suffix||'').toUpperCase();
    const name=(meta.name||'').toLowerCase();
    if(s==='EX'&&name.includes('mega'))return 3;
    if(s==='EX')return 2;
  }catch{}
  return 1;
}
const checkBenchOut=owner=>[...benchFor(owner).querySelectorAll('img')].length===0;

function showVictory(winnerKey,reason){
  if(gameOver)return;
  gameOver=true;
  $('.main-layout')?.classList.add('disable-clicks');
  $('.side-panel')?.classList.add('disable-clicks');
  victoryTitle.textContent=winnerKey==='player1'?'Player 1 Wins!':'Player 2 Wins!';
  victoryDesc.textContent=reason||'Game over';
  p1PtsText.textContent=String(p1Points);
  p2PtsText.textContent=String(p2Points);
  victoryOverlay.style.display='flex';
}

async function handleKnockOut(owner,img){
  const set=img.dataset.set,
        num=img.dataset.num;
  const foe=owner==='player1'?'player2':'player1';
  logEvent({
    player: foe,
    text:`Knocked out ${img.alt || 'a Pokémon'}.`,
    cardSet:set,cardNum:num
  });

  moveCardToDiscard(owner,img);
  const pts=await pointsForCard(set,num);
  if(foe==='player1')p1Points+=pts;else p2Points+=pts;
  updatePointsUI();
  if(p1Points>=3||p2Points>=3){
    showVictory(p1Points>=3?'player1':'player2','Reached 3 points');
    return true;
  }
  if(checkBenchOut(owner)){
    showVictory(foe,'Bench out');
    return true;
  }
  return false;
}

function damageActiveOf(player,amount){
  const img=getActiveImage(player);
  if(!img)return{knocked:false,hpText:''};
  const base=parseInt(img.dataset.hp||'0',10)||0;
  let chp=parseInt(img.dataset.chp||base||'0',10)||base;
  chp=Math.max(0,chp-amount);
  setHpOnImage(img,base,chp);
  const slot=img.closest('.card-slot');
  slot.classList.add('damage-flash');
  setTimeout(()=>slot.classList.remove('damage-flash'),400);

  if(currentZoom.img && currentZoom.img===img){
    const pct=base>0?Math.round((chp/base)*100):0;
    zoomHp.textContent=`HP: ${chp} / ${base}`;
    zoomHpBar.style.width=pct+"%";
    zoomHpBar.style.background=(chp===base)
      ?'linear-gradient(90deg,#22c55e,#16a34a)'
      :'linear-gradient(90deg,#f43f5e,#ef4444)';
  }

  if(chp<=0){
    const owner=img.closest('#player1')?'player1':'player2';
    return{knocked:true,owner};
  }
  return{knocked:false};
}

function animateCardToHand(pk, cardObj) {
  // Create ghost thumbnail
  const img = document.createElement('img');
  img.src = cardObj.image;
  img.style.position = 'fixed';
  img.style.width = '48px';
  img.style.height = '67px';
  img.style.pointerEvents = 'none';
  img.style.zIndex = 99999;
  img.style.borderRadius = '6px';
  img.style.left = '50%';
  img.style.top = '50%';
  img.style.transform = 'translate(-50%, -50%) scale(2)';
  img.style.opacity = '1';
  img.style.transition = 'all .4s ease-out';

  document.body.appendChild(img);

  // Destination: player's hand bar
  const handElm = pk === 'p1' ? document.getElementById('p1Hand') : document.getElementById('p2Hand');
  const rect = handElm.getBoundingClientRect();

  setTimeout(() => {
    img.style.left = rect.left + 40 + 'px';
    img.style.top = rect.top + 10 + 'px';
    img.style.transform = 'translate(0,0) scale(.6)';
    img.style.opacity = '0';
  }, 20);

  setTimeout(() => img.remove(), 420);
}

/* ========= discard UI ========= */
function renderDiscard(owner){
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  const {cards,energyCounts}=playerState[owner].discard;
  drawer.innerHTML=`
    <h3 style="margin:10px 0 6px;">
      ${owner==='player1'?'Player 1':'Player 2'} Discard (${cards.length+Object.values(energyCounts).reduce((a,b)=>a+b,0)})
    </h3>
    <button style="margin-bottom:10px" onclick="document.getElementById('${owner==='player1'?'p1DiscardDrawer':'p2DiscardDrawer'}').classList.remove('show')">Close</button>
  `;
  const energiesRow=document.createElement('div');
  energiesRow.style.display='flex';
  energiesRow.style.flexDirection='column';
  Object.keys(energyCounts).forEach(k=>{
    const row=document.createElement('div');
    row.className='discard-item';
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
    ico.style.width='26px';ico.style.height='26px';
    const cnt=document.createElement('span');
    cnt.className='discard-count';
    cnt.textContent=`x${energyCounts[k]}`;
    row.appendChild(ico);row.appendChild(cnt);
    energiesRow.appendChild(row);
  });
  drawer.appendChild(energiesRow);
  cards.forEach(c=>{
    const row=document.createElement('div');
    row.className='discard-item';
    const im=document.createElement('img');
    im.src=c.src;
    row.appendChild(im);
    drawer.appendChild(row);
  });
}

/* ========= attack menu + retreat ========= */
function closeAttackMenu(){
  if(openAttackMenu&&openAttackMenu.parentElement){
    openAttackMenu.parentElement.removeChild(openAttackMenu);
  }
  openAttackMenu=null;
}

function computeRetreatCost(activeDiv, meta) {
  const base = Number(meta.retreat || meta.retreatCost || 0) || 0;

  // If this card is not actually in an .active div (e.g. opened from log),
  // just return the base retreat cost and skip temp modifiers.
  if (!activeDiv) return base;

  const abs = activeDiv.dataset.tempRetreat;
  const red = Number(activeDiv.dataset.tempRetreatReduce || '0') || 0;

  if (abs != null) return Math.max(0, Number(abs));
  return Math.max(0, base - red);
}

function addRetreatRow(menu, activeDiv, meta){
  const slot = activeDiv.querySelector('.card-slot');
  const costCount = computeRetreatCost(activeDiv, meta);
  const row = document.createElement('div');
  row.style.marginTop = '6px';
  row.innerHTML = '<div class="thin"></div>';

  const btn = document.createElement('div');
  btn.className = 'attack-item';

  const left = document.createElement('div');
  left.style.display = 'flex';
  left.style.alignItems = 'center';
  left.style.gap = '6px';
  const nm = document.createElement('div');
  nm.className = 'attack-name';
  nm.textContent = 'Retreat';
  left.appendChild(nm);

  const icons = document.createElement('div');
  icons.className = 'attack-cost';
  if (costCount > 0) {
    const flags = satisfiedFlags(countPipsOn(slot), Array(costCount).fill('colorless'));
    for (let i = 0; i < costCount; i++) {
      const ic = document.createElement('div');
      ic.className = 'cost-icon';
      ic.style.backgroundImage = `url('${ENERGY_ICONS.colorless}')`;
      if (!flags[i]) ic.classList.add('missing');
      icons.appendChild(ic);
    }
  }
  left.appendChild(icons);

  const arrow = document.createElement('div');
  arrow.style.fontWeight = '900';
  arrow.textContent = '⟲';
  btn.appendChild(left);
  btn.appendChild(arrow);

  const canPay = costCount === 0 || canPayCostFromAPI(slot, Array(costCount).fill('colorless'));
  const hasBench = [...benchFor(currentPlayer).querySelectorAll('img')].length > 0;
  const canRetreat = hasBench && canPay && !hasRetreatedThisTurn;

  if (canRetreat) btn.classList.add('payable');
  else btn.classList.add('muted');

  btn.onclick = () => {
    if (!canRetreat) {
      showPopup(hasRetreatedThisTurn ? 'You can only retreat once per turn.' : 'Cannot retreat.');
      return;
    }

    // discard only up to retreat cost
    let toDiscard = costCount;
    const energyBox = slot.querySelector('.energy-pips');
    if (energyBox && toDiscard > 0) {
      const pips = [...energyBox.querySelectorAll('.energy-pip')];
      for (const pip of pips) {
        if (toDiscard <= 0) break;
        pip.remove();
        toDiscard--;
        const type = (pip.dataset.type || 'colorless').toLowerCase();
        playerState[currentPlayer].discard.energyCounts[type] =
          (playerState[currentPlayer].discard.energyCounts[type] || 0) + 1;
      }
    }

    // consume temporary retreat mods
    if (activeDiv.dataset.tempRetreatReduce != null) {
      delete activeDiv.dataset.tempRetreatReduce;
    }
    if (activeDiv.dataset.tempRetreat != null) {
      delete activeDiv.dataset.tempRetreat;
    }

    hasRetreatedThisTurn = true;

    const activeImg = activeDiv.querySelector('img');
    if (activeImg) {
      logEvent({
        player: currentPlayer,
        text: 'Retreated Active Pokémon.',
        cardSet: activeImg.dataset.set,
        cardNum: activeImg.dataset.num
      });
    }

    beginPromotionFlow(currentPlayer);
    showPopup('Choose a Benched Pokémon to promote.');
    closeAttackMenu();
  };

  row.appendChild(btn);
  menu.appendChild(row);
}


function showAttackMenuFor(activeDiv, meta) {
  closeAttackMenu();

  const menu = document.createElement('div');
  menu.className = 'attack-menu';

  const slot = activeDiv.querySelector('.card-slot');
  const cardImg = activeDiv.querySelector('img');

  /* -------------------------------------------------------
     ABILITY HEADER ABOVE ATTACKS (non-clickable, muted)
  -------------------------------------------------------- */
  const abilities = extractAbilities(meta);
  if (abilities.length > 0) {
    const ab = abilities[0]; // TCG Pocket: at most one ability

    const abilityRow = document.createElement('div');
    abilityRow.style.marginBottom = '10px';

    const abilityBox = document.createElement('div');
    abilityBox.className = 'attack-item muted';
    abilityBox.style.cursor = 'default';
    abilityBox.style.display = 'flex';
    abilityBox.style.alignItems = 'center';
    abilityBox.style.justifyContent = 'flex-start';
    abilityBox.style.gap = '8px';
    abilityBox.style.padding = '6px 8px';

    const badge = document.createElement('img');
    badge.src = ABILITY_BADGE;
    badge.style.width = '50px';
    badge.style.height = '22px';
    badge.style.borderRadius = '3px';

    const abilityName = document.createElement('div');
    abilityName.style.fontWeight = '800';
    abilityName.style.fontSize = '13px';
    abilityName.style.color = '#e5e7eb';
    abilityName.textContent = ab.name || 'Ability';

    abilityBox.appendChild(badge);
    abilityBox.appendChild(abilityName);
    abilityRow.appendChild(abilityBox);
    menu.appendChild(abilityRow);
  }

  /* -------------------------------------------------------
     ATTACKS
  -------------------------------------------------------- */
  (meta.attacks || []).forEach(atk => {
    const item = document.createElement('div');
    item.className = 'attack-item';

    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.alignItems = 'center';
    left.style.gap = '6px';

    const nm = document.createElement('div');
    nm.className = 'attack-name';
    nm.textContent = atk.name || 'Attack';

    left.appendChild(nm);
    left.appendChild(makeCostIcons(atk.cost || [], slot));

    const dmg = document.createElement('div');
    dmg.style.fontWeight = '900';
    dmg.textContent = (atk.damage || '').toString();

    item.appendChild(left);
    item.appendChild(dmg);

    const payable = canPayCostFromAPI(slot, atk.cost || []);
    if (payable) item.classList.add('payable');

    item.onclick = async () => {
      if (!payable) {
        showPopup('Not enough energy to use this attack.');
        closeAttackMenu();
        return;
      }

      const foe = opponentOf(currentPlayer);
      const pk  = currentPlayer === 'player1' ? 'p1' : 'p2';

      // Base printed damage (can be 0 for pure-effect attacks)
      let baseDamage = parseDamage(atk.damage);

      // Wrap state into { p1, p2 } as expected by effects.js
      const effectState = {
        p1: playerState.player1,
        p2: playerState.player2
      };

      /* === PREVIEW PASS (no side effects) === */
      let previewDamage = baseDamage;
      try {
        previewDamage = await applyMoveEffectFromCsv(
          effectState,
          pk,
          atk.name,
          baseDamage,
          { isFinal: false }
        );
      } catch (err) {
        console.error('Move preview error:', err);
        previewDamage = baseDamage;
      }

      /* === WEAKNESS (only vs opponent Active, non-Colorless weakness) === */
      try {
        const foeImg = getActiveImage(foe);
        if (foeImg) {
          const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
          const wk = metaFoe?.weaknesses?.[0];

          if (wk) {
            const wkType = (wk.type || '').toLowerCase();
            if (wkType !== 'colorless') {
              const atkType = (meta.types?.[0] || '').toLowerCase();
              if (atkType === wkType) {
                previewDamage += 20; // Pocket: +20 for weakness
              }
            }
          }
        }
      } catch (err) {
        console.error('Weakness check failed:', err);
      }

      /* === FINAL PASS (apply side effects; may change damage) === */
      let finalDamage = previewDamage;
      try {
        finalDamage = await applyMoveEffectFromCsv(
          effectState,
          pk,
          atk.name,
          previewDamage,
          { isFinal: true, damageDealt: previewDamage }
        );
      } catch (err) {
        console.error('Move final error:', err);
        finalDamage = previewDamage;
      }

      /* === APPLY DAMAGE TO ACTIVE === */
      const result = damageActiveOf(foe, finalDamage);

      /* === HANDLE KO === */
      if (result.knocked) {
        const foeImg2 = getActiveImage(foe);
        if (foeImg2) {
          const ended = await handleKnockOut(foe, foeImg2);
          if (ended) {
            closeAttackMenu();
            return;
          }
          beginPromotionFlow(foe);
        }
      }

      closeAttackMenu();
      startTurn(foe);
    };

    menu.appendChild(item);
  });

  /* -------------------------------------------------------
     RETREAT ROW
  -------------------------------------------------------- */
  addRetreatRow(menu, activeDiv, meta);

  /* -------------------------------------------------------
     OPEN MENU
  -------------------------------------------------------- */
  activeDiv.style.position = 'relative';
  activeDiv.appendChild(menu);

  requestAnimationFrame(() => menu.classList.add('show'));
  openAttackMenu = menu;
}


/* ========= zoom ========= */
async function buildZoomPanel(meta,img){
  currentZoom={img,meta};

  zoomTitle.textContent=meta.name||'Pokémon';

  const mainType=(meta.types&&meta.types[0])?String(meta.types[0]).toLowerCase():null;
  zoomType.style.display=mainType?"block":"none";
  if(mainType)zoomType.style.backgroundImage=`url('${energyIconUrl(mainType)}')`;

  const base=parseInt(img.dataset.hp||meta.hp||'0',10)||0;
  const chp=parseInt(img.dataset.chp||base||'0',10)||base;

  zoomHp.textContent=`HP: ${chp} / ${base}`;
  const pct=base>0?Math.round((chp/base)*100):0;

  zoomHpBar.style.width=pct+'%';
  zoomHpBar.style.background=
    (chp===base)
      ?'linear-gradient(90deg,#22c55e,#16a34a)'
      :'linear-gradient(90deg,#f43f5e,#ef4444)';

  /* Energy section */
  const slot=img.closest('.card-slot');
  const pips=countPipsOn(slot);

  zoomEnergyCount.textContent=`x${pips.total||0}`;
  zoomEnergyIcons.innerHTML='';

  Object.keys(pips).filter(k=>k!=='total').forEach(k=>{
    for(let i=0;i<pips[k];i++){
      const ico=document.createElement('span');
      ico.className='mini-icon';
      ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
      zoomEnergyIcons.appendChild(ico);
    }
  });

  /* Tool display */
  zoomTools.innerHTML='';
  const tool=getToolDataFromSlot(slot);

  if(tool){
    const tImg=document.createElement('img');
    tImg.src=tool.src;
    tImg.alt='Tool';
    tImg.style.borderRadius='4px';
    tImg.style.boxShadow='0 2px 6px rgba(0,0,0,.6)';
    tImg.style.cursor='pointer';
    tImg.onclick=async ev=>{
      ev.stopPropagation();
      await openToolModal(tool.set,tool.num,tool.src);
    };
    zoomTools.appendChild(tImg);
  }else{
    const none=document.createElement('div');
    none.className='chip';
    none.textContent='none';
    zoomTools.appendChild(none);
  }

  /* Abilities */
  zoomAbilities.style.display='none';
  zoomAbilities.innerHTML='';

  const abilities = extractAbilities(meta);
  if(abilities.length){
    const bandClr=(TYPE_HEX[mainType||'colorless']||'#94a3b8');
    abilities.forEach(ab=>{
      const box=document.createElement('div');
      box.className='ability-box';

      const head=document.createElement('div');
      head.className='ability-head';
      head.style.background=bandClr;
      head.style.color='#0b0f14';

      const badge=document.createElement('img');
      badge.src=ABILITY_BADGE;
      badge.alt='';

      const nm=document.createElement('div');
      nm.className='ability-name';
      nm.textContent=ab.name||'Ability';

      head.appendChild(badge);
      head.appendChild(nm);

      const tx=document.createElement('div');
      tx.className='ability-text';
      tx.textContent=ab.effect||'';

      box.appendChild(head);
      box.appendChild(tx);
      zoomAbilities.appendChild(box);
    });
    zoomAbilities.style.display='block';
  }

  /* Attacks */
  zoomAttacks.innerHTML='';

  (meta.attacks||[]).forEach(atk=>{
    const card=document.createElement('div');
    card.className='zoom-attack';

    const top=document.createElement('div');
    top.className='top';

    const left=document.createElement('div');
    left.style.display='flex';
    left.style.alignItems='center';
    left.style.gap='6px';

    const nm=document.createElement('div');
    nm.className='name';
    nm.textContent=atk.name||'Attack';

    const cost=makeCostIcons(atk.cost||[],slot);
    left.appendChild(nm);
    left.appendChild(cost);

    const dmg=document.createElement('div');
    dmg.className='dmg';
    dmg.textContent=(atk.damage||'').toString();

    top.appendChild(left);
    top.appendChild(dmg);
    card.appendChild(top);

    /* Effect text row */
    const divider=document.createElement('div');
    divider.className='thin';
    const eff=document.createElement('div');
    eff.className='effect';
    eff.textContent=atk.effect?String(atk.effect):'';

    card.appendChild(divider);
    card.appendChild(eff);

    const payable=canPayCostFromAPI(slot,atk.cost||[]);

    if(payable&&mainType){
      top.style.background=TYPE_HEX[mainType]||'#94a3b8';
      top.style.color='#fff';
      nm.style.color='#fff';
      dmg.style.color='#fff';
    }else{
      top.style.background='#2a2f36';
      top.style.color='#e5e7eb';
      card.classList.add('muted');
    }

    const isActiveCurrent = (currentPlayer && activeFor(currentPlayer).querySelector('img') === img);

    if (isActiveCurrent) {
      card.onclick = async () => {
        if (!payable) {
          showPopup('Not enough energy to use this attack.');
          return;
        }

        const foe = opponentOf(currentPlayer);
        const pk  = currentPlayer === 'player1' ? 'p1' : 'p2';

        // Base printed damage
        let baseDamage = parseDamage(atk.damage);

        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2
        };

        /* === PREVIEW (no side effects) === */
        let previewDamage = baseDamage;
        try {
          previewDamage = await applyMoveEffectFromCsv(
            effectState,
            pk,
            atk.name,
            baseDamage,
            { isFinal: false }
          );
        } catch (err) {
          console.error('Move preview error (zoom):', err);
          previewDamage = baseDamage;
        }

        /* === WEAKNESS === */
        try {
          const foeImg = getActiveImage(foe);
          if (foeImg) {
            const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
            const wk = metaFoe?.weaknesses?.[0];

            if (wk) {
              const wkType = (wk.type || '').toLowerCase();
              if (wkType !== 'colorless') {
                const atkType = (meta.types?.[0] || '').toLowerCase();
                if (atkType === wkType) {
                  previewDamage += 20;
                }
              }
            }
          }
        } catch (err) {
          console.error('Weakness check failed (zoom):', err);
        }

        /* === FINAL PASS (side effects) === */
        let finalDamage = previewDamage;
        try {
          finalDamage = await applyMoveEffectFromCsv(
            effectState,
            pk,
            atk.name,
            previewDamage,
            { isFinal: true, damageDealt: previewDamage }
          );
        } catch (err) {
          console.error('Move final error (zoom):', err);
          finalDamage = previewDamage;
        }

        /* === APPLY DAMAGE === */
        const result = damageActiveOf(foe, finalDamage);

        // Close zoom
        zoomBackdrop.classList.remove('show');
        currentZoom = { img: null, meta: null };

        // Handle KO
        if (result.knocked) {
          const foeImg2 = getActiveImage(foe);
          if (foeImg2) {
            const ended = await handleKnockOut(foe, foeImg2);
            if (ended) return;
            beginPromotionFlow(foe);
          }
        }

        setTimeout(() => startTurn(foe), 300);
      };
    } else {
      // Not current active: just visually muted
      card.classList.add('muted');
    }


    zoomAttacks.appendChild(card);
  });

  /* Weakness display */
  zoomWeakness.innerHTML='';
  {
    const wk=(meta.weaknesses&&meta.weaknesses[0])||null;
    if(wk){
      const k=String(wk.type||'').toLowerCase();
      if(k==='colorless'){
        zoomWeakness.textContent='—';
      }else{
        const ico=document.createElement('span');
        ico.className='mini-icon';
        ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;

        const val=document.createElement('span');
        val.className='mini-badge';
        val.textContent=wk.value||'';

        zoomWeakness.appendChild(ico);
        zoomWeakness.appendChild(val);
      }
    }else zoomWeakness.textContent='—';
  }

  /* Retreat cost display */
  zoomRetreat.innerHTML='';
  const rcost=computeRetreatCost(img.closest('.active'),meta);

  for(let i=0;i<rcost;i++){
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${ENERGY_ICONS.colorless}')`;
    zoomRetreat.appendChild(ico);
  }
}
/* ========= tool modal ========= */
async function openToolModal(set,num,src){
  if(!toolBackdrop)return;
  toolImg.src=src||'';
  toolTitle.textContent='Tool';
  toolMeta.textContent='';
  toolText.textContent='';
  toolBackdrop.classList.add('show');
  try{
    const meta=await fetchCardMeta(set,num);
    toolTitle.textContent=meta.name||'Tool';
    toolMeta.textContent=(meta.trainerType?meta.trainerType:'Tool');
    toolText.textContent=(meta.effect||meta.description||'');
  }catch{
    toolText.textContent='No details available.';
  }
}
if(toolBackdrop){
  toolBackdrop.addEventListener('click',e=>{
    if(e.target===toolBackdrop)toolBackdrop.classList.remove('show');
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape')toolBackdrop.classList.remove('show');
  });
}

/* ========= evolution ========= */
function clearGlow(){
  $$('.glow-evo,.promote-glow').forEach(el=>el.classList.remove('glow-evo','promote-glow'));
  isEvoMode=false;evoMeta=null;evoOwner=null;evoHandCard=null;
}

async function evolveCard(target,meta,handCard,owner,set,num){
  if(turnNumber<=2){
    showPopup('You can’t evolve during the first two turns.');
    clearGlow();
    return;
  }
  const playedTurn=parseInt(target.dataset.playedTurn||'0',10);
  if(playedTurn===turnNumber){
    showPopup('Can’t evolve the turn it was played.');
    clearGlow();
    return;
  }

  const prevHp=parseInt(target.dataset.hp||'0',10),
        prevChp=parseInt(target.dataset.chp||prevHp||'0',10),
        priorDamage=prevHp>0?Math.max(0,prevHp-prevChp):0;

  const padded=String(num).padStart(3,'0');
  const evolvedImage=`https://assets.tcgdex.net/en/tcgp/${set}/${padded}/high.png`;
  const evo=document.createElement('img');
  evo.className='card-img';
  evo.alt=meta.name;
  evo.src=evolvedImage;
  evo.dataset.playedTurn=turnNumber;
  evo.dataset.evolvedFrom=(meta.evolveFrom||'').toLowerCase();
  evo.dataset.set=set;
  evo.dataset.num=num;

  const slot=target.closest('.card-slot');
  const moveBack=(from,to)=>{
    const energyBox=from.querySelector('.energy-pips');
    const hpOverlay=from.querySelector('.hp-overlay');
    const toolThumb=from.querySelector('.tool-thumb');
    if(energyBox)to.appendChild(energyBox);
    if(hpOverlay)to.appendChild(hpOverlay);
    if(toolThumb)to.appendChild(toolThumb);
    const tool=getToolDataFromSlot(from);
    if(tool){
      setToolDataOnSlot(to,tool);
      setToolDataOnSlot(from,null);
    }
  };
  moveBack(slot,slot);
  target.replaceWith(evo);

  const newHp=parseInt(meta.hp||'0',10)||prevHp||0;
  const newChp=Math.max(0,newHp-priorDamage);
  setHpOnImage(evo,newHp,newChp);
  markSlot(slot,true);
  removeFromHand(owner,set,num);
  renderAllHands();

  logEvent({
    player: owner,
    text:`Evolved ${meta.evolveFrom || 'a Pokémon'} into ${meta.name}.`,
    cardSet:set,cardNum:num
  });

  showPopup(`${meta.evolveFrom} → ${meta.name}`);
  if(currentZoom.img&&currentZoom.img===evo){
    await buildZoomPanel(meta,evo);
  }
}

/* ========= board interactions ========= */
function handFind(owner,set,num){
  return playerState[owner].hand.find(c=>c.set===set&&String(c.number||c.num)===String(num))||null;
}

function attachEnergyToSlot(owner,slot,energyKey){
  if(!slot||!energyKey)return;
  const img=slot.querySelector('img');
  if(!img){showPopup('Select a Pokémon in play.');return}
  const area=currentPlayer==='player1'?$('#player1'):$('#player2');
  if(!area.contains(slot)||slot.closest('.hand')){
    showPopup('Attach only to Pokémon in play.');
    return;
  }
  const set=img.dataset.set,num=img.dataset.num;
  fetchCardMeta(set,num).then(meta=>{
    if(String(meta.category||'').toLowerCase()!=='pokemon'){
      showPopup('You can only attach to Pokémon.');
      return;
    }
    let box=slot.querySelector('.energy-pips');
    if(!box){
      box=document.createElement('div');
      box.className='energy-pips';
      slot.appendChild(box);
    }
    const pip=document.createElement('div');
    pip.className='energy-pip';
    pip.dataset.type=energyKey;
    pip.style.backgroundImage=`url('${ENERGY_ICONS[energyKey]||''}')`;
    box.appendChild(pip);
    hasAttachedEnergyThisTurn=true;
    renderEnergyZone();
    showPopup('Energy attached');

    logEvent({
      player: owner,
      text:`Attached ${energyKey} Energy.`,
      cardSet:set,cardNum:num
    });

    if(currentZoom.img&&slot.contains(currentZoom.img)){
      buildZoomPanel(meta,currentZoom.img);
    }
  }).catch(()=>showPopup('Error verifying card.'));
}

/* primary click */
document.body.addEventListener('click',async e=>{
  if(e.button!==0)return;

  /* tool attach flow */
  if(toolAttachPending){
    const targetImg=e.target.closest('.active img, .bench img');
    if(targetImg){
      const owner=targetImg.closest('#player1')?'player1':'player2';
      if(owner!==toolAttachPending.owner){
        showPopup('Attach Tools to your own Pokémon.');
      }else{
        const slot=targetImg.closest('.card-slot');
        if(getToolDataFromSlot(slot)){
          showPopup('This Pokémon already has a Tool attached.');
        }else{
          await attachToolToSlot(owner,slot,{
            set:toolAttachPending.set,
            num:toolAttachPending.num,
            src:toolAttachPending.src
          });
          removeFromHand(owner,toolAttachPending.set,toolAttachPending.num);
          renderAllHands();

          logEvent({
            player: owner,
            text:'Attached Tool.',
            cardSet:toolAttachPending.set,
            cardNum:toolAttachPending.num
          });

          toolAttachPending=null;
        }
      }
      e.stopPropagation();
      return;
    }
  }

  /* energy pick */
  if(selectedEnergy){
    const img=e.target.closest('.card-slot img');
    if(!img)return;
    const owner=img.closest('#player1')?'player1':'player2';
    if(owner!==currentPlayer){
      showPopup('Attach Energy to your own Pokémon.');
      return;
    }
    attachEnergyToSlot(owner,img.closest('.card-slot'),selectedEnergy);
    selectedEnergy=null;
    return;
  }

  /* open attack menu for current active on left-click */
  const activeArea=currentPlayer?activeFor(currentPlayer):null;
  if(activeArea&&activeArea.contains(e.target)&&e.target.tagName==='IMG'&&!e.target.closest('.hand')){
    if(e.target.closest('.active')===activeArea){
      const img=e.target;
      const set=img.dataset.set,num=img.dataset.num;
      if(!set||!num){closeAttackMenu();return}
      try{
        const meta=await fetchCardMeta(set,num);
        showAttackMenuFor(activeArea,meta);
      }catch{
        showPopup('No attacks available.');
      }
      return;
    }
  }

  /* hand interactions */
  if(e.target.tagName!=='IMG')return;
  const inHand=e.target.closest('.hand');
  if(!inHand)return;
  const owner=e.target.dataset.owner;
  const set=e.target.dataset.set;
  const num=e.target.dataset.num;
  if(currentPlayer&&owner!==currentPlayer)return;

  let meta=null;
  try{meta=await fetchCardMeta(set,num)}catch{}

  /* trainer */
  if(meta && String(meta.category||'').toLowerCase()==='trainer'){
    if(isSetupPhase){
      showPopup('You can’t play Trainer cards during setup.');
      return;
    }
    const ttype=String(meta.trainerType||'').toLowerCase();
    const cardId=csvIdFor(set,num);
    const effect=TRAINER_EFFECT_DATA.find(x=>x.id===cardId);
    const doEffect=()=>{
      if(effect){applyTrainerEffect(effect,owner)}
      else{console.warn('No CSV effect for',cardId)}
    };

    if(ttype==='supporter'){
      if(hasPlayedSupporterThisTurn[owner]){
        showPopup('Only one Supporter per turn.');
        return;
      }
      addTrainerToDiscard(owner,e.target);
      removeFromHand(owner,set,num);
      renderAllHands();
      hasPlayedSupporterThisTurn[owner]=true;
      doEffect();
      showPopup('Supporter played');

      logEvent({
        player: owner,
        text:`Played Supporter: ${meta.name}.`,
        cardSet:set,cardNum:num
      });

      return;
    }else if(ttype==='item'){
      addTrainerToDiscard(owner,e.target);
      removeFromHand(owner,set,num);
      renderAllHands();
      doEffect();
      showPopup('Item played');

      logEvent({
        player: owner,
        text:`Played Item: ${meta.name}.`,
        cardSet:set,cardNum:num
      });

      return;
    }else if(ttype==='tool'){
      toolAttachPending={owner,set,num,src:e.target.src};
      showPopup('Select a Pokémon in play to attach this Tool.');

      logEvent({
        player: owner,
        text:`Played Tool: ${meta.name}.`,
        cardSet:set,cardNum:num
      });

      return;
    }else{
      showPopup('Unknown Trainer type.');
      return;
    }
  }

  /* evolution */
  if(meta && meta.evolveFrom){
    isEvoMode=true;evoMeta=meta;evoOwner=owner;evoHandCard=e.target;
    let glow=0;
    $$('#'+owner+' .active img, #'+owner+' .bench img').forEach(img=>{
      if(img.alt.toLowerCase().includes(String(meta.evolveFrom).toLowerCase())){
        img.classList.add('glow-evo');glow++;
      }
    });
    if(glow===0){
      showPopup(`No valid ${meta.evolveFrom} to evolve.`);
      isEvoMode=false;
      return;
    }
    showPopup(`Select ${meta.evolveFrom} to evolve.`);
    return;
  }

  /* basic placement */
  if(!(meta && String(meta.category||'').toLowerCase()==='pokemon' &&
       String(meta.stage||'').toLowerCase()==='basic')){
    showPopup('Only Basic Pokémon can be placed.');
    return;
  }

  const clone=e.target.cloneNode(true);
  clone.dataset.playedTurn=turnNumber;
  clone.dataset.set=set;
  clone.dataset.num=num;
  const act=owner==='player1'?p1Active:p2Active;
  const bench=owner==='player1'?p1Bench:p2Bench;

  let placedTo='bench';

  if(!act.querySelector('img')){
    const slot=act.querySelector('.card-slot');
    slot.innerHTML='';
    slot.appendChild(clone);
    markSlot(slot,true);
    placedTo='active';
  }else{
    const empty=[...bench.querySelectorAll('.card-slot')].find(s=>s.dataset.empty==='1');
    if(!empty){
      showPopup('Bench full.');
      return;
    }
    empty.innerHTML='';
    empty.appendChild(clone);
    markSlot(empty,true);
    placedTo='bench';
  }

  removeFromHand(owner,set,num);
  try{
    const baseHp=parseInt(meta.hp||'0',10)||0;
    setHpOnImage(clone,baseHp,baseHp);
  }catch{}
  renderAllHands();

  logEvent({
    player: owner,
    text:`Played Basic Pokémon to ${placedTo==='active'?'Active':'Bench'}: ${meta.name}.`,
    cardSet:set,cardNum:num
  });
});

/* evolution click */
document.body.addEventListener('click',async e=>{
  if(!isEvoMode)return;
  const target=e.target.closest('img.glow-evo');
  if(!target)return;
  e.stopPropagation();
  await evolveCard(target,evoMeta,evoHandCard,evoOwner,evoHandCard.dataset.set,evoHandCard.dataset.num);
  clearGlow();
});
/* promotion helpers: attachments follow their Pokémon */
function detachAttachments(slot){
  if (!slot) return { energy: null, hp: null, toolThumb: null, toolData: null };
  const energy    = slot.querySelector('.energy-pips');
  const hp        = slot.querySelector('.hp-overlay');
  const toolThumb = slot.querySelector('.tool-thumb');

  if (energy)    energy.remove();
  if (hp)        hp.remove();
  if (toolThumb) toolThumb.remove();

  const toolData = getToolDataFromSlot(slot);
  if (toolData) setToolDataOnSlot(slot, null);

  return { energy, hp, toolThumb, toolData };
}

function attachAttachments(slot, pack){
  if (!slot || !pack) return;
  const { energy, hp, toolThumb, toolData } = pack;
  if (energy)    slot.appendChild(energy);
  if (hp)        slot.appendChild(hp);
  if (toolThumb) slot.appendChild(toolThumb);
  if (toolData)  setToolDataOnSlot(slot, toolData);
}

function beginPromotionFlow(owner){
  isPromotionPhase = true;

  const benchImgs = [...benchFor(owner).querySelectorAll('img')];
  if (!benchImgs.length) {
    const foe = owner === 'player1' ? 'player2' : 'player1';
    showVictory(foe, 'Bench out');
    isPromotionPhase = false;
    return;
  }

  benchImgs.forEach(img => img.classList.add('promote-glow'));
  showPopup('Choose a Benched Pokémon to promote.');

  const clickOnce = (e) => {
    if (!isPromotionPhase) return;
    const chosenImg = e.target.closest(`#${owner} .bench img`);
    if (!chosenImg) return;

    e.stopPropagation();
    document.body.removeEventListener('click', clickOnce, true);

    const activeDiv  = activeFor(owner);
    const activeSlot = activeDiv.querySelector('.card-slot');
    const benchSlot  = chosenImg.closest('.card-slot');
    const activeImg  = activeSlot.querySelector('img');

    /* CASE 1 — Active slot is empty */
    if (!activeImg) {
      const benchPack = detachAttachments(benchSlot);

      benchSlot.removeChild(chosenImg);
      activeSlot.appendChild(chosenImg);

      attachAttachments(activeSlot, benchPack);

      markSlot(activeSlot, true);
      markSlot(benchSlot, !!benchSlot.querySelector('img'));

      benchImgs.forEach(x => x.classList.remove('promote-glow'));
      isPromotionPhase = false;

      showPopup('Promoted to Active.');
      return;
    }

    /* CASE 2 — Swap Active <-> Bench */
    const activePack = detachAttachments(activeSlot);
    const benchPack  = detachAttachments(benchSlot);

    activeSlot.removeChild(activeImg);
    benchSlot.removeChild(chosenImg);

    activeSlot.appendChild(chosenImg);
    benchSlot.appendChild(activeImg);

    attachAttachments(activeSlot, benchPack);
    attachAttachments(benchSlot, activePack);

    markSlot(activeSlot, true);
    markSlot(benchSlot, !!benchSlot.querySelector('img'));

    benchImgs.forEach(x => x.classList.remove('promote-glow'));
    isPromotionPhase = false;

    showPopup('Promoted to Active.');
  };

  document.body.addEventListener('click', clickOnce, true);
}

// Make core helpers visible to effects.js after their definitions
globalThis.benchFor           = benchFor;
globalThis.activeFor          = activeFor;
globalThis.beginPromotionFlow = beginPromotionFlow;
globalThis.fetchCardMeta      = fetchCardMeta;
globalThis.ENERGY_ICONS       = ENERGY_ICONS;

/* ========= draws / turns ========= */
function drawOne(player){
  const d=playerState[player].deck,
        h=playerState[player].hand;
  if(!d.length) return false;
  h.push(d.shift());
  updateDeckBubbles();
  return true;
}

function startTurn(player){
    turnNumber++;

  logEvent({
    player,
    text:`Turn ${turnNumber} started for ${player==='player1'?'Player 1':'Player 2'}.`
  });

  currentPlayer=player;

  const turnLabel = `Turn ${turnNumber} — ${player === 'player1' ? 'Player 1' : 'Player 2'}`;

  const bar = document.createElement("div");
  bar.className = "turn-bar";
  bar.innerHTML = `
    <div class="turn-icon">${turnNumber}</div>
    ${turnLabel}
  `;
  logEntriesDiv.appendChild(bar);

  /* reset turn state */
  hasAttachedEnergyThisTurn=false;
  selectedEnergy=null;
  hasRetreatedThisTurn=false;
  closeAttackMenu();
  hasPlayedSupporterThisTurn[player]=false;

  resetDamageBoostsFor('player1');
  resetDamageBoostsFor('player2');

  /* draw 1 */
  drawOne(player);

  renderAllHands();
  renderEnergyZone();
  updateTurnBox();
  showPopup(`Player ${player==='player1'?'1':'2'}'s turn`);
}

/* starting hand logic */
async function drawStartingHandForPlayer(key){
  const deck=playerState[key].deck;
  if(deck.length<5)throw new Error('Deck too small');

  let tries=0,hand=[],hasBasic=false;

  while(tries<10){
    tries++;
    shuffle(deck);

    hand=deck.slice(0,5);

    const flags=await Promise.all(
      hand.map(c=>isBasicPokemon(c.set,c.number||c.num))
    );

    hasBasic=flags.some(Boolean);
    if(hasBasic) break;
  }

  playerState[key].hand=hand;
  deck.splice(0,5);
}

/* ========= energy zone ========= */
function renderEnergyZone(){
  const types = playerState[currentPlayer]?.energyTypes || [];
  energyZoneDiv.innerHTML = '';

  const disable =
    (turnNumber === 1 && currentPlayer === firstPlayer) ||
    hasAttachedEnergyThisTurn;

  for (const t of types) {
    const lw = t.toLowerCase();
    const el = document.createElement('div');
    el.className = 'energy';
    el.style.backgroundImage = `url('${ENERGY_ICONS[lw] || ''}')`;
    el.title = t;

    if (disable) {
      el.style.filter = 'grayscale(100%) brightness(70%)';
      el.style.cursor  = 'not-allowed';
    } else {
      el.onclick = () => {
        selectedEnergy = lw;
        showPopup(`Selected ${lw} energy`);
      };
    }

    energyZoneDiv.appendChild(el);
  }
}

/* ========= coin flip + setup ========= */
function flipCoin(){
  coinEl.classList.add('flip');

  const res = Math.random() < 0.5 ? 'player1' : 'player2';
  const front = coinEl.querySelector('.front');
  const back  = coinEl.querySelector('.back');

  setTimeout(() => {
    coinEl.classList.remove('flip');

    if (res === 'player1') {
      front.style.transform = 'rotateY(0deg)';
      back.style.transform  = 'rotateY(180deg)';
    } else {
      front.style.transform = 'rotateY(180deg)';
      back.style.transform  = 'rotateY(0deg)';
    }

    firstPlayer   = res;
    currentPlayer = res;

    coinResult.textContent = `${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`;
    showPopup(`${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`);

    logEvent({
      player: res,
      text:`Won the coin flip and goes first.`
    });

    updateTurnBox();
    renderEnergyZone();

    drawOne(currentPlayer);
    renderAllHands();

    isSetupPhase = false;
  }, 1500);
}

/* ========= right-click zoom ========= */
document.body.addEventListener('contextmenu', async e => {
  const handImgEl = e.target.closest('.hand img');

  /* Right-click on card in hand */
  if (handImgEl) {
    e.preventDefault();

    const set = handImgEl.dataset.set;
    const num = handImgEl.dataset.num;

    try {
      const meta = await fetchCardMeta(set, num);
      const category = (meta.category || '').toLowerCase();

      if (handBackdrop && handImg) {
        handImg.src = handImgEl.src;
        handBackdrop.classList.add('show');
        handTitle.textContent = meta.name || 'Card';
      }

      if (category === 'pokemon') {
        if (handBackdrop) handBackdrop.classList.remove('show');

        zoomImg.src = handImgEl.src;
        zoomBackdrop.classList.add('show');

        await buildZoomPanel(meta, handImgEl);
        zoomAttacks.querySelectorAll('.zoom-attack').forEach(a => a.classList.add('muted'));
        document.getElementById('zoomRetreatRow')?.classList.add('disabled');
      } else {
        if (handType) {
          handType.textContent = meta.trainerType || meta.category || 'Card';
          handType.style.background = trainerColor(meta.trainerType || meta.category);
        }
        if (handEffect) {
          handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
        }
      }

    } catch {
      showPopup('No data available for this card.');
    }

    return;
  }

  /* Right-click on Pokémon in play */
  const img = e.target.closest('.active img, .bench img');
  if (!img) return;

  e.preventDefault();

  zoomImg.src = img.src;
  zoomBackdrop.classList.add('show');

  try {
    const set = img.dataset.set;
    const num = img.dataset.num;
    const meta = await fetchCardMeta(set, num);
    await buildZoomPanel(meta, img);
  } catch {
    zoomTitle.textContent = 'Pokémon';
    zoomHp.textContent = '';
    zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
    zoomEnergyCount.textContent = 'x0';
    zoomEnergyIcons.innerHTML = '';
    zoomWeakness.textContent = '—';
    zoomRetreat.innerHTML = '';
    zoomTools.innerHTML = '<div class="chip">none</div>';
    zoomAbilities.style.display = 'none';
  }
});

/* close zoom */
if (zoomBackdrop) {
  zoomBackdrop.addEventListener('click', e => {
    if (e.target === zoomBackdrop) {
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
    }
  });

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
    }
  });
}

/* ========= discard buttons ========= */
if (p1DiscardBtn) p1DiscardBtn.onclick = () => {
  renderDiscard('player1');
  p1DiscardDrawer.classList.add('show');
};

if (p2DiscardBtn) p2DiscardBtn.onclick = () => {
  renderDiscard('player2');
  p2DiscardDrawer.classList.add('show');
};

document.addEventListener('click', e => {
  if (p1DiscardDrawer?.classList.contains('show') &&
      !p1DiscardDrawer.contains(e.target) &&
      e.target !== p1DiscardBtn) {
    p1DiscardDrawer.classList.remove('show');
  }

  if (p2DiscardDrawer?.classList.contains('show') &&
      !p2DiscardDrawer.contains(e.target) &&
      e.target !== p2DiscardBtn) {
    p2DiscardDrawer.classList.remove('show');
  }
});

/* ========= main button ========= */
if (mainButton) mainButton.onclick = async () => {
  const label = mainButton.textContent;

  try {
    if (label === 'Draw Hands') {
      await Promise.all([
        drawStartingHandForPlayer('player1'),
        drawStartingHandForPlayer('player2')
      ]);

      renderAllHands();
      updateDeckBubbles();
      showPopup('Choose Active & Benched Pokémon');

      mainButton.textContent = 'Start Game';

    } else if (label === 'Start Game') {
      if (!p1Active.querySelector('img') || !p2Active.querySelector('img')) {
        showPopup('Both players need an Active Pokémon.');
        return;
      }

      flipCoin();
      mainButton.textContent = 'End Turn';

    } else {
      /* Regular turn cycling */
      const next = currentPlayer === 'player1' ? 'player2' : 'player1';
      startTurn(next);
    }
  } catch (err) {
    console.error('Flow error:', err);
    showPopup('Setup error. Check decks.');
  }
};

/* ========= victory screen actions ========= */
if (playAgainBtn)
  playAgainBtn.addEventListener('click', () => {
    window.location.reload();
  });

if (chooseDecksBtn)
  chooseDecksBtn.addEventListener('click', () => {
    window.location.href = 'index.html';
  });

const victoryShowLogBtn = document.getElementById("victoryShowLogBtn");

if (victoryShowLogBtn) {
  victoryShowLogBtn.onclick = () => {
    if (!fullHistoryLog.length) {
      fullHistoryDiv.innerHTML = '<div class="match-log-entry">No actions logged.</div>';
    } else {
      fullHistoryDiv.innerHTML = fullHistoryLog.map(h => `
        <div class="match-log-entry">
          <div>
            <strong>#${h.id}</strong> · ${h.player} ·
            <span style="opacity:.6">${h.ts}</span>
          </div>
          <div>${h.text}</div>
          ${
            h.imgUrl
              ? `<img class="log-thumb" src="${h.imgUrl}"
                  style="margin-top:6px;border-radius:6px;width:52px;height:auto;">`
              : ''
          }
        </div>
      `).join('');
    }
    historyBackdrop.classList.add('show');
  };
}
/* ========= effects bridge ========= */
globalThis.selectPokemon = function (_st, pk, _z) {
  const area = pk === 'p1' ? p1Active : p2Active;
  const img  = area?.querySelector('img');
  if (!img) return null;

  return {
    name: img.alt,
    hp:   parseInt(img.dataset.chp || img.dataset.hp || '0', 10) || 0,
    maxHP: parseInt(img.dataset.hp || '0', 10) || 0
  };
};

globalThis.drawCards = function (_st, pk, n) {
  const owner = pk === 'p1' ? 'player1' : 'player2';

  for (let i = 0; i < (parseInt(n) || 0); i++) {
    if (playerState[owner].deck.length) {
      playerState[owner].hand.push(playerState[owner].deck.shift());
    }
  }

  renderAllHands();
  updateDeckBubbles();
};

globalThis.shuffleIntoDeck = function (hand, deck) {
  if (!Array.isArray(hand) || !Array.isArray(deck)) return;

  deck.push(...hand);
  hand.length = 0;
  shuffle(deck);
};

globalThis.findPokemonByName = function (_st, name) {
  const imgs = $$('#player1 .active img, #player1 .bench img, ' +
                  '#player2 .active img, #player2 .bench img');
  const hit = imgs.find(i => i.alt === name);
  return hit ? { name } : null;
};

globalThis.promoteFromBench = function (_st, oppKey, requireChoice = true) {
  const owner = oppKey === 'p1' ? 'player1' : 'player2';
  const bench = owner === 'player1' ? p1Bench : p2Bench;
  const imgs  = bench.querySelectorAll('img');

  if (requireChoice && imgs.length === 0) return false;

  beginPromotionFlow(owner);
  showPopup(`${owner === 'player1' ? 'Player 1' : 'Player 2'} choose a Benched Pokémon to promote.`);
  return true;
};

globalThis.setTempRetreatFor = function (pk, k, mode = 'set') {
  const area = pk === 'p1' ? p1Active : p2Active;
  if (!area) return;

  if (mode === 'reduce') {
    area.dataset.tempRetreatReduce = String(k);
  } else {
    area.dataset.tempRetreat = String(k);
  }
};

/* Expose helpers */
globalThis.shuffle = shuffle;
globalThis.renderAllHands = renderAllHands;
globalThis.updateDeckBubbles = updateDeckBubbles;
globalThis.showPopup = showPopup;
globalThis.getToolDataFromSlot = getToolDataFromSlot;
globalThis.setToolDataOnSlot = setToolDataOnSlot;

/* Animation support for Poké Ball etc. */
globalThis.animateCardToHand = animateCardToHand;

/* Logging bridge for trainer effects (Misty/Brock/etc.) */
globalThis.addLog = function (pk, htmlText, _imgUrl, cardObj) {
  const owner = pk === 'p1' ? 'player1' : 'player2';

  logEvent({
    player: owner,
    text: htmlText,
    cardSet: cardObj?.set,
    cardNum: cardObj?.number || cardObj?.num
  });
};

/* ========= trainer effect application ========= */
async function applyTrainerEffect(effect, owner) {
  try {
    const key = owner === 'player1' ? 'p1' : 'p2';

    const state = {
      p1: { deck: playerState.player1.deck, hand: playerState.player1.hand },
      p2: { deck: playerState.player2.deck, hand: playerState.player2.hand }
    };

    let handler = TRAINER_EFFECTS[effect.effect_type];

    if (!handler && effect.effect_name && TRAINER_EFFECTS[effect.effect_name]) {
      console.warn('No handler for type:', effect.effect_type, '— using name instead');
      handler = TRAINER_EFFECTS[effect.effect_name];
    }

    if (!handler) {
      console.warn('No trainer handler for', effect);
      return;
    }

    await handler(state, key, { param1: effect.param1, param2: effect.param2 });

    renderAllHands();
    updateDeckBubbles();

  } catch (err) {
    console.error('Trainer effect error:', err);
    showPopup('Trainer effect failed.');
  }
}

function addTrainerToDiscard(owner, img) {
  pushCardToDiscard(owner, img);
  const drawer = owner === 'player1' ? p1DiscardDrawer : p2DiscardDrawer;

  if (drawer.classList.contains('show')) {
    renderDiscard(owner);
  }
}


/* ========= init ========= */
updateDeckBubbles();
updateTurnBox();
updatePointsUI();
renderAllHands();
</script>
</body>
</html>
