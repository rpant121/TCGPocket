<!-- UPDATED: 1765141943.5356314 - All ability bugs fixed -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pok√©mon TCG Pocket Battle</title>
<link rel="icon" type="image/png" href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Pok%C3%A9_Ball_icon.svg/768px-Pok%C3%A9_Ball_icon.svg.png?20161023215848"/>
<style>
:root{--card-w:75px;--card-h:105px}

/* ============================================
   MISSING KEYFRAMES ANIMATIONS
============================================ */

/* Coin flip animation */
@keyframes flipCoin {
  0% {
    transform: rotateY(0deg);
  }
  100% {
    transform: rotateY(1800deg);
  }
}

/* Damage flash animation */
@keyframes damageFlash {
  0% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
  50% {
    filter: brightness(1.8) saturate(1.5);
    box-shadow: 0 0 30px rgba(239, 68, 68, 1);
    border-color: #ef4444;
  }
  100% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
}

/* Glow pulse animation */
@keyframes glowPulse {
  0% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
  50% {
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
    border-color: rgba(0, 212, 255, 1);
  }
  100% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
}

/* Evolution glow animation */
@keyframes evoGlow {
  0% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(34, 197, 94, 1);
    border-color: rgba(34, 197, 94, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
}

/* Promotion glow animation */
@keyframes promoteGlow {
  0% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(168, 85, 247, 1);
    border-color: rgba(168, 85, 247, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
}

/* Popup slide animation */
@keyframes popupSlide {
  0% {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
  10% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  90% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%);
  }
}

/* Nebula pulse for background (if used) */
@keyframes nebulaPulse {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 0.6;
  }
}

/* Twinkle for stars (if used) */
@keyframes twinkle {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 1;
  }
}


body{
  font-family:'Segoe UI',Arial,sans-serif;
  background:linear-gradient(135deg, #0a0a1a 0%, #1a0f2e 50%, #2d1b4e 100%);
  margin:0;
  padding:0;
  color:#e5e7eb;
  height:100vh;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  align-items:center;
  background-attachment:fixed;
}
h1{
  margin:0;
  width:100%;
  padding:.4rem 0;
  text-align:center;
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  font-size:1.05rem;
  letter-spacing:.2px;
}
.main-layout{
  display:flex;
  justify-content:center;
  align-items:center;
  width:100%;
  height:calc(100vh - 52px);
  position:relative;
  z-index:1;
}
.battlefield{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-evenly;
  max-width:850px !important;
  width:100%;
  height:95%;
  transform-origin:center center;
  transform:scale(0.92);
}
.player-area{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:6px 0;
  position:relative;
  z-index:1;
}
.hand,.bench,.active{
  display:flex;
  justify-content:center;
  gap:8px;
  flex-wrap:wrap;
  position:relative;
}
.bench,.active{
  min-height:calc(var(--card-h) + 6px);
}
.card-slot{
  width:var(--card-w);
  height:var(--card-h);
  border-radius:8px;
  background:rgba(20, 20, 30, 0.65);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:10px;
  color:#a1a1aa;
  box-shadow:0 1px 3px rgba(0,0,0,.5);
  position:relative;
  flex-shrink:0;
  border:2px solid rgba(138, 43, 226, 0.3);
  backdrop-filter:blur(8px);
}
.slot-label{
  position:absolute;
  inset:auto 0 6px 0;
  text-align:center;
  font-weight:700;
  background:rgba(0,0,0,.7);
  color:#fff;
  border-radius:12px;
  line-height:1;
  padding:3px 8px;
  width:70px;
  margin:auto;
  font-size:10px;
  pointer-events:none;
}
/* HP Badge for cards with modified HP */
.hp-badge {
  position: absolute;
  top: 4px;
  right: 4px;
  background: rgba(239, 68, 68, 0.95);
  color: #fff;
  font-weight: 700;
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 8px;
  pointer-events: none;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
}
.hp-badge.tool-boosted {
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  animation: pulse-green 2s ease-in-out infinite;
}
@keyframes pulse-green {
  0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 0 rgba(34, 197, 94, 0.7); }
  50% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 4px rgba(34, 197, 94, 0); }
}
.card-img{
  width:var(--card-w);
  height:var(--card-h);
  object-fit:contain;
  border-radius:6px;
  cursor:pointer;
  transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
  z-index:2;
  position:relative;
  transform:perspective(700px) rotateX(0deg);
}
.active .card-img{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 8px rgba(255,215,0,.6);
  transform:perspective(700px) rotateX(12deg);
}
.bench .card-img{
  transform:perspective(700px) rotateX(6deg);
}
.hand .card-img{
  transform:perspective(700px) rotateX(3deg);
}
/* Pokemon Communication selection glow */
.poke-comm-glow {
  animation: poke-comm-pulse 1.5s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4) !important;
  border: 2px solid #3b82f6 !important;
}
@keyframes poke-comm-pulse {
  0%, 100% { transform: perspective(700px) rotateX(3deg) scale(1); }
  50% { transform: perspective(700px) rotateX(3deg) scale(1.05); }
}
#p1Active,#p1Bench{
  outline:1.5px solid #4da3ff;
  outline-offset:3px;
  border-radius:5px;
}
#p2Active,#p2Bench{
  outline:1.5px solid #ff6b6b;
  outline-offset:3px;
  border-radius:5px;
}
.deck-bubble{
  position:absolute;
  width:32px;
  height:32px;
  border-radius:50%;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  font-weight:700;
  font-size:12px;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 2px 6px rgba(0,0,0,.5);
  border:2px solid rgba(100, 100, 120, 0.4) !important;
}
#p1Bubble{
  left:-40px;top:50%;transform:translateY(-50%);
}
#p2Bubble{
  right:-40px;top:50%;transform:translateY(-50%);
}
.points-indicator{
  position:absolute;
  top:calc(50% + 26px);
  transform:translateY(-50%);
  display:flex;
  gap:6px;
  align-items:center;
  z-index:5;
  filter:brightness(1.1) !important;
}
#p1Points{
  right:4px;transform:translateX(50%);
}
#p2Points{
  left:4px;transform:translateX(-50%);
}
.point-bubble{
  width:14px;
  height:14px;
  border-radius:50%;
  border:1.5px solid #94a3b8;
  background:rgba(40, 40, 50, 0.8) !important;
  box-shadow:0 0 4px rgba(0,0,0,.5);
  transition:background .25s,border-color .25s,box-shadow .25s;
  border-color:rgba(100, 100, 120, 0.5) !important;
}
.point-bubble.filled{
  background:#facc15 !important;
  border-color:#fde047 !important;
  box-shadow:0 0 8px 2px rgba(250, 204, 21, 0.7) !important;
}
.energy-zone{
  display:flex !important;
  flex-wrap:wrap;
  gap:6px !important;
  justify-content:center;
  background:rgba(40, 40, 50, 0.96) !important;
  backdrop-filter:blur(20px);
  border-radius:12px !important;
  padding:10px !important;
  z-index:200 !important;
  position:fixed !important;
  pointer-events:all !important;
  visibility:visible !important;
  left:50% !important;
  transform:translateX(-50%) !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  bottom:60px !important;
}
.energy{
  width:30px !important;
  height:30px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  cursor:pointer !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  box-shadow:0 2px 6px rgba(0, 0, 0, 0.3) !important;
  background-repeat:no-repeat !important;
  transition:all 0.25s ease !important;
}
.energy-pips{
  position:absolute;
  left:3px;
  bottom:3px;
  height:16px;
  display:flex;
  gap:2px;
  z-index:3;
}
.energy-pip{
  width:16px;
  height:16px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #1f2937;
}
.status-icon{
  position:absolute;
  left:4px;
  top:4px;
  width:20px;
  height:20px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  pointer-events:none;
  z-index:6;
}
.zoom-status{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  flex-shrink:0;
}
.zoom-status-icon{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-position:center;
  background-repeat:no-repeat;
  flex-shrink:0;
}
.hp-overlay{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:22px;
  min-width:72px;
  text-align:center;
  background:rgba(0,0,0,.85);
  color:#fff;
  font-weight:800;
  font-size:10px;
  padding:2px 8px;
  border-radius:12px;
  z-index:3;
  line-height:1;
  white-space:nowrap;
  pointer-events:none;
}
.tool-thumb{
  position:absolute;
  top:30px;
  left:6px;
  width:34px;
  height:44px;
  border-radius:4px;
  box-shadow:0 2px 6px rgba(0,0,0,.6);
  border:1px solid #111827;
  background-color:#0b0f14;
  z-index:4;
  cursor:pointer;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 5% 45% 5%);
  transition:transform .15s ease;
}
#zoomTools img{
  width:88px;
  height:108px;
  border-radius:8px;
  border:1px solid #444;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 10% 45% 10%);
  box-shadow:0 0 8px rgba(0,0,0,.4);
  margin-top:0 !important;
}
#zoomTools{
  display:flex;
  align-items:center;
  gap:10px;
  padding:0 !important;
}
.side-panel{
  position:fixed;
  top:20px;
  right:20px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.6rem;
  z-index:10;
}
.coin{
  width:70px;
  height:70px;
  position:relative;
  transform-style:preserve-3d;
  transition:transform 1.5s ease-in-out;
}
.coin img{
  width:100%;
  height:100%;
  border-radius:50%;
  position:absolute;
  backface-visibility:hidden;
}
.coin .back{
  transform:rotateY(180deg);
}
.coin.flip{
  animation:flipCoin 1.5s ease-in-out;
}
#coinResult{
  text-align:center;
  font-weight:700;
  font-size:13px;
  min-height:35px;
}
button{
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  border:1px solid #1f2937;
  padding:8px 14px;
  border-radius:10px;
  cursor:pointer;
  font-size:.9rem;
  min-width:150px;
  box-shadow:0 4px 16px rgba(0,0,0,.35);
}
.turnbox{
  width:150px;
  border:1px solid #3b3f46;
  background:#23272e;
  border-radius:12px;
  padding:10px;
  text-align:center;
  font-size:.92rem;
  box-shadow:0 1px 3px rgba(0,0,0,.4);
  color:#e5e7eb;
}
.turnbox .big{
  font-weight:800;
  font-size:1.05rem;
}
#popup{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  background:rgba(17,17,17,.9);
  color:#fff;
  padding:10px 16px;
  border-radius:10px;
  font-size:14px;
  font-weight:800;
  opacity:0;
  z-index:200;
  transition:opacity .35s;
}
#popup.show{
  opacity:1;
}
.disable-clicks{
  pointer-events:none;
  filter:saturate(.9) brightness(.98);
}
.glow-evo{
  animation:evoGlow 1.5s ease-in-out infinite !important;
  outline:3px solid rgba(255,215,0,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(255,215,0,.85));
  border:3px solid #ffd700 !important;
}
.promote-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(59,130,246,.95);
  border-radius:8px;
}
.attack-menu{
  position:fixed;
  /* left and top will be set by JavaScript */
  left:0;
  top:0;
  background:rgba(255, 255, 255, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:12px !important;
  box-shadow:0 14px 38px rgba(0,0,0,.5);
  padding:18px !important;
  min-width:280px !important;
  z-index:1000 !important;
  opacity:0;
  transform:translateY(-4px);
  transition:opacity .2s ease,transform .2s ease;
  color:#e5e7eb;
  backdrop-filter:blur(20px);
  width:280px !important;
  overflow-y:auto !important;
}
.attack-menu.show{
  opacity:1;
  transform:translateY(0);
}
.attack-item{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  gap:8px;
  padding:14px 16px !important;
  border-radius:10px !important;
  cursor:pointer;
  background:linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  min-height:52px;
}
.attack-item.payable{
  background:rgba(0, 212, 255, 0.15) !important;
  border-color:#00d4ff !important;
}
.attack-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  line-height:1.2 !important;
  margin-right:8px !important;
  flex-shrink:0 !important;
}
.attack-cost{
  display:flex !important;
  gap:2px !important;
  margin-right:8px !important;
}
.cost-icon{
  width:16px;
  height:18px !important;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  margin:0 1px !important;
}
.cost-icon.missing{
  filter:grayscale(100%) brightness(50%);
}
.damage-flash{
  animation:damageFlash 0.4s ease-out !important;
}
.zoom-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0, 0, 0, 0.88) !important;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:3000 !important;
  backdrop-filter:blur(10px);
}
.zoom-backdrop.show{
  display:flex;
}
.zoom-modal{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:1180px;
}
.zoom-modal img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
}
.zoom-panel{
  min-width:470px;
  max-width:520px;
  background:rgba(30, 30, 40, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:18px !important;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb !important;
  backdrop-filter:blur(20px);
  max-height:90vh !important;
  overflow-y:auto !important;
}
.zoom-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:10px;
}
.zoom-title{
  font-weight:700 !important;
  font-size:22px !important;
  color:#ffffff !important;
}
.zoom-hp{
  font-size:12px;
  color:#ffffff !important;
}
.zoom-type{
  width:24px;
  height:24px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
}
.hpbar-container{
  width:100%;
  height:12px;
  background:#2f343c;
  border-radius:8px;
  overflow:hidden;
  margin:8px 0 6px;
}
.hpbar-fill{
  height:100%;
  width:0;
  border-radius:8px;
  transition:width .2s ease, background .2s ease;
  background:linear-gradient(90deg,#22c55e,#16a34a);
}
.zoom-section{
  border-top:1px solid #3b3f46;
  margin-top:12px;
  padding-top:12px;
  opacity:1 !important;
  margin-bottom:20px !important;
}
.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  margin:4px 0;
}
.chip{
  font-size:12px;
  background:#2a2f36;
  border:1px solid #3b3f46;
  border-radius:999px;
  padding:2px 8px;
  color:#e5e7eb;
}
.icon-row{
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:wrap;
}
.mini-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  display:inline-block;
}
.mini-badge{
  font-size:11px;
  color:#cbd5e1;
  margin-left:4px;
}
.zoom-attack{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  padding:16px !important;
  margin:10px 0;
  cursor:pointer;
  transition:filter .15s,border-color .15s;
  background:rgba(50, 50, 60, 0.8) !important;
  margin-bottom:12px !important;
}
.zoom-attack .top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  border-radius:10px;
  padding:8px 10px;
}
.zoom-attack .name{
  font-weight:800;
}
.zoom-attack .dmg{
  font-weight:900;
}
.thin{
  height:1px;
  background:#3b3f46;
  margin:8px 0;
}
.effect{
  font-size:12px;
  color:#cbd5e1;
  line-height:1.25;
}
.muted{
  opacity:.45;cursor:not-allowed;
}
.mini-icon.missing{
  filter:grayscale(100%) brightness(65%);
}
.discard-btn{
  position:absolute;
  left:12px;
  top:50%;
  transform:translateY(-50%);
  z-index:9;
}
.discard-btn.right{
  left:auto;
  right:12px;
}
.discard-drawer{
  position:fixed;
  top:0;
  bottom:0;
  width:310px;
  background:#1f232a;
  border-right:1px solid #3b3f46;
  box-shadow:18px 0 30px rgba(0,0,0,.5);
  z-index:1200;
  padding:14px;
  display:none;
  overflow:auto;
  color:#e5e7eb;
}
.discard-drawer.right{
  right:0;
  left:auto;
  border-right:none;
  border-left:1px solid #3b3f46;
  box-shadow:-18px 0 30px rgba(0,0,0,.5);
}
.discard-drawer.show{
  display:block;
}
.discard-item{
  display:flex;
  align-items:center;
  gap:10px;
  margin:10px 0;
}
.discard-item img{
  width:60px;
  height:84px;
  border-radius:8px;
  box-shadow:0 8px 18px rgba(0,0,0,.5);
}
.discard-group{
  display:flex;
  align-items:center;
  gap:10px;
}
.discard-count{
  font-weight:800;
  color:#e5e7eb;
  background:#2a2f36;
  border:1px solid #3b3f46;
  border-radius:999px;
  padding:2px 10px;
}
#victoryOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.68);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
#victoryCard{
  width:min(540px,92vw);
  background:#101418;
  border:1px solid #334155;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  padding:22px;
  color:#e5e7eb;
  text-align:center;
}
#victoryCard h2{
  margin:4px 0 8px 0;
  font-size:24px;
}
#victoryCard p{
  margin:6px 0 16px 0;
  color:#cbd5e1;
}
#victoryBtns{
  display:flex;
  gap:10px;
  justify-content:center;
}
#victoryOverlay,#victoryOverlay *{
  pointer-events:auto;
}
#toolBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1100;
}
#toolBackdrop.show{
  display:flex;
}
#toolCard{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:980px;
}
#toolCard img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
}
#toolPanel{
  min-width:360px;
  max-width:420px;
  background:#1f232a;
  border:1px solid #3b3f46;
  border-radius:16px;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb;
}
#toolPanel h3{
  margin:0 0 8px 0;
}
#zoomAttached{
  padding-bottom:0;margin-bottom:0 !important;
}
#zoomAttached .row{
  margin:0 0 4px 0 !important;
}
#zoomAttached+.zoom-section{
  margin-top:6px;padding-top:8px !important;
}
.ability-box{
  border:1px solid #3b3f46;
  border-radius:10px;
  background:#23272e;
  margin:6px 0;
  padding:6px 8px;
}
.ability-head{
  display:flex;
  align-items:center;
  gap:6px;
  border-radius:8px;
  padding:6px 8px;
  font-weight:800;
  color:#0b0f14;
}
.ability-head img{
  width:60px;
  height:18px;
  border-radius:3px;
  display:block;
}
.ability-name{
  font-size:13px;
}
.ability-text{
  font-size:12px;
  color:#cbd5e1;
  margin-top:6px;
  line-height:1.25;
}
.heal-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(74,222,128,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(74,222,128,.85));
}
#zoomRetreatRow{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  background:linear-gradient(180deg,#2a2f36,#262b32);
  transition:all .2s ease;
  margin-top:10px;
  padding:8px 10px;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  font-weight:700 !important;
  color:#ffffff !important;
  user-select:none;
  min-height:36px !important;
}
#zoomRetreatRow.enabled{
  cursor:pointer;
  filter:brightness(1.08);
  transform:scale(1.02);
}
#zoomRetreatRow.disabled{
  opacity:.5;
  cursor:not-allowed;
  filter:grayscale(80%);
}
#handType{
  color:#fff;
  font-weight:700;
  border:none;
  text-transform:capitalize;
}
#logToggleBtn{
  position:fixed;
  right:30px;
  top:355px;
  z-index:1500;
  background:linear-gradient(90deg,#2a2f36,#1f232a);
  border:1px solid #334155;
  padding:8px 14px;
  color:#e5e7eb;
  border-radius:10px;
  font-size:.85rem;
  cursor:pointer;
  box-shadow:0 4px 10px rgba(0,0,0,.4);
}
#logPanel{
  position:fixed;
  top:100px;
  right:-360px;
  width:340px;
  height:calc(100vh - 140px);
  background:#101418;
  border-left:1px solid #334155;
  box-shadow:-12px 0 28px rgba(0,0,0,.55);
  padding:12px 12px 20px 12px;
  overflow-y:auto;
  transition:right .25s ease;
  z-index:1200;
  color:#e5e7eb;
}
#logPanel.show{
  right:20px;
}
#closeLogBtn{
  background:#d92d2d;
  color:white;
  border:none;
  padding:6px 10px;
  border-radius:6px;
  cursor:pointer;
  font-size:12px;
  width:100%;
  margin-bottom:10px;
}
#logPanelHeader{
  background:linear-gradient(90deg,#d92d2d,#a61c1c);
  color:white;
  padding:12px 14px;
  font-size:15px;
  font-weight:700;
  letter-spacing:.5px;
  border-bottom:2px solid #8a1414;
  margin-bottom:8px;
}
.turn-bar{
  background:linear-gradient(90deg,#2f343c,#242a31);
  border-top:1px solid #3b3f46;
  border-bottom:1px solid #3b3f46;
  padding:10px 14px;
  font-size:13px;
  font-weight:800;
  color:#e5e7eb;
  display:flex;
  align-items:center;
  gap:8px;
  box-shadow:0 2px 4px rgba(0,0,0,.12);
  margin-top:6px;
}
.turn-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  background:#d92d2d;
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-size:11px;
  font-weight:900;
}
.log-entry{
  background:#1f232a;
  border:1px solid #334155;
  border-left:4px solid #334155;
  padding:10px 12px;
  margin-bottom:12px;
  border-radius:10px;
  font-size:12px;
  line-height:1.35;
  color:#e5e7eb;
  box-shadow:0 2px 6px rgba(0,0,0,.35);
}
.log-entry.p1{
  border-left-color:#3b82f6;
}
.log-entry.p2{
  border-left-color:#ef4444;
}
.log-entry.sys{
  border-left-color:#9ca3af;
}
.entry-player{
  font-weight:800;
  margin-bottom:4px;
}
.entry-player.p1{
  color:#1e73d8;
}
.entry-player.p2{
  color:#d82020;
}
.entry-player.sys{
  color:#888;
}
.entry-text{
  line-height:1.35;
}
.log-thumb{
  width:48px;
  height:67px;
  border-radius:6px;
  margin-top:8px;
  box-shadow:0 2px 6px rgba(0,0,0,.45);
  border:1px solid #1f2937;
  cursor:pointer;
  align-self:flex-start;
}
#historyBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.7);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
#historyBackdrop.show{
  display:flex;
}
#historyCard{
  width:min(600px,90vw);
  background:#101418;
  border:1px solid #334155;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  border-radius:16px;
  padding:20px;
  color:#e5e7eb;
  max-height:80vh;
  overflow-y:auto;
}
#historyCard h2{
  margin:0 0 10px 0;
  font-size:22px;
  text-align:center;
}
#fullHistory{
  font-size:13px;
  line-height:1.32;
}
.match-log-entry{
  background:#111827;
  border:1px solid #374151;
  border-left:4px solid #9ca3af;
  border-radius:8px;
  padding:8px 10px;
  box-shadow:0 2px 6px rgba(0,0,0,.4);
  margin-bottom:12px;
  color:#e5e7eb;
}
.ability-glow{
  animation:glowPulse 1.2s infinite;
  cursor:pointer;
  box-shadow:0 0 10px rgba(255,255,255,0.6);
}
.ability-disabled{
  opacity:0.45;
  filter:grayscale(70%);
  pointer-events:none;
}
.ability-entry{
  background:rgba(85, 105, 255, 0.14);
  border:1px solid rgba(110, 150, 255, 0.4);
  border-radius:8px;
  padding:8px 10px;
  margin:6px 0;
  transition:0.15s ease;
}
.ability-entry.disabled{
  opacity:0.45;
  pointer-events:none;
}
.ability-header{
  display:flex;
  align-items:center;
  gap:6px;
  margin-bottom:6px;
}
.ability-badge{
  background:linear-gradient(90deg, #cc2a2a, #ff5959);
  color:white;
  padding:2px 8px;
  border-radius:6px;
  font-size:11px;
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:0.5px;
}
.ability-title{
  font-size:14px;
  font-weight:700;
  color:#ffffff;
}
.ability-desc{
  font-size:12px;
  line-height:1.3;
  opacity:0.9;
  color:#e8e8e8;
  margin-top:3px;
}
.ability-used-tag{
  margin-top:6px;
  font-size:11px;
  font-weight:bold;
  color:#ffaaaa;
  text-align:right;
}
.attack-ability-wrapper{
  margin-bottom:8px;
}
.attack-ability-row{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  padding:6px 10px;
  border-radius:10px !important;
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  box-shadow:0 0 0 1px rgba(15,23,42,0.7);
  cursor:pointer;
  transition:transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.15s;
  min-height:52px;
}
.attack-ability-row.used{
  opacity:0.45;
  cursor:default;
}
.attack-ability-left{
  display:flex;
  flex-direction:column;
  gap:2px;
}
.attack-ability-label{
  font-size:9px !important;
  font-weight:700;
  padding:1px 6px;
  border-radius:999px;
  background:rgba(0,0,0,0.4);
  text-transform:uppercase;
  letter-spacing:0.8px !important;
  color:rgba(255, 255, 255, 0.95) !important;
}
.attack-ability-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#fff !important;
  margin-top:2px !important;
  line-height:1.2 !important;
}
.attack-ability-right{
  display:flex;
  align-items:center;
  gap:4px;
  font-size:11px;
  opacity:0.8;
}
.attack-ability-toggle{
  cursor:pointer;
}
.attack-ability-desc{
  margin-top:4px;
  padding:6px 10px 7px;
  border-radius:8px;
  background:rgba(254, 226, 226, 0.2) !important;
  font-size:11px;
  color:#fecaca !important;
  line-height:1.3 !important;
  display:none;
}
.attack-desc{
  margin-top:-2px !important;
  margin-bottom:4px !important;
  padding:4px 10px 6px;
  border-radius:8px;
  background:rgba(30, 30, 40, 0.8) !important;
  font-size:11px;
  color:#d1d5db !important;
  display:none;
  line-height:1.3 !important;
}
.attack-info{
  font-size:12px !important;
  margin-left:6px;
  opacity:0.7;
  cursor:pointer;
  padding:2px 6px !important;
  color:#00d4ff !important;
}
#player1{
  border-radius:16px;
  padding:12px;
  box-shadow:0 -4px 16px rgba(0, 212, 255, 0.15);
}
#player2{
  border-radius:16px;
  padding:12px;
  box-shadow:0 4px 16px rgba(227, 53, 13, 0.15);
}
.zoom-card{
  border-radius:16px !important;
}
.zoom-hp-bar{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
  border-radius:8px;
  box-shadow:inset 0 1px 2px rgba(0, 0, 0, 0.2);
}
.zoom-ability-card{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border:2px solid #ef4444 !important;
  border-radius:10px !important;
  padding:16px !important;
  backdrop-filter:blur(10px);
  margin-bottom:8px !important;
}
.energy.selected{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 16px rgba(0, 255, 255, 0.8) !important;
  transform:scale(1.2) !important;
}
#mainButton{
  background:rgba(40, 40, 50, 0.98) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:50px !important;
  padding:12px 20px !important;
  font-size:14px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  transition:all 0.3s ease;
  z-index:150 !important;
  backdrop-filter:blur(20px);
  position:fixed !important;
  right:30px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
  bottom:220px !important;
}
.popup{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  color:#111827 !important;
  border-radius:50px !important;
  padding:14px 28px !important;
  font-weight:600 !important;
  font-size:15px !important;
  border:2px solid #e5e7eb !important;
  z-index:2500 !important;
}
.deck-bubble, .discard-btn{
  background:rgba(15, 15, 25, 0.85) !important;
  backdrop-filter:blur(12px);
  border:2px solid rgba(138, 43, 226, 0.4) !important;
  border-radius:12px !important;
}
.victory-overlay{
  background:rgba(0, 0, 0, 0.9) !important;
  backdrop-filter:blur(12px);
  z-index:5000 !important;
}
.victory-content{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  border-radius:24px !important;
  border:3px solid #00d4ff !important;
}
.victory-title{
  font-size:44px !important;
  font-weight:700 !important;
  color:#111827 !important;
  text-transform:uppercase;
  letter-spacing:2px;
}
.victory-btn{
  background:linear-gradient(135deg, #00d4ff 0%, #0ff 100%) !important;
  color:#000 !important;
  border:none !important;
  border-radius:50px !important;
  padding:16px 40px !important;
  font-size:17px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  box-shadow:0 8px 24px rgba(0, 212, 255, 0.5) !important;
}
.glow-promote, .promote-glow{
  animation:promoteGlow 1.5s ease-in-out infinite !important;
  border:3px solid #0ff !important;
}
.zoom-attack-name{
  font-size:16px !important;
  font-weight:700 !important;
  color:#ffffff !important;
}
.zoom-attack-text{
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
  margin-top:4px !important;
}
.zoom-stats{
  border-radius:10px !important;
  padding:12px !important;
  margin-top:16px !important;
}
.zoom-stat-label{
  color:#9ca3af !important;
  font-weight:600 !important;
  font-size:12px !important;
  text-transform:uppercase;
  letter-spacing:1px;
  margin-bottom:6px !important;
}
.zoom-stat-value{
  color:#ffffff !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  gap:6px !important;
  font-size:16px !important;
}
.attack-ability-wrapper[data-type="grass"] .attack-ability-row{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
}
.attack-ability-wrapper[data-type="fire"] .attack-ability-row{
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
}
.attack-ability-wrapper[data-type="water"] .attack-ability-row{
  background:linear-gradient(90deg, #3b82f6 0%, #2563eb 100%) !important;
}
.attack-ability-wrapper[data-type="lightning"] .attack-ability-row{
  background:linear-gradient(90deg, #eab308 0%, #ca8a04 100%) !important;
}
.attack-ability-wrapper[data-type="psychic"] .attack-ability-row{
  background:linear-gradient(90deg, #a855f7 0%, #9333ea 100%) !important;
}
.attack-ability-wrapper[data-type="fighting"] .attack-ability-row{
  background:linear-gradient(90deg, #f97316 0%, #ea580c 100%) !important;
}
.attack-ability-wrapper[data-type="darkness"] .attack-ability-row{
  background:linear-gradient(90deg, #64748b 0%, #475569 100%) !important;
}
.attack-ability-wrapper[data-type="metal"] .attack-ability-row{
  background:linear-gradient(90deg, #94a3b8 0%, #64748b 100%) !important;
}
.attack-ability-wrapper[data-type="dragon"] .attack-ability-row{
  background:linear-gradient(90deg, #d3ba30 0%, #b89e20 100%) !important;
}
.attack-ability-wrapper[data-type="fairy"] .attack-ability-row{
  background:linear-gradient(90deg, #ec4899 0%, #db2777 100%) !important;
}
.attack-ability-wrapper[data-type="colorless"] .attack-ability-row{
  background:linear-gradient(90deg, #9ca3af 0%, #6b7280 100%) !important;
}
.attack-item.payable[data-type="grass"]{
  background:rgba(34, 197, 94, 0.2) !important;
  border-color:#22c55e !important;
}
.attack-item.payable[data-type="grass"] .attack-name{
  color:#15803d !important;
}
.attack-item.payable[data-type="fire"]{
  background:rgba(239, 68, 68, 0.2) !important;
  border-color:#ef4444 !important;
}
.attack-item.payable[data-type="fire"] .attack-name{
  color:#b91c1c !important;
}
.attack-item.payable[data-type="water"]{
  background:rgba(59, 130, 246, 0.2) !important;
  border-color:#3b82f6 !important;
}
.attack-item.payable[data-type="water"] .attack-name{
  color:#1e40af !important;
}
.attack-item.payable[data-type="lightning"]{
  background:rgba(234, 179, 8, 0.2) !important;
  border-color:#eab308 !important;
}
.attack-item.payable[data-type="lightning"] .attack-name{
  color:#a16207 !important;
}
.attack-item.payable[data-type="psychic"]{
  background:rgba(168, 85, 247, 0.2) !important;
  border-color:#a855f7 !important;
}
.attack-item.payable[data-type="psychic"] .attack-name{
  color:#7e22ce !important;
}
.attack-item.payable[data-type="fighting"]{
  background:rgba(249, 115, 22, 0.2) !important;
  border-color:#f97316 !important;
}
.attack-item.payable[data-type="fighting"] .attack-name{
  color:#c2410c !important;
}
.attack-item.payable[data-type="darkness"]{
  background:rgba(100, 116, 139, 0.2) !important;
  border-color:#64748b !important;
}
.attack-item.payable[data-type="darkness"] .attack-name{
  color:#334155 !important;
}
.attack-item.payable[data-type="metal"]{
  background:rgba(148, 163, 184, 0.2) !important;
  border-color:#94a3b8 !important;
}
.attack-item.payable[data-type="metal"] .attack-name{
  color:#475569 !important;
}
.attack-item.payable[data-type="dragon"]{
  background:linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%) !important;
  border-color:#8b5cf6 !important;
}
.attack-item.payable[data-type="dragon"] .attack-name{
  color:#6d28d9 !important;
}
.attack-item.payable[data-type="fairy"]{
  background:linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%) !important;
  border-color:#ec4899 !important;
}
.attack-item.payable[data-type="fairy"] .attack-name{
  color:#be185d !important;
}
.attack-item.payable[data-type="colorless"]{
  background:linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%) !important;
  border-color:#9ca3af !important;
}
.attack-item.payable[data-type="colorless"] .attack-name{
  color:#4b5563 !important;
}
.log-toggle-btn{
  bottom:20px !important;
  z-index:100 !important;
}
.prize-area{
  z-index:50 !important;
}
.hand{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
}
.bench{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
}
.player-area > * + *{
  margin-top:2px !important;
}
.zoom-attack-header{
  display:flex !important;
  justify-content:space-between !important;
  align-items:center !important;
  margin-bottom:10px !important;
}
.zoom-attack-damage{
  font-size:20px !important;
  font-weight:900 !important;
  color:#ffffff !important;
}
.zoom-attack-cost{
  display:flex !important;
  gap:3px !important;
  margin-right:8px !important;
}
.zoom-retreat-cost{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:10px !important;
  padding:12px !important;
  margin-top:12px !important;
}
.zoom-retreat-btn{
  background:rgba(50, 50, 60, 0.8) !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  border-radius:10px !important;
  padding:14px !important;
  margin-top:12px !important;
  font-size:15px !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
}
.zoom-panel *{
  filter:none !important;
  color:inherit;
}
.attack-damage{
  font-weight:900 !important;
}
[id*="log"] button{
  z-index:90 !important;
}
.zoom-ability-card[data-type="grass"]{
  background:linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.3) 100%) !important;
  border-color:#22c55e !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-name{
  color:#15803d !important;
}
.zoom-ability-card[data-type="fire"]{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border-color:#ef4444 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-name{
  color:#b91c1c !important;
}
.zoom-ability-card[data-type="water"]{
  background:linear-gradient(135deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.3) 100%) !important;
  border-color:#3b82f6 !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-name{
  color:#1e40af !important;
}
.zoom-ability-card[data-type="lightning"]{
  background:linear-gradient(135deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.3) 100%) !important;
  border-color:#eab308 !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-name{
  color:#a16207 !important;
}
.zoom-ability-card[data-type="psychic"]{
  background:linear-gradient(135deg, rgba(168, 85, 247, 0.3) 0%, rgba(147, 51, 234, 0.3) 100%) !important;
  border-color:#a855f7 !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-name{
  color:#7e22ce !important;
}
.zoom-ability-card[data-type="fighting"]{
  background:linear-gradient(135deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.3) 100%) !important;
  border-color:#f97316 !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-name{
  color:#c2410c !important;
}
.zoom-ability-card[data-type="darkness"]{
  background:linear-gradient(135deg, rgba(100, 116, 139, 0.3) 0%, rgba(71, 85, 105, 0.3) 100%) !important;
  border-color:#64748b !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-name{
  color:#334155 !important;
}
.zoom-ability-card[data-type="metal"]{
  background:linear-gradient(135deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.3) 100%) !important;
  border-color:#94a3b8 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-name{
  color:#475569 !important;
}
.zoom-ability-text{
  -webkit-font-smoothing:antialiased !important;
  -moz-osx-font-smoothing:grayscale !important;
  text-rendering:optimizeLegibility !important;
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
}
.zoom-section-title{
  color:#9ca3af !important;
  margin-bottom:10px !important;
}
.zoom-ability-name{
  font-size:18px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  margin-bottom:6px !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-text{
  color:#bbf7d0 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-text{
  color:#fecaca !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-text{
  color:#bfdbfe !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-text{
  color:#fde68a !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-text{
  color:#e9d5ff !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-text{
  color:#fdba74 !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-text{
  color:#cbd5e1 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-text{
  color:#e2e8f0 !important;
}
.zoom-tool-section{
  color:#e5e7eb !important;
}
.zoom-close{
  background:#ef4444 !important;
  color:#fff !important;
}
.zoom-tool-count{
  background:rgba(50, 50, 60, 0.8) !important;
  color:#ffffff !important;
  padding:4px 10px !important;
  border-radius:12px !important;
  font-weight:700 !important;
}
.zoom-attack-cost-icon{
  width:20px !important;
  height:18px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  border:1px solid rgba(255, 255, 255, 0.2) !important;
}
div[style*="retreat"]{
  margin-top:6px !important;
  padding:6px 10px !important;
  min-height:36px !important;
  background:rgba(60, 60, 70, 0.6) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  color:#ffffff !important;
}
[class*="retreat"] button{
  padding:6px 10px !important;
  min-height:36px !important;
  font-size:13px !important;
  color:#ffffff !important;
}
.zoom-ability-badge{
  padding:3px 10px !important;
  font-size:10px !important;
  margin-bottom:6px !important;
}
.zoom-resistance{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:8px !important;
}
.attack-menu *{
  color:#ffffff !important;
}
.show-log-btn{
  z-index:100 !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  position:fixed !important;
  bottom:20px !important;
  right:20px !important;
}
[class*="turn"]{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:1px solid rgba(100, 100, 120, 0.3) !important;
}
[class*="discard"] button{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  transition:all 0.2s ease !important;
}
.deck-count{
  color:#ffffff !important;
  font-weight:700 !important;
}
.energy-zone.horizontal{
  flex-direction:row !important;
  border-radius:40px !important;
  padding:10px 14px !important;
}
[class*="turn-box"]{
  position:fixed !important;
  right:30px !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  border-radius:12px !important;
  padding:12px 16px !important;
  font-weight:600 !important;
  text-align:center !important;
  z-index:50 !important;
  min-width:120px !important;
}
#player1 .discard-btn{
  position:absolute !important;
  left:20px !important;
  bottom:50% !important;
  transform:translateY(50%) !important;
}
#player2 .discard-btn{
  position:absolute !important;
  left:20px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
}
#turnInfo{
  bottom:300px !important;
}
.turn-info{
  z-index:50 !important;
}

/* ============================================
   BUTTON SIZE FIXES
============================================ */
/* Fix oversized buttons and elements */

/* Show Log button - make it compact */
#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed;
  right: 30px;
  bottom: 20px;
  padding: 8px 16px;
  background: rgba(40, 40, 50, 0.9);
  border: 1px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  color: #e5e7eb;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  transition: all 0.2s ease;
  width: auto;
  height: auto;
  min-width: auto;
}

#logToggleBtn:hover, #showLogBtn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3);
}

/* Energy Zone - make it compact and positioned correctly */
.energy-zone {
  position: fixed;
  right: 30px;
  bottom: 60px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 10px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 12px;
  z-index: 200;
  width: auto;
  max-width: 60px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
}

.energy {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-size: cover;
  background-position: center;
  cursor: pointer;
  border: 2px solid rgba(100, 100, 120, 0.3);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  transition: all 0.2s ease;
}

.energy:hover {
  transform: scale(1.1);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.5);
}

.energy.selected {
  border: 3px solid #0ff;
  box-shadow: 0 0 16px rgba(0, 255, 255, 0.8);
  transform: scale(1.15);
}

/* View Discard buttons - make them compact like deck bubbles */
.discard-btn {
  position: absolute;
  width: 85px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  color: #fff;
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
  z-index: 9;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  transition: all 0.2s ease;
  padding: 0;
}

.discard-btn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.4);
  transform: scale(1.05);
}

/* Deck bubble - keep small and compact */
.deck-bubble {
  width: 36px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 50%;
  font-size: 13px;
  font-weight: 700;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

/* Turn info box - compact */
.turnbox, #turnInfo {
  width: 120px;
  padding: 8px 12px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

/* Main button (END TURN) - keep reasonable size */
#mainButton {
  padding: 12px 24px;
  font-size: 15px;
  font-weight: 700;
  min-width: 140px;
  height: auto;
  border-radius: 50px;
}


/* ============================================
   RESTORE ORIGINAL LAYOUT - Match Image 1
============================================ */

/* Remove all the fixed positioning we added */
#mainButton {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  padding: 8px 14px !important;
  font-size: 0.9rem !important;
  min-width: 150px !important;
  max-width: none !important;
  height: auto !important;
  border-radius: 10px !important;
  background: linear-gradient(135deg, #e3350d, #0074d9) !important;
  border: 1px solid #1f2937 !important;
  color: #fff !important;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35) !important;
  cursor: pointer !important;
  z-index: auto !important;
}

#mainButton::after {
  display: none !important;
}

/* Energy zone - restore to side panel */
.energy-zone {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  display: flex !important;
  flex-wrap: wrap !important;
  gap: 6px !important;
  justify-content: center !important;
  padding: 0 !important;
  background: transparent !important;
  border: none !important;
  border-radius: 0 !important;
  z-index: auto !important;
  width: auto !important;
  max-width: none !important;
  box-shadow: none !important;
}

.energy {
  width: 28px !important;
  height: 28px !important;
  border-radius: 50% !important;
  background-size: cover !important;
  background-position: center !important;
  cursor: pointer !important;
  border: 2px solid #3b3f46 !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.6) !important;
  transition: transform 0.2s ease !important;
}

.energy:hover {
  transform: scale(1.1) !important;
}

.energy.selected {
  border: 3px solid #0ff !important;
  box-shadow: 0 0 12px rgba(0, 255, 255, 0.8) !important;
  transform: scale(1.15) !important;
}

/* Side panel - restore original positioning */
.side-panel {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 0.6rem !important;
  z-index: 10 !important;
}

/* Turn box - restore to side panel */
.turnbox, #turnInfo {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  width: 150px !important;
  border: 1px solid #3b3f46 !important;
  background: #23272e !important;
  border-radius: 12px !important;
  padding: 10px !important;
  text-align: center !important;
  font-size: 0.92rem !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4) !important;
  color: #e5e7eb !important;
  z-index: auto !important;
}

.turnbox .big {
  font-weight: 800;
  font-size: 1.05rem;
}

/* Show Log button - restore original */
#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed !important;
  right: 30px !important;
  top: 355px !important;
  bottom: auto !important;
  z-index: 1500 !important;
  background: linear-gradient(90deg, #2a2f36, #1f232a) !important;
  border: 1px solid #334155 !important;
  padding: 8px 14px !important;
  color: #e5e7eb !important;
  border-radius: 10px !important;
  font-size: 0.85rem !important;
  cursor: pointer !important;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4) !important;
  width: auto !important;
  height: auto !important;
  min-width: auto !important;
}

#logToggleBtn:hover, #showLogBtn:hover {
  filter: brightness(1.08);
}

/* Remove any label styling we added */
.energy-zone-label,
#energyZoneLabel {
  display: none !important;
}

.energy-zone::before {
  content: none !important;
  display: none !important;
}

/* Coin - keep in side panel */
.coin {
  position: static !important;
  top: auto !important;
  right: auto !important;
  width: 70px !important;
  height: 70px !important;
  transform-style: preserve-3d !important;
  transition: transform 1.5s ease-in-out !important;
  z-index: auto !important;
}

/* Coin result text */
#coinResult {
  text-align: center;
  font-weight: 700;
  font-size: 13px;
  min-height: 35px;
}

/* Ensure buttons in side panel have correct styling */
.side-panel button {
  background: linear-gradient(135deg, #e3350d, #0074d9);
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 0.9rem;
  min-width: 150px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
  border: 1px solid #1f2937;
}

.side-panel button:hover {
  opacity: 0.95;
}


/* ============================================
   FINAL POLISH - Dark menus, compact padding, type-based backgrounds
============================================ */

/* 1. LEFT-CLICK ATTACK MENU - Dark background, minimal padding */
.attack-menu {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border: 2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8) !important;
  padding: 8px !important;
  min-width: 240px !important;
  color: #e5e7eb !important;
}

.attack-item {
  padding: 8px 10px !important;
  margin-bottom: 4px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 8px !important;
  color: #ffffff !important;
  min-height: 36px !important;
}

.attack-item:hover {
  background: rgba(60, 60, 70, 0.9) !important;
  border-color: #00d4ff !important;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3) !important;
}

.attack-item.payable {
  border-color: #00d4ff !important;
  background: rgba(0, 212, 255, 0.15) !important;
}

.attack-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  line-height: 1.2 !important;
}

.attack-cost {
  gap: 3px !important;
}

.cost-icon {
  width: 18px !important;
  height: 18px !important;
}

.attack-desc {
  padding: 3px 5px !important;
  margin-top: 2px !important;
  margin-bottom: 4px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(20, 20, 30, 0.8) !important;
  color: #d1d5db !important;
  border-radius: 6px !important;
}

/* Ability row - dark with red accent */
.attack-ability-wrapper {
  margin-bottom: 6px !important;
}

.attack-ability-row {
  padding: 8px 10px !important;
  background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  border-radius: 8px !important;
  min-height: 36px !important;
}

.attack-ability-row:hover {
  background: linear-gradient(90deg, #dc2626 0%, #b91c1c 100%) !important;
}

.attack-ability-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #fff !important;
  line-height: 1.2 !important;
}

.attack-ability-label {
  font-size: 9px !important;
  padding: 2px 6px !important;
}

.attack-ability-desc {
  padding: 3px 5px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(254, 226, 226, 0.2) !important;
  color: #fecaca !important;
}

/* 2. ZOOM MODAL - Compact padding, dark theme */
.zoom-panel {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border-radius: 16px !important;
  padding: 16px !important;
  color: #e5e7eb !important;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9) !important;
  border: 2px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-header {
  margin-bottom: 12px !important;
  padding-bottom: 10px !important;
}

.zoom-title {
  font-size: 20px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-hp {
  font-size: 14px !important;
  color: #ffffff !important;
  margin-bottom: 8px !important;
}

.hpbar-container {
  margin: 6px 0 !important;
}

.zoom-section {
  margin-top: 10px !important;
  padding-top: 10px !important;
  border-top: 1px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-attack {
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-attack .top {
  padding: 6px 8px !important;
}

.zoom-attack-name,
.zoom-attack .name {
  font-size: 15px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-attack-damage,
.zoom-attack .dmg {
  font-size: 18px !important;
  font-weight: 900 !important;
  color: #ffffff !important;
}

.zoom-attack-text,
.effect {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #d1d5db !important;
  margin-top: 4px !important;
}

/* Ability in zoom */
.zoom-ability-card,
.ability-box {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border: 2px solid #ef4444 !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-ability-name,
.ability-name {
  font-size: 16px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  margin-bottom: 6px !important;
}

.zoom-ability-text,
.ability-text {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #fecaca !important;
}

/* Retreat row */
#zoomRetreatRow {
  padding: 10px 12px !important;
  margin-top: 10px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
}

/* Row spacing */
.row {
  margin: 6px 0 !important;
  gap: 6px !important;
}

.chip {
  padding: 3px 8px !important;
  font-size: 11px !important;
}

/* 3. TYPE-BASED PLAYER BACKGROUNDS */

/* Grass type */
#player1.type-grass,
#player2.type-grass {
  background: linear-gradient(180deg, 
    rgba(34, 197, 94, 0.3) 0%, 
    rgba(22, 163, 74, 0.5) 50%, 
    rgba(21, 128, 61, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(34, 197, 94, 0.3) !important;
  border: 1px solid rgba(34, 197, 94, 0.3) !important;
}

/* Fire type */
#player1.type-fire,
#player2.type-fire {
  background: linear-gradient(180deg, 
    rgba(239, 68, 68, 0.3) 0%, 
    rgba(220, 38, 38, 0.5) 50%, 
    rgba(185, 28, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(239, 68, 68, 0.3) !important;
  border: 1px solid rgba(239, 68, 68, 0.3) !important;
}

/* Water type */
#player1.type-water,
#player2.type-water {
  background: linear-gradient(180deg, 
    rgba(59, 130, 246, 0.3) 0%, 
    rgba(37, 99, 235, 0.5) 50%, 
    rgba(29, 78, 216, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(59, 130, 246, 0.3) !important;
  border: 1px solid rgba(59, 130, 246, 0.3) !important;
}

/* Lightning type */
#player1.type-lightning,
#player2.type-lightning {
  background: linear-gradient(180deg, 
    rgba(234, 179, 8, 0.3) 0%, 
    rgba(202, 138, 4, 0.5) 50%, 
    rgba(161, 98, 7, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(234, 179, 8, 0.3) !important;
  border: 1px solid rgba(234, 179, 8, 0.3) !important;
}

/* Psychic type */
#player1.type-psychic,
#player2.type-psychic {
  background: linear-gradient(180deg, 
    rgba(168, 85, 247, 0.3) 0%, 
    rgba(147, 51, 234, 0.5) 50%, 
    rgba(126, 34, 206, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.3) !important;
  border: 1px solid rgba(168, 85, 247, 0.3) !important;
}

/* Fighting type */
#player1.type-fighting,
#player2.type-fighting {
  background: linear-gradient(180deg, 
    rgba(249, 115, 22, 0.3) 0%, 
    rgba(234, 88, 12, 0.5) 50%, 
    rgba(194, 65, 12, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(249, 115, 22, 0.3) !important;
  border: 1px solid rgba(249, 115, 22, 0.3) !important;
}

/* Darkness type */
#player1.type-darkness,
#player2.type-darkness {
  background: linear-gradient(180deg, 
    rgba(100, 116, 139, 0.3) 0%, 
    rgba(71, 85, 105, 0.5) 50%, 
    rgba(51, 65, 85, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(100, 116, 139, 0.3) !important;
  border: 1px solid rgba(100, 116, 139, 0.3) !important;
}

/* Metal type */
#player1.type-metal,
#player2.type-metal {
  background: linear-gradient(180deg, 
    rgba(148, 163, 184, 0.3) 0%, 
    rgba(100, 116, 139, 0.5) 50%, 
    rgba(71, 85, 105, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(148, 163, 184, 0.3) !important;
  border: 1px solid rgba(148, 163, 184, 0.3) !important;
}

/* Dragon type */
#player1.type-dragon,
#player2.type-dragon {
  background: linear-gradient(180deg, 
    rgba(211, 186, 48, 0.3) 0%, 
    rgba(184, 158, 32, 0.5) 50%, 
    rgba(169, 142, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(211, 186, 48, 0.3) !important;
  border: 1px solid rgba(211, 186, 48, 0.3) !important;
}

/* Fairy type */
#player1.type-fairy,
#player2.type-fairy {
  background: linear-gradient(180deg, 
    rgba(236, 72, 153, 0.3) 0%, 
    rgba(219, 39, 119, 0.5) 50%, 
    rgba(190, 24, 93, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(236, 72, 153, 0.3) !important;
  border: 1px solid rgba(236, 72, 153, 0.3) !important;
}

/* Colorless type */
#player1.type-colorless,
#player2.type-colorless {
  background: linear-gradient(180deg, 
    rgba(156, 163, 175, 0.3) 0%, 
    rgba(107, 114, 128, 0.5) 50%, 
    rgba(75, 85, 99, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(156, 163, 175, 0.3) !important;
  border: 1px solid rgba(156, 163, 175, 0.3) !important;
}

/* Default if no type class */
#player1:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    transparent 0%, 
    rgba(30, 58, 95, 0.4) 15%, 
    rgba(13, 31, 58, 0.6) 100%) !important;
  box-shadow: 0 -6px 24px rgba(59, 130, 246, 0.25) !important;
  border: 1px solid rgba(59, 130, 246, 0.2) !important;
}

#player2:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    rgba(95, 30, 30, 0.6) 0%, 
    rgba(58, 13, 13, 0.4) 75%, 
    transparent 100%) !important;
  box-shadow: 0 6px 24px rgba(239, 68, 68, 0.25) !important;
  border: 1px solid rgba(239, 68, 68, 0.2) !important;
}



/* ============================================
   ATTACK MENU ULTIMATE Z-INDEX FIX
   Makes menu appear as high as possible
============================================ */

/* CRITICAL: Attack menu must be above everything */
.attack-menu {
  z-index: 99999 !important;
  position: fixed !important;
}

/* Ensure card-slot can have positioned children escape */
.card-slot {
  position: relative;
  isolation: auto !important; /* Prevent new stacking context */
}

/* Make sure active area doesn't create stacking context */
.active {
  position: relative;
  z-index: auto !important;
  isolation: auto !important;
}

/* Player areas must have lower z-index */
#player1, #player2 {
  position: relative;
  z-index: 1 !important;
}

/* Ensure player area doesn't block */
.player-area {
  z-index: auto !important;
}

/* When menu is open, boost the entire chain */
.active:has(.attack-menu) {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .card-slot {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .attack-menu {
  z-index: 99999 !important;
}






/* ============================================
   PTCGL ATTACK MENU - SINGLE CLEAN VERSION
============================================ */

.attack-menu-backdrop { display: none !important; }

.attack-menu.ptcgl-style {
  position: fixed !important;
  z-index: 99999 !important;
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  display: block !important;
}

.ptcgl-card-container {
  position: relative;
  width: 280px;
  height: 392px;
  border-radius: 12px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
  overflow: hidden;
}

.ptcgl-card-container img {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  object-fit: cover;
}

/* Close button removed - click outside card to close */

.ptcgl-hp-type-bar {
  position: absolute;
  top: 6px;
  right: 6px;
  background: rgba(0, 0, 0, 0.85);
  padding: 6px 10px;
  border-radius: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 10;
}

.ptcgl-hp-number {
  font-size: 16px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-type-icon-inline {
  width: 20px;
  height: 20px;
  background-size: cover;
  border-radius: 50%;
}

.ptcgl-actions-overlay {
  position: absolute;
  top: 225px;
  left: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 3px;
  z-index: 10;
}

.ptcgl-ability-overlay {
  background: rgba(239, 68, 68, 0.96);  /* Default red (fallback) */
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 3px 5px;
  cursor: pointer;
}

/* ABILITY TYPE COLORS */
.ptcgl-ability-overlay.type-grass {
  background: rgba(139, 195, 74, 0.96);
  border: 1px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-ability-overlay.type-fire {
  background: rgba(239, 83, 80, 0.96);
  border: 1px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-ability-overlay.type-water {
  background: rgba(66, 165, 245, 0.96);
  border: 1px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-ability-overlay.type-lightning {
  background: rgba(255, 202, 40, 0.96);
  border: 1px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-ability-overlay.type-psychic {
  background: rgba(171, 71, 188, 0.96);
  border: 1px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-ability-overlay.type-fighting {
  background: rgba(255, 138, 101, 0.96);
  border: 1px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-ability-overlay.type-darkness {
  background: rgba(66, 66, 66, 0.96);
  border: 1px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-ability-overlay.type-metal {
  background: rgba(158, 158, 158, 0.96);
  border: 1px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-ability-overlay.type-dragon {
  background: rgba(211, 186, 48, 0.96);  /* GOLD! */
  border: 1px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-ability-overlay.type-fairy {
  background: rgba(236, 64, 122, 0.96);
  border: 1px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-ability-overlay.type-colorless {
  background: rgba(189, 189, 189, 0.96);
  border: 1px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-ability-name {
  font-size: 10px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-ability-text {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.95);
}

/* Attack overlay - DEFAULT (unpayable) state - WHITE */
.ptcgl-attack-overlay {
  background: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  cursor: not-allowed;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  opacity: 0.7;
}

/* PAYABLE - shows type color */
.ptcgl-attack-overlay.payable {
  cursor: pointer;
  opacity: 1;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
}

.ptcgl-attack-overlay.payable:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* TYPE COLORS */
.ptcgl-attack-overlay.payable.type-grass {
  background: rgba(139, 195, 74, 0.95);
  border: 2px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-attack-overlay.payable.type-fire {
  background: rgba(239, 83, 80, 0.95);
  border: 2px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-attack-overlay.payable.type-water {
  background: rgba(66, 165, 245, 0.95);
  border: 2px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-attack-overlay.payable.type-lightning {
  background: rgba(255, 202, 40, 0.95);
  border: 2px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-attack-overlay.payable.type-psychic {
  background: rgba(171, 71, 188, 0.95);
  border: 2px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-attack-overlay.payable.type-fighting {
  background: rgba(255, 138, 101, 0.95);
  border: 2px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-attack-overlay.payable.type-darkness {
  background: rgba(66, 66, 66, 0.95);
  border: 2px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-attack-overlay.payable.type-metal {
  background: rgba(158, 158, 158, 0.95);
  border: 2px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-attack-overlay.payable.type-dragon {
  background: rgba(211, 186, 48, 0.95);  /* GOLD! */
  border: 2px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-attack-overlay.payable.type-fairy {
  background: rgba(236, 64, 122, 0.95);
  border: 2px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-attack-overlay.payable.type-colorless {
  background: rgba(189, 189, 189, 0.95);
  border: 2px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-attack-left {
  flex: 1;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 6px 10px;
  z-index: 2;
}

/* Attack name - grayed out when can't pay */
.ptcgl-attack-name {
  font-size: 12px;
  font-weight: 700;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-name {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

/* Duplicate removed - using BLACK text above */



.ptcgl-attack-cost {
  display: flex;
  gap: 2px;
}

.ptcgl-cost-icon {
  width: 18px;
  height: 18px;
  background-size: cover;
  border-radius: 50%;
  opacity: 0.4;
}

.ptcgl-attack-overlay.payable .ptcgl-cost-icon {
  opacity: 1;
  filter: brightness(1.1);
}

/* Separator - dark when can't pay */
.ptcgl-attack-separator {
  display: none;
}

/* Separator - inherits type color when payable */
.ptcgl-attack-overlay.payable .ptcgl-attack-separator {
  opacity: 0.95;
}

.ptcgl-attack-damage-box {
  position: relative;
  right: auto;
  top: auto;
  width: auto;
  min-width: 40px;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 8px;
  z-index: 2;
}

.ptcgl-attack-damage {
  font-size: 22px;
  font-weight: 900;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-damage {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

.ptcgl-attack-effect {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.85);
  padding: 0 5px 3px 5px;
}

.ptcgl-retreat-corner {
  position: absolute;
  bottom: 35px;
  right: 6px;
  background: rgba(255, 255, 255, 0.98);
  border-radius: 12px;
  padding: 3px 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  z-index: 10;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-retreat-corner:hover {
  background: rgba(255, 255, 255, 1);
  transform: translateY(-1px);
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
}

/* Type-based coloring for retreat corner */
.ptcgl-retreat-corner[data-type="water"] { background: #6890f0 !important; }
.ptcgl-retreat-corner[data-type="fire"] { background: #f08030 !important; }
.ptcgl-retreat-corner[data-type="grass"] { background: #78c850 !important; }
.ptcgl-retreat-corner[data-type="lightning"] { background: #f8d030 !important; }
.ptcgl-retreat-corner[data-type="psychic"] { background: #f85888 !important; }
.ptcgl-retreat-corner[data-type="fighting"] { background: #c03028 !important; }
.ptcgl-retreat-corner[data-type="darkness"] { background: #705848 !important; }
.ptcgl-retreat-corner[data-type="metal"] { background: #b8b8d0 !important; }
.ptcgl-retreat-corner[data-type="colorless"] { background: #c6c6a7 !important; }
.ptcgl-retreat-corner[data-type="dragon"] { background: #7038f8 !important; }

/* White text for colored retreat */
.ptcgl-retreat-corner[data-type] .ptcgl-retreat-label,
.ptcgl-retreat-corner[data-type] .ptcgl-retreat-icon {
  color: #ffffff !important;
}

.ptcgl-retreat-label {
  font-size: 10px;
  font-weight: 700;
  color: #000000;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}


/* Energy pips display */
.ptcgl-energy-pips {
  position: absolute;
  bottom: 6px;
  left: 6px;
  right: 6px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  max-height: 50px;
  z-index: 5;
  pointer-events: none;
}

.ptcgl-energy-pip {
  width: 20px;
  height: 20px;
  background-size: cover;
  background-position: center;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.8);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
}

.ptcgl-weakness-corner {
  position: absolute;
  bottom: 35px;
  left: 6px;
  background: rgba(255, 255, 255, 0.98);
  padding: 4px 6px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 4px;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-weakness-label {
  font-size: 9px;
  font-weight: 700;
  color: #000000 !important;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}

.ptcgl-weakness-value {
  font-size: 13px;
  font-weight: 900;
  color: #000000 !important;
  line-height: 1;
}

.ptcgl-weakness-icon {
  width: 16px;
  height: 16px;
  background-size: cover;
  border-radius: 50%;
}

.type-grass { color: #22c55e !important; }
.type-fire { color: #ef4444 !important; }
.type-water { color: #3b82f6 !important; }
.type-lightning { color: #eab308 !important; }
.type-psychic { color: #a855f7 !important; }
.type-fighting { color: #f97316 !important; }
.type-darkness { color: #64748b !important; }
.type-metal { color: #94a3b8 !important; }
.type-dragon { color: #8b5cf6 !important; }
.type-fairy { color: #ec4899 !important; }
.type-colorless { color: #9ca3af !important; }

.card-slot.menu-open {
  opacity: 0 !important;
  pointer-events: none !important;
}

/* ============================
   ABILITY MODAL STYLES
   Add these to your battle.html CSS
============================ */

/* Base ability option styling */
.ability-option {
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: white;
  font-weight: 500;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
  border: 2px solid transparent;
}

/* Active abilities - clickable */
.ability-option:not(.passive-ability):hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.3);
  border-color: rgba(255,255,255,0.3);
}

/* Passive abilities - not clickable */
.ability-option.passive-ability {
  cursor: not-allowed;
  opacity: 0.75;
  border: 2px solid rgba(255,255,255,0.2);
  filter: saturate(0.7);
}

.ability-option.passive-ability:hover {
  transform: none;
  box-shadow: none;
}

/* Passive label badge */
.passive-label {
  display: inline-block;
  padding: 3px 8px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 4px;
  font-size: 10px;
  font-weight: bold;
  color: white;
  margin-left: 8px;
  letter-spacing: 0.5px;
  vertical-align: middle;
}

/* ============================
   TYPE-BASED BACKGROUNDS
============================ */

/* Grass */
.ability-grass {
  background: linear-gradient(135deg, #78C850 0%, #5CA935 100%);
}

/* Fire */
.ability-fire {
  background: linear-gradient(135deg, #F08030 0%, #DD6610 100%);
}

/* Water */
.ability-water {
  background: linear-gradient(135deg, #6890F0 0%, #386CEB 100%);
}

/* Lightning/Electric */
.ability-lightning,
.ability-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333; /* Dark text for better contrast */
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

/* Psychic */
.ability-psychic {
  background: linear-gradient(135deg, #F85888 0%, #F61C5D 100%);
}

/* Fighting */
.ability-fighting {
  background: linear-gradient(135deg, #C03028 0%, #9D2721 100%);
}

/* Darkness/Dark */
.ability-darkness,
.ability-dark {
  background: linear-gradient(135deg, #705848 0%, #513F34 100%);
}

/* Metal/Steel */
.ability-metal,
.ability-steel {
  background: linear-gradient(135deg, #B8B8D0 0%, #9999B3 100%);
}

/* Dragon - FIXED COLOR */
.ability-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d; /* Dark text for better contrast */
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

/* Fairy */
.ability-fairy {
  background: linear-gradient(135deg, #EE99AC 0%, #E67199 100%);
}

/* Colorless/Normal */
.ability-colorless,
.ability-normal {
  background: linear-gradient(135deg, #A8A878 0%, #8A8A59 100%);
}

/* ============================
   MOVE TYPE BACKGROUNDS
   (Update dragon color here too)
============================ */

/* Dragon moves - FIXED COLOR */
.move-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

/* Lightning moves - better contrast */
.move-lightning,
.move-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

/* ============================
   ABILITY TEXT STYLING
============================ */

.ability-option strong {
  font-size: 16px;
  display: block;
  margin-bottom: 4px;
}

.ability-option small {
  font-size: 12px;
  opacity: 0.9;
  line-height: 1.4;
}

/* ============================
   RESPONSIVE ADJUSTMENTS
============================ */

@media (max-width: 768px) {
  .ability-option {
    padding: 10px 12px;
  }
  
  .ability-option strong {
    font-size: 14px;
  }
  
  .ability-option small {
    font-size: 11px;
  }
  
  .passive-label {
    font-size: 9px;
    padding: 2px 6px;
  }
}


</style>

<script src="./effects.js"></script>

</head>
<body>
<h1>Pok√©mon TCG Pocket Battle</h1>
<div id="popup"></div>
<div class="main-layout">
  <div class="battlefield">
    <div class="player-area" id="player2">
      <div id="p2Bubble" class="deck-bubble">0</div>
      <div class="points-indicator" id="p2Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="hand" id="p2Hand"></div>
      <div class="bench" id="p2Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="active" id="p2Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <button class="discard-btn right" id="p2DiscardBtn">View Discard</button>
    </div>

    <div class="player-area" id="player1">
      <div id="p1Bubble" class="deck-bubble">0</div>
      <div class="points-indicator" id="p1Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="active" id="p1Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="bench" id="p1Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="hand" id="p1Hand"></div>
      <button class="discard-btn" id="p1DiscardBtn">View Discard</button>
    </div>
  </div>

  <div class="side-panel">
    <div class="coin" id="coin">
      <img class="front" crossorigin="anonymous" src="imgs/coin_front.png" alt="Coin front">
      <img class="back" crossorigin="anonymous" src="imgs/Coin_Back_TM.png" alt="Coin back">
    </div>
    <div id="coinResult"></div>
    <button id="mainButton">Draw Hands</button>
    <div class="turnbox">
      <div>Turn</div>
      <div id="turnNum" class="big">1</div>
      <div id="turnPlayer">Current: ‚Äî</div>
    </div>
    <h4 style="margin:0 .25rem;">Energy Zone</h4>
    <div class="energy-zone" id="energyZone"></div>
    <button id="logToggleBtn">Show Log</button>
  </div>
</div>

<!-- Pok√©mon zoom modal -->
<div id="zoomBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="zoomImg" src="" alt="Card zoom">
      <img id="zoomToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel">
<div class="zoom-header">
  <div id="zoomTitle" class="zoom-title"></div>
  <div style="display:flex;align-items:center;gap:8px">
    <div id="zoomStatus" class="zoom-status" style="display:none;"></div>
    <div id="zoomHp" class="zoom-hp"></div>
    <div id="zoomType" class="zoom-type-pill"></div>
  </div>
</div>


      <div class="hpbar-container"><div id="zoomHpBar" class="hpbar-fill"></div></div>
      <div class="zoom-section" id="zoomAttached">
        <div class="row">
          <div><strong>Attached Energy</strong></div>
          <div id="zoomEnergyCount" class="chip">x0</div>
        </div>
        <div id="zoomEnergyIcons" class="icon-row"></div>
        <div class="row" style="margin-top:10px">
          <div><strong>Attached Tools</strong></div>
          <div id="zoomTools" class="icon-row"></div>
        </div>
      </div>
      <div class="zoom-section" id="zoomAbilities" style="display:none"></div>
      <div class="zoom-section">
        <div><strong>Attacks</strong></div>
        <div id="zoomAttacks"></div>
      </div>
      <div class="zoom-section">
        <div class="row">
          <div><strong>Weakness</strong></div>
          <div id="zoomWeakness" class="icon-row"></div>
        </div>
        <div class="row" id="zoomRetreatRow">
          <div><strong>Retreat</strong></div>
          <div id="zoomRetreat" class="icon-row"></div>
        </div>
        <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:6px">Right-click anywhere or press Esc.</div>
      </div>
    </div>
  </div>
</div>

<!-- Tool modal -->
<div id="toolBackdrop">
  <div id="toolCard">
    <img id="toolImg" src="" alt="Tool Card">
    <div id="toolPanel">
      <h3 id="toolTitle">Tool</h3>
      <div id="toolMeta" class="chip" style="margin-bottom:8px"></div>
      <div class="thin" style="height:1px;background:#3b3f46;margin:8px 0"></div>
      <div id="toolText" style="font-size:13px;color:#cbd5e1;line-height:1.25"></div>
      <div style="margin-top:12px;font-size:12px;color:#9ca3af">Click outside to close.</div>
    </div>
  </div>
</div>

<!-- Hand Card modal -->
<div id="handBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="handImg" src="" alt="Card image">
      <img id="handToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel" id="handPanel">
      <div id="handTitle" class="zoom-title"></div>
      <div id="handType" class="chip" style="margin-top:6px;"></div>
      <div id="handEffect" style="font-size:13px;color:#cbd5e1;margin-top:10px;line-height:1.4"></div>
      <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:12px">
        Right-click anywhere or press Esc to close.
      </div>
    </div>
  </div>
</div>

<!-- victory overlay -->
<div id="victoryOverlay">
  <div id="victoryCard">
    <h2 id="victoryTitle">Player Wins!</h2>
    <p id="victoryDesc">Game over</p>
    <div style="display:flex;justify-content:center;gap:12px;margin:10px 0 18px 0">
      <div class="chip">P1 Points: <span id="p1Pts">0</span></div>
      <div class="chip">P2 Points: <span id="p2Pts">0</span></div>
    </div>
    <div id="victoryBtns">
      <button id="playAgainBtn">Play again</button>
      <button id="chooseDecksBtn">Choose new decks</button>
      <button id="victoryShowLogBtn">Show Match Log</button>
    </div>
  </div>
</div>

<!-- discard drawers -->
<div class="discard-drawer" id="p1DiscardDrawer"></div>
<div class="discard-drawer right" id="p2DiscardDrawer"></div>

<!-- LOG PANEL (right slide) -->
<div id="logPanel">
  <div id="logPanelHeader">Battle Log</div>
  <button id="closeLogBtn" style="margin:8px 14px 10px;width:calc(100% - 28px);background:#e5e7eb;border:1px solid #c2c4c6;color:#111;padding:6px;border-radius:6px;cursor:pointer;">
    Close Log
  </button>
  <div id="logEntries"></div>
</div>


<!-- FULL MATCH HISTORY MODAL -->
<div id="historyBackdrop">
  <div id="historyCard">
    <h2>Match History</h2>
    <div id="fullHistory"></div>
    <div style="text-align:center;margin-top:14px;">
      <button onclick="document.getElementById('historyBackdrop').classList.remove('show')">
        Close
      </button>
    </div>
  </div>
</div>

<script type="module">

  

  // REQUIRED GLOBAL STATE OBJECT FOR EFFECTS
globalThis.state = { temp: { p1: {}, p2: {} } };


/* ============================
   SPECIAL EFFECTS SYSTEM
   
   Paste this entire section into your battle.html <script> tag
   (somewhere after effects.js is loaded)
============================ */

// Initialize special effects storage
if (!globalThis.__specialEffects) {
  globalThis.__specialEffects = { p1: {}, p2: {} };
  console.log('[special-effects] Initialized');
}

/**
 * Check if player can retreat
 * @param {string} pk - 'p1' or 'p2'
 * @returns {boolean}
 */
function canRetreat(pk) {
  // Check for sleep and paralysis - both block retreat
  const img = getActiveImg(pk);
  if (img) {
    const status = (img.dataset.status || '').toLowerCase();
    if (status === 'asleep') {
      console.log(`[retreat] ${pk} cannot retreat - Pokemon is asleep`);
      return false;
    }
    if (status === 'paralyzed') {
      console.log(`[retreat] ${pk} cannot retreat - Pokemon is paralyzed`);
      return false;
    }
  }
  
  if (globalThis.__specialEffects?.[pk]?.retreatLock) {
    console.log(`[special-effects] ${pk} is retreat locked`);
    return false;
  }
  return true;
}

/**
 * Check if player can attack
 * @param {string} pk - 'p1' or 'p2'
 * @returns {boolean}
 */
function canAttack(pk) {
  if (globalThis.__specialEffects?.[pk]?.attackLock) {
    console.log(`[special-effects] ${pk} is attack locked`);
    return false;
  }
  return true;
}

/**
 * Check if player can use Supporters
 * @param {string} pk - 'p1' or 'p2'
 * @returns {boolean}
 */
function canUseSupporter(pk) {
  if (globalThis.__specialEffects?.[pk]?.supporterBlock) {
    console.log(`[special-effects] ${pk} is supporter blocked`);
    return false;
  }
  return true;
}

/**
 * Apply damage reduction/prevention to incoming damage
 * @param {string} defendingPk - 'p1' or 'p2'
 * @param {number} baseDamage - Original damage amount
 * @returns {number} Final damage after reductions
 */
function applySpecialEffectsToDamage(defendingPk, baseDamage) {
  let damage = baseDamage;
  
  // üÜï A3 - Check for complete immunity (Mr. Mime's Barrier Shove)
  const defenderImg = getActiveImg(defendingPk);
  if (defenderImg?.dataset.preventAllNextTurn === 'true') {
    console.log(`[prevent-all-next-turn] ${defendingPk} immune to all damage and effects`);
    showPopup("All damage and effects prevented!");
    delete defenderImg.dataset.preventAllNextTurn; // Clear after use
    return 0;
  }
  
  // Check for complete prevention
  if (globalThis.__specialEffects?.[defendingPk]?.preventDamage) {
    console.log(`[special-effects] ${defendingPk} damage prevented`);
    showPopup("Attack prevented!");
    return 0;
  }
  
  // üÜï A3 - Check if defender takes increased damage this turn
  if (defenderImg?.dataset.incomingDamageIncrease) {
    const increase = parseInt(defenderImg.dataset.incomingDamageIncrease, 10);
    damage += increase;
    console.log(`[incoming-damage-increase] ${defendingPk} takes +${increase}: ${baseDamage} ‚Üí ${damage}`);
    showPopup(`Damage increased by ${increase}!`);
    delete defenderImg.dataset.incomingDamageIncrease; // Clear after use
  }
  
  // Apply reduction
  const reduction = globalThis.__specialEffects?.[defendingPk]?.damageReduction || 0;
  if (reduction > 0) {
    damage = Math.max(0, damage - reduction);
    console.log(`[special-effects] ${defendingPk} damage reduced by ${reduction}: ${baseDamage} ‚Üí ${damage}`);
    if (damage > 0) {
      showPopup(`Damage reduced by ${reduction}!`);
    } else {
      showPopup(`All damage blocked!`);
    }
  }
  
  return damage;
}

/**
 * Clear all special effects for a player
 * @param {string} pk - 'p1' or 'p2'
 */
function clearSpecialEffects(pk) {
  if (globalThis.__specialEffects?.[pk]) {
    const had = Object.keys(globalThis.__specialEffects[pk]).length > 0;
    if (had) {
      console.log(`[special-effects] Clearing effects for ${pk}:`, globalThis.__specialEffects[pk]);
    }
    globalThis.__specialEffects[pk] = {};
  }
}

/**
 * Clear effects at turn start
 * Call this at the beginning of each turn for the current player
 * @param {string} pk - 'p1' or 'p2' (player whose turn is starting)
 */
function clearExpiredEffectsOnTurnStart(pk) {
  clearSpecialEffects(pk);
  
  // üÜï A2 MOVE EFFECT - Clear locked attacks for this player
  const allPokemon = [getActiveImg(pk), ...getBenchImgs(pk)].filter(Boolean);
  for (const img of allPokemon) {
    if (img.dataset.lockedAttack) {
      console.log(`[clear-effects] Clearing locked attack "${img.dataset.lockedAttack}" from ${img.alt}`);
      delete img.dataset.lockedAttack;
    }
  }
}

// Expose globally for debugging
globalThis.canRetreat = canRetreat;
globalThis.canAttack = canAttack;
globalThis.canUseSupporter = canUseSupporter;
globalThis.applySpecialEffectsToDamage = applySpecialEffectsToDamage;
globalThis.clearSpecialEffects = clearSpecialEffects;
globalThis.clearExpiredEffectsOnTurnStart = clearExpiredEffectsOnTurnStart;

console.log('[special-effects] Helper functions loaded');

const popupEl = document.getElementById("popup");


/* ========= trainer CSV ========= */
let TRAINER_EFFECT_DATA=[];
fetch('trainer_effects.csv')
  .then(r=>r.text())
  .then(t=>{
    TRAINER_EFFECT_DATA=parseCSV(t);
    console.log('[trainer] CSV loaded:',TRAINER_EFFECT_DATA.length,'rows');
  });

function parseCSV(text){
  const rows=[];let i=0,f='',row=[],q=false;
  const pf=()=>{row.push(f);f=''},pr=()=>{if(row.length)rows.push(row);row=[]};
  while(i<text.length){
    const c=text[i];
    if(q){
      if(c==='"'&&text[i+1]==='"'){f+='"';i+=2;continue}
      if(c==='"'){q=false;i++;continue}
      f+=c;i++;continue;
    }else{
      if(c==='"'){q=true;i++;continue}
      if(c===','){pf();i++;continue}
      if(c==='\r'){i++;continue}
      if(c==='\n'){pf();pr();i++;continue}
      f+=c;i++;continue;
    }
  }
  if(f.length||row.length){pf();pr()}
  const [h,...b]=rows;
  if(!h) return[];
  return b.map(r=>Object.fromEntries(h.map((k,ix)=>[k.trim(),(r[ix]??'').trim()])));
}
const csvIdFor=(set,num)=>`${set}-${String(num).padStart(3,'0')}`;

/* ========= constants ========= */
const ENERGY_ICONS={
  fire:'https://archives.bulbagarden.net/media/upload/thumb/a/ad/Fire-attack.png/20px-Fire-attack.png',
  water:'https://archives.bulbagarden.net/media/upload/thumb/1/11/Water-attack.png/20px-Water-attack.png',
  grass:'https://archives.bulbagarden.net/media/upload/thumb/2/2e/Grass-attack.png/20px-Grass-attack.png',
  lightning:'https://archives.bulbagarden.net/media/upload/thumb/0/04/Lightning-attack.png/20px-Lightning-attack.png',
  psychic:'https://archives.bulbagarden.net/media/upload/thumb/e/ef/Psychic-attack.png/20px-Psychic-attack.png',
  fighting:'https://archives.bulbagarden.net/media/upload/thumb/4/48/Fighting-attack.png/20px-Fighting-attack.png',
  darkness:'https://archives.bulbagarden.net/media/upload/thumb/a/ab/Darkness-attack.png/20px-Darkness-attack.png',
  metal:'https://archives.bulbagarden.net/media/upload/thumb/6/64/Metal-attack.png/20px-Metal-attack.png',
  dragon:'https://archives.bulbagarden.net/media/upload/thumb/c/c9/Dragon-attack.png/20px-Dragon-attack.png',
  colorless:'https://archives.bulbagarden.net/media/upload/thumb/1/1d/Colorless-attack.png/30px-Colorless-attack.png'
};

/* ========= ability helpers ========= */
function getAbilityCardKey(set, num, img) {
  // If img provided, use its unique instance ID
  if (img && img.dataset.instanceId) {
    return `instance-${img.dataset.instanceId}`;
  }
  
  // Fallback to card-based key (for backwards compatibility)
  const normalizedSet = String(set || '').toUpperCase();
  const normalizedNum = String(num || '').padStart(3, '0');
  return `${normalizedSet}-${normalizedNum}`;
}

function abilityRequiresActive(row) {
  const txt = (row.text || '').toLowerCase();
  return txt.includes('if this pok√©mon is in the active spot') ||
         txt.includes('as long as this pok√©mon is in the active spot');
}

const TYPE_HEX={
  fire:'#f08030',water:'#6890f0',grass:'#78c850',lightning:'#f8d030',
  psychic:'#f85888',fighting:'#c03028',darkness:'#705848',
  metal:'#b8b8d0',dragon:'#d3ba30',colorless:'#c6c6a7'
};
const ABILITY_BADGE='https://archives.bulbagarden.net/media/upload/thumb/0/06/TCGAbilityIcon.png/150px-TCGAbilityIcon.png';

/* ========= status icon URLs ========= */
const STATUS_ICON_URLS = {
  poisoned:  'https://img.game8.co/4032556/c9ba9a1b0a05840ece5f931c7c1321a4.png/show',
  confused:  'https://img.game8.co/4094717/5ab86a0b822d0e62b2c579b570086f83.png/show',
  paralyzed: 'https://img.game8.co/4032560/0410c7a29706b6533839572ddf3204a5.png/show',
  asleep:    'https://img.game8.co/4032559/fd51a89575d9ce25c0ee9bf451f3a6fe.png/show',
  burned:    'https://img.game8.co/4096103/c432edb7c5f7bb6a914ad5837bffce84.png/show'
};


/* ========= DOM ========= */
const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));

const popup=$('#popup'),
      energyZoneDiv=$('#energyZone'),
      coinEl=$('#coin'),
      coinResult=$('#coinResult'),
      mainButton=$('#mainButton'),
      turnNumEl=$('#turnNum'),
      turnPlayerEl=$('#turnPlayer');

const p1HandDiv=$('#p1Hand'),
      p2HandDiv=$('#p2Hand'),
      p1Active=$('#p1Active'),
      p2Active=$('#p2Active'),
      p1Bench=$('#p1Bench'),
      p2Bench=$('#p2Bench'),
      p1Bubble=$('#p1Bubble'),
      p2Bubble=$('#p2Bubble');

const zoomBackdrop=$('#zoomBackdrop'),
      zoomImg=$('#zoomImg'),
      zoomToolImg=$('#zoomToolImg'),
      zoomTitle=$('#zoomTitle'),
      zoomHp=$('#zoomHp'),
      zoomHpBar=$('#zoomHpBar'),
      zoomType=$('#zoomType'),
      zoomStatusIcon=$('#zoomStatusIcon'),
      zoomAttacks=$('#zoomAttacks'),
      zoomEnergyCount=$('#zoomEnergyCount'),
      zoomEnergyIcons=$('#zoomEnergyIcons'),
      zoomWeakness=$('#zoomWeakness'),
      zoomRetreat=$('#zoomRetreat'),
      zoomTools=$('#zoomTools'),
      zoomAbilities=$('#zoomAbilities');


const p1DiscardBtn=$('#p1DiscardBtn'),
      p2DiscardBtn=$('#p2DiscardBtn'),
      p1DiscardDrawer=$('#p1DiscardDrawer'),
      p2DiscardDrawer=$('#p2DiscardDrawer');

const victoryOverlay=$('#victoryOverlay'),
      victoryTitle=$('#victoryTitle'),
      victoryDesc=$('#victoryDesc'),
      p1PtsText=$('#p1Pts'),
      p2PtsText=$('#p2Pts'),
      playAgainBtn=$('#playAgainBtn'),
      chooseDecksBtn=$('#chooseDecksBtn');

const toolBackdrop=$('#toolBackdrop'),
      toolImg=$('#toolImg'),
      toolTitle=$('#toolTitle'),
      toolMeta=$('#toolMeta'),
      toolText=$('#toolText');

const handBackdrop=$('#handBackdrop'),
      handImg=$('#handImg'),
      handToolImg=$('#handToolImg'),
      handTitle=$('#handTitle'),
      handType=$('#handType'),
      handEffect=$('#handEffect');

/* log panel dom */
const logPanel=$('#logPanel'),
      logEntriesDiv=$('#logEntries'),
      logToggleBtn=$('#logToggleBtn'),
      historyBackdrop=$('#historyBackdrop'),
      fullHistoryDiv=$('#fullHistory');

/* ========= state ========= */
globalThis.turnNumber=1;
let currentPlayer=null,firstPlayer=null;

// Expose currentPlayer via getter
Object.defineProperty(globalThis, 'currentPlayer', {
  get: () => currentPlayer,
  set: (val) => { currentPlayer = val; }
});
let hasAttachedEnergyThisTurn=false,selectedEnergy=null,isSetupPhase=true;
let isEvoMode=false,evoMeta=null,evoOwner=null,evoHandCard=null;
let isPromotionPhase=false,openAttackMenu=null,gameOver=false,hasRetreatedThisTurn=false,isRetreatSelection=false,lastRetreatTime=0,abilityJustUsed=false;
const hasPlayedSupporterThisTurn={player1:false,player2:false};
let p1Points=0,p2Points=0,toolAttachPending=null,currentZoom={img:null,meta:null};
// Ensure global reference exists
globalThis.getPoints = function(player) {
  if (player === 'player1' || player === 'p1') return p1Points;
  if (player === 'player2' || player === 'p2') return p2Points;
  return 0;
};
if (!window.usedAbilitiesThisTurn) {
  window.usedAbilitiesThisTurn = {
    p1: {},
    p2: {}
  };
}
// Use the global reference
let usedAbilitiesThisTurn = window.usedAbilitiesThisTurn;

// Simple type ‚Üí color for ability header band
function typeColorHex(t) {
  const key = (t || '').toLowerCase();
  switch (key) {
    case 'fire':      return '#f97316';
    case 'water':     return '#38bdf8';
    case 'grass':     return '#22c55e';
    case 'lightning': return '#facc15';
    case 'psychic':   return '#a855f7';
    case 'fighting':  return '#f97316';
    case 'metal':
    case 'steel':     return '#9ca3af';
    case 'darkness':  return '#4b5563';
    case 'dragon':    return '#22d3ee';
    case 'colorless': return '#e5e7eb';
    default:          return '#64748b';
  }
}

const playerState={
  player1:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player1Energy')||'[]'),discard:{cards:[],energyCounts:{}} },
  player2:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player2Energy')||'[]'),discard:{cards:[],energyCounts:{}} }
};

function expandDeck(raw){
  const out=[];
  (raw||[]).forEach(c=>{
    if(!c||!c.name||!c.set||(c.number??c.num)==null)return;
    const n=Number(c.quantity)||1;
    for(let i=0;i<n;i++)out.push({...c,quantity:1});
  });
  return out;
}
playerState.player1.deck=expandDeck(JSON.parse(localStorage.getItem('player1Deck')||'[]'));
playerState.player2.deck=expandDeck(JSON.parse(localStorage.getItem('player2Deck')||'[]'));

/* ========= logging ========= */

let fullHistoryLog=[];
let logCounter=1;

function highImgUrl(set,num){
  if(!set || num==null) return null;
  return `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3,'0')}/high.png`;
}

function logEvent({ player, text, cardSet = null, cardNum = null }) {
  const id = logCounter++;
  const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  const who =
    player === 'player1' ? 'Player 1' :
    player === 'player2' ? 'Player 2' : 'System';

  const cls =
    player === 'player1' ? 'p1' :
    player === 'player2' ? 'p2' : 'sys';

  // build image URL if we have set/num
  const imgUrl = (cardSet && cardNum) ? highImgUrl(cardSet, cardNum) : null;

  // create the log entry element
  const div = document.createElement('div');
  div.className = `log-entry ${cls}`;
  div.dataset.id = id;

  div.innerHTML = `
    <div class="entry-player ${cls}">${who}</div>
    <div class="entry-text">${text}</div>
    ${imgUrl ? `<img class="log-thumb" src="${imgUrl}" alt="card">` : '' }
  `;

  logEntriesDiv.appendChild(div);
  logEntriesDiv.scrollTop = logEntriesDiv.scrollHeight;

  // store for match history modal
  fullHistoryLog.push({ id, ts, player: who, text, cardSet, cardNum, imgUrl });
}

/* === CLICK CARD IN LOG ‚Üí OPEN FULLSCREEN MODAL (FULLY POPULATED FIELDS) === */
logEntriesDiv.addEventListener("click", async (e) => {
  const thumb = e.target.closest(".log-thumb");
  if (!thumb) return;

  // Extract set + num from image URL
  const match = thumb.src.match(/tcgp\/([^\/]+)\/(\d{3})/i);
  if (!match) return;

  const set = match[1];
  const num = match[2];

  let meta;
  try {
    meta = await fetchCardMeta(set, num);
  } catch (err) {
    console.error("Failed to fetch meta", err);
    showPopup("Unable to load card details.");
    return;
  }

  const category = (meta.category || "").toLowerCase();

  // === Create a FAKE BOARD IMAGE so buildZoomPanel() can populate all fields ===
  const fakeImg = document.createElement("img");
  fakeImg.dataset.set = set;
  fakeImg.dataset.num = num;
  fakeImg.dataset.hp = meta.hp || "0";
  fakeImg.dataset.chp = meta.hp || "0";
  fakeImg.src = thumb.src;
  fakeImg.alt = meta.name;

  // Wrap in a temporary fake card-slot with no energies or tools
  const fakeSlot = document.createElement("div");
  fakeSlot.className = "card-slot";
  fakeSlot.appendChild(fakeImg);

  // Add empty energy & tool containers so zoom panel displays correctly
  const fakePips = document.createElement("div");
  fakePips.className = "energy-pips";
  fakeSlot.appendChild(fakePips);

  const fakeHP = document.createElement("div");
  fakeHP.className = "hp-overlay";
  fakeHP.textContent = `${meta.hp} / ${meta.hp}`;
  fakeSlot.appendChild(fakeHP);

  // === Pok√©mon handling ===
  if (category === "pokemon") {
    zoomImg.src = thumb.src;
    zoomBackdrop.classList.add("show");

    // Create a hidden container so fake card-slot exists in the DOM
    const tempWrap = document.createElement("div");
    tempWrap.style.display = "none";
    tempWrap.appendChild(fakeSlot);
    document.body.appendChild(tempWrap);

    await buildZoomPanel(meta, fakeImg);

    // Clean up after zoom closes
    zoomBackdrop.addEventListener("transitionend", () => {
      if (!zoomBackdrop.classList.contains("show")) {
        tempWrap.remove();
      }
    }, { once: true });

    return;

  }

  // === Trainer handling ===
  handImg.src = thumb.src;
  handBackdrop.classList.add("show");
  handTitle.textContent = meta.name || "Trainer Card";
  handType.textContent = meta.trainerType || "Trainer";
  handType.style.background = trainerColor(meta.trainerType || "trainer");
  handEffect.textContent = meta.effect || meta.description || "No effect listed.";
});



if(logToggleBtn){
  logToggleBtn.onclick = () => {
    logPanel.classList.toggle('show');
  };
}
/* === log panel close logic === */
const closeLogBtn = document.getElementById("closeLogBtn");

if (closeLogBtn) {
  closeLogBtn.onclick = () => {
    logPanel.classList.remove("show");
  };
}

// Escape closes log
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    logPanel.classList.remove("show");
  }
});

if(historyBackdrop){
  historyBackdrop.addEventListener('click',e=>{
    if(e.target===historyBackdrop) historyBackdrop.classList.remove('show');
  });
}

/* ========= utils ========= */
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
let popupTimer = null;

let popupTimeout = null;

function showPopup(msg, duration = 1800) {
  if (!popupEl) return;

  if (popupTimeout) {
    clearTimeout(popupTimeout);
    popupTimeout = null;
  }

  popupEl.textContent = msg;
  popupEl.classList.add("show");

  popupTimeout = setTimeout(() => {
    popupEl.classList.remove("show");
    popupTimeout = null;
  }, duration);
}

globalThis.showPopup = showPopup;


function updateDeckBubbles(){if(p1Bubble)p1Bubble.textContent=playerState.player1.deck.length;if(p2Bubble)p2Bubble.textContent=playerState.player2.deck.length}
function updatePointsUI(){
  const f=(id,pts)=>{$$(`#${id} .point-bubble`).forEach(b=>b.classList.toggle('filled',Number(b.dataset.i)<=pts))};
  f('p1Points',p1Points);f('p2Points',p2Points);
}
function updateTurnBox(){
  if(turnNumEl)turnNumEl.textContent=globalThis.turnNumber;
  if(turnPlayerEl)turnPlayerEl.textContent=`Current: ${currentPlayer?currentPlayer.replace('player','Player '):'‚Äî'}`;
}
const activeFor=p=>p==='player1'?p1Active:p2Active;
const benchFor=p=>p==='player1'?p1Bench:p2Bench;
const handDivFor=p=>p==='player1'?p1HandDiv:p2HandDiv;
const opponentOf=p=>p==='player1'?'player2':'player1';

// also add in the state section:
let damageBoostThisTurn = {
  player1: { flatAll: 0, flatByName: {} },
  player2: { flatAll: 0, flatByName: {} }
};
globalThis.damageBoostThisTurn = damageBoostThisTurn;
globalThis.resetDamageBoostsFor = function (playerKey) {
  const slot = damageBoostThisTurn[playerKey];
  if (!slot) return;
  slot.flatAll = 0;
  slot.flatByName = {};
};

function markSlot(slot,has){
  const lab=slot.querySelector('.slot-label');
  slot.dataset.empty=has?'0':'1';
  if(lab)lab.style.display=has?'none':'block';
}
globalThis.markSlot = markSlot;

const metaCache={};
async function fetchCardMeta(set,num){
  const key=`${set}-${num}`;
  if(metaCache[key])return metaCache[key];
  const r=await fetch(`https://api.tcgdex.net/v2/en/sets/${set}/${num}`);
  if(!r.ok)throw new Error('meta');
  const d=await r.json();
  metaCache[key]=d;
  return d;
}
async function isBasicPokemon(set,num){
  try{
    const d=await fetchCardMeta(set,num);
    return String(d.category||'').toLowerCase()==='pokemon' &&
           String(d.stage||'').toLowerCase()==='basic';
  }catch{return false}
}

function setHpOnImage(img,baseHp,chp){
  img.dataset.hp=String(baseHp);
  img.dataset.chp=String(chp);
  const slot=img.closest('.card-slot');
  if(!slot)return;
  
  // Check for Giant Cape or other max HP modifiers
  const modifiedMaxHp = slot.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  const displayMax = modifiedMaxHp || baseHp;
  
  let hpDiv=slot.querySelector('.hp-overlay');
  if(!hpDiv){
    hpDiv=document.createElement('div');
    hpDiv.className='hp-overlay';
    slot.appendChild(hpDiv);
  }
  hpDiv.textContent=`${chp} / ${displayMax}`;
  
  // Make HP green if Giant Cape is attached
  if (modifiedMaxHp) {
    hpDiv.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
    hpDiv.style.fontWeight = '900';
  } else {
    hpDiv.style.background = 'rgba(0,0,0,.85)';
    hpDiv.style.fontWeight = '800';
  }
}

/* ========= hand render ========= */
function renderHand(div,cards,hide=false){
  const owner=div.id==='p1Hand'?'player1':'player2';
  
  // Check if Pokemon Communication is active
  const selData = globalThis.__pokemonCommSelection;
  const isCommActive = globalThis.__pokemonCommActive && selData;
  
  div.innerHTML=(cards||[]).map(c=>{
    const src=hide?'imgs/cardback.png':(c.image||'https://archives.bulbagarden.net/media/upload/1/17/Cardback.jpg');
    
    // Add glow class if this card is eligible for Pokemon Communication
    let extraClass = '';
    if (isCommActive && selData.pokemonInHand.includes(c)) {
      extraClass = ' poke-comm-glow';
    }
    
    return `<div class="card-slot" data-empty="0"><img class="card-img${extraClass}" src="${src}" alt="${c.name}" data-owner="${owner}" data-set="${c.set}" data-num="${c.number||c.num}"></div>`;
  }).join('');
}
function removeFromHand(owner,set,num){
  const h=playerState[owner].hand;
  const i=h.findIndex(c=>c.set===set&&String(c.number||c.num)===String(num));
  if(i>=0)h.splice(i,1);
}
function renderAllHands(){
  const p1Hide=currentPlayer==='player2',
        p2Hide=currentPlayer==='player1';
  renderHand(p1HandDiv,playerState.player1.hand,p1Hide);
  renderHand(p2HandDiv,playerState.player2.hand,p2Hide);
  p1HandDiv.classList.toggle('disable-clicks',currentPlayer==='player2');
  p2HandDiv.classList.toggle('disable-clicks',currentPlayer==='player1');
}

/* ========= tools ========= */
function getToolDataFromSlot(slot){
  const set=slot.dataset.toolSet||null,
        num=slot.dataset.toolNum||null,
        src=slot.dataset.toolSrc||null;
  return set&&num&&src?{set,num,src}:null;
}
function setToolDataOnSlot(slot,tool){
  if(tool){
    slot.dataset.toolSet=tool.set;
    slot.dataset.toolNum=tool.num;
    slot.dataset.toolSrc=tool.src;
  }else{
    delete slot.dataset.toolSet;
    delete slot.dataset.toolNum;
    delete slot.dataset.toolSrc;
  }
}
function ensureToolThumb(slot){
  let th=slot.querySelector('.tool-thumb');
  if(!th){
    th=document.createElement('img');
    th.className='tool-thumb';
    th.title='Tool';
    slot.appendChild(th);
  }
  return th;
}
function removeToolThumb(slot){
  const th=slot.querySelector('.tool-thumb');
  if(th)th.remove();
}
async function attachToolToSlot(owner,slot,toolObj){
  if(!slot||!toolObj)return;
  const img=slot.querySelector('img');
  if(!img){showPopup('Attach to a Pok√©mon in play.');return}
  if(getToolDataFromSlot(slot)){showPopup('This Pok√©mon already has a Tool attached.');return}
  try{
    const metaP=await fetchCardMeta(img.dataset.set,img.dataset.num);
    if(String(metaP.category||'').toLowerCase()!=='pokemon'){
      showPopup('Attach only to Pok√©mon.');
      return;
    }
  }catch{
    showPopup('Error verifying Pok√©mon.');
    return;
  }
  setToolDataOnSlot(slot,toolObj);
  const th=ensureToolThumb(slot);
  th.src=toolObj.src;
  th.onerror = () => {
    console.error('[tool] Failed to load tool image:', toolObj.src);
    th.src = 'imgs/cardback.png'; // Fallback
  };
  th.onload = () => {
    console.log('[tool] Tool thumbnail loaded successfully:', toolObj.src);
  };
  th.onclick=async ev=>{
    ev.stopPropagation();
    await openToolModal(toolObj.set,toolObj.num,toolObj.src);
  };
  console.log('[tool] Tool attached visually:', toolObj);
  showPopup('Tool attached');
}

/* ========= A2 Helper Functions ========= */

// Set max HP for Giant Cape tool
globalThis.setMaxHp = function(img, newMax) {
  if (!img) return;
  const slot = img.closest('.card-slot');
  if (!slot) return;
  
  // Get OLD values
  const oldMaxHp = parseInt(img.dataset.hp, 10) || 0;
  const oldCurrentHp = parseInt(img.dataset.chp || img.dataset.hp, 10) || oldMaxHp;
  
  // Calculate the HP increase
  const hpIncrease = newMax - oldMaxHp;
  
  // ALWAYS increase current HP by the same amount as max HP increase
  const newCurrentHp = oldCurrentHp + hpIncrease;
  
  // Store new max HP
  slot.dataset.maxHp = String(newMax);
  
  // Update current HP in dataset
  img.dataset.chp = String(newCurrentHp);
  
  // Update the HP overlay (bottom green box) - NO badge!
  let hpDiv = slot.querySelector('.hp-overlay');
  if (!hpDiv) {
    hpDiv = document.createElement('div');
    hpDiv.className = 'hp-overlay';
    slot.appendChild(hpDiv);
  }
  
  // Update HP overlay with new current/max HP
  hpDiv.textContent = `${newCurrentHp} / ${newMax}`;
  
  // Make it green to show tool is active
  hpDiv.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
  hpDiv.style.fontWeight = '900';
  
  console.log(`[setMaxHp] ${img.alt} HP: ${oldCurrentHp}/${oldMaxHp} ‚Üí ${newCurrentHp}/${newMax} (+${hpIncrease})`);
};

// Force switch specific bench Pokemon (for Cyrus)
globalThis.forceSwitchSpecific = function(state, pk, benchImg) {
  if (!benchImg) return;
  
  const owner = pkToPlayer(pk);
  console.log(`[forceSwitchSpecific] Switching ${benchImg.alt} to active for ${owner}`);
  
  // Get the active slot directly - the .active div contains one .card-slot
  const activeDiv = owner === 'player1' ? document.getElementById('p1Active') : document.getElementById('p2Active');
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const benchSlot = benchImg.closest('.card-slot');
  
  console.log('[forceSwitchSpecific] Slots found:', { activeSlot, benchSlot, activeDiv });
  
  if (!activeSlot || !benchSlot) {
    console.error('[forceSwitchSpecific] Could not find slots', { activeSlot, benchSlot });
    return;
  }
  
  // Get the active Pokemon image
  const activeImg = activeSlot.querySelector('img');
  if (!activeImg) {
    console.error('[forceSwitchSpecific] No active Pokemon to swap');
    return;
  }
  
  console.log('[forceSwitchSpecific] Found slots, swapping...');
  
  // Swap maxHp data (for Giant Cape / Leaf Cape)
  const activeMaxHp = activeSlot.dataset.maxHp;
  const benchMaxHp = benchSlot.dataset.maxHp;
  
  // Clear both first
  delete activeSlot.dataset.maxHp;
  delete benchSlot.dataset.maxHp;
  
  // Swap if they existed
  if (benchMaxHp) {
    activeSlot.dataset.maxHp = benchMaxHp;
  }
  if (activeMaxHp) {
    benchSlot.dataset.maxHp = activeMaxHp;
  }
  
  // Swap the innerHTML of the slots
  const activeHTML = activeSlot.innerHTML;
  const benchHTML = benchSlot.innerHTML;
  
  activeSlot.innerHTML = benchHTML;
  benchSlot.innerHTML = activeHTML;
  
  console.log(`[forceSwitchSpecific] Successfully swapped ${benchImg.alt} to active`);
  
  // Update HP displays to reflect correct maxHp state
  const newActiveImg = activeSlot.querySelector('img');
  const newBenchImg = benchSlot.querySelector('img');
  
  if (newActiveImg) {
    const baseHp = parseInt(newActiveImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newActiveImg.dataset.chp || newActiveImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newActiveImg, baseHp, curHp);
  }
  
  if (newBenchImg) {
    const baseHp = parseInt(newBenchImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newBenchImg.dataset.chp || newBenchImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newBenchImg, baseHp, curHp);
  }
  
  // Update visual displays
  if (typeof updateAllEnergyVisuals === 'function') {
    updateAllEnergyVisuals();
  }
};

/* ========= hand modal ========= */
if(handBackdrop){
  handBackdrop.addEventListener('click',e=>{
    if(e.target===handBackdrop){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape'){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
}
function trainerColor(type){
  const t=String(type||'').toLowerCase();
  if(t.includes('supporter'))return'#e45803';
  if(t.includes('item'))return'#0167b6';
  if(t.includes('tool'))return'#6e4e9c';
  return'#3b3f46';
}

/* ========= energy + costs ========= */
function countPipsOn(slot){
  const out={total:0};
  // Only count real energy pips, not phantom pips
  slot.querySelectorAll('.energy-pip:not(.phantom-pip)').forEach(p=>{
    const t=(p.dataset.type||'colorless').toLowerCase();
    out[t]=(out[t]||0)+1;
    out.total++;
  });
  return out;
}
function satisfiedFlags(pips, costArr, pokemonImg = null) {
  const cnt = {...pips};
  const keys = Object.keys(cnt).filter(k => k !== 'total');
  const f = [];
  
  // üÜï A3 - Check for increased attack costs (Oranguru's Primate's Trap)
  let costIncrease = 0;
  if (pokemonImg) {
    let pk = null;
    if (pokemonImg.closest('#player1')) pk = 'p1';
    else if (pokemonImg.closest('#player2')) pk = 'p2';
    
    if (pk && globalThis.__specialEffects?.[pk]?.attackCostIncrease) {
      costIncrease = globalThis.__specialEffects[pk].attackCostIncrease;
      console.log(`[attack-cost-increase] +${costIncrease} to attack costs`);
    }
    
    // üÜï A3a - Stoutland Guard Dog Visage (opponent attacks cost +1)
    // Check if opponent's active has increase_opponent_cost
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppActiveImg = oppActive?.querySelector('img');
    
    if (oppActiveImg) {
      try {
        const cacheKey = `${oppActiveImg.dataset.set}-${oppActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'increase_opponent_cost') {
          const increase = parseInt(abilityRow.param1 || '1', 10);
          costIncrease += increase;
          console.log(`[Guard Dog Visage] Opponent attacks cost +${increase}`);
        }
      } catch (err) {
        console.error('[canAfford] Guard Dog Visage check failed:', err);
      }
    }
  }
  
  // üÜï A2a PASSIVE ABILITY - reduce_attack_cost_if_arceus (Abomasnow)
  // Check if Pokemon has reduce_attack_cost_if_arceus and Arceus is in play
  let colorlessReduction = 0;
  if (pokemonImg && pokemonImg.dataset.set && pokemonImg.dataset.num) {
    try {
      const cacheKey = `${pokemonImg.dataset.set}-${pokemonImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_attack_cost_if_arceus') {
        // Determine which player owns this Pokemon
        let pk = null;
        if (pokemonImg.closest('#player1')) pk = 'p1';
        else if (pokemonImg.closest('#player2')) pk = 'p2';
        
        if (pk && typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          colorlessReduction = parseInt(abilityRow.param1 || '1', 10);
          console.log(`[Arceus cost reduction] -${colorlessReduction} colorless cost`);
        }
      }
    } catch (e) {
      // Ability check failed, no reduction
    }
  }
  
  // üÜï A2a TRAINER - Barry (reduce cost for specific Pokemon)
  if (pokemonImg) {
    const pokemonName = (pokemonImg.alt || '').toLowerCase();
    const barryCostReduction = globalThis.attackCostReduction?.[pokemonName] || 0;
    if (barryCostReduction > 0) {
      colorlessReduction += barryCostReduction;
      console.log(`[Barry] -${barryCostReduction} colorless cost for ${pokemonImg.alt}`);
    }
  }
  
  // Build modified cost array with cost increase
  const modifiedCostArr = [...(costArr || [])];
  for (let i = 0; i < costIncrease; i++) {
    modifiedCostArr.push('colorless');
  }
  
  modifiedCostArr.forEach(t => {
    const k = String(t || '').toLowerCase();
    if (k === 'colorless') {
      // Try to use reduction first
      if (colorlessReduction > 0) {
        colorlessReduction--;
        f.push(true);
        return;
      }
      
      // Otherwise, pay normally
      let ok = false;
      for (const tp of keys) {
        if ((cnt[tp] || 0) > 0) {
          cnt[tp]--;
          cnt.total--;
          ok = true;
          break;
        }
      }
      f.push(ok);
    } else {
      if ((cnt[k] || 0) > 0) {
        cnt[k]--;
        cnt.total--;
        f.push(true);
      } else {
        f.push(false);
      }
    }
  });
  return f;
}

function canPayCostFromAPI(slot, costArr, pokemonImg = null) {
  return satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg).every(Boolean);
}
const energyIconUrl=k=>ENERGY_ICONS[k==='electric'?'lightning':k]||ENERGY_ICONS.colorless;
function extractAbilities(meta) {
  if (!meta) return [];
  // Standard case: array of abilities
  if (Array.isArray(meta.abilities)) return meta.abilities;
  // Some cards might expose a single ability object
  if (meta.abilities && typeof meta.abilities === 'object') return [meta.abilities];
  // Fallback if the API ever uses a single "ability" field
  if (meta.ability) return [meta.ability];
  return [];
}

function makeCostIcons(costArr, slot, pokemonImg = null) {
  const wrap = document.createElement('div');
  wrap.className = 'attack-cost';
  const flags = satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg);
  (costArr || []).forEach((t, i) => {
    const ic = document.createElement('div');
    ic.className = 'cost-icon';
    ic.style.backgroundImage = `url('${energyIconUrl(String(t || '').toLowerCase())}')`;
    if (!flags[i]) ic.classList.add('missing');
    wrap.appendChild(ic);
  });
  return wrap;
}

/* ========= damage / KO ========= */
const parseDamage=v=>{const m=String(v??'').match(/\d+/);return m?parseInt(m[0],10):0};
const getActiveImage=p=>activeFor(p).querySelector('img')||null;

function pushCardToDiscard(owner,img){
  playerState[owner].discard.cards.push({set:img.dataset.set,num:img.dataset.num,src:img.src});
}
function moveCardToDiscard(owner,img){
  const slot=img.closest('.card-slot');
  const tool=getToolDataFromSlot(slot);
  if(tool){
    playerState[owner].discard.cards.push({set:tool.set,num:tool.num,src:tool.src});
    removeToolThumb(slot);
    setToolDataOnSlot(slot,null);
  }
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  pushCardToDiscard(owner,img);
  const pips=countPipsOn(slot);
  Object.keys(pips).forEach(k=>{
    if(k==='total')return;
    playerState[owner].discard.energyCounts[k]=(playerState[owner].discard.energyCounts[k]||0)+pips[k];
  });
  slot.innerHTML='';
  slot.classList.remove('damage-flash');
  const lab=document.createElement('span');
  lab.className='slot-label';
  lab.textContent='Empty';
  slot.appendChild(lab);
  markSlot(slot,false);
  if(drawer.classList.contains('show'))renderDiscard(owner);
}
async function pointsForCard(set,num){
  try{
    const meta=await fetchCardMeta(set,num);
    const s=(meta.suffix||'').toUpperCase();
    const name=(meta.name||'').toLowerCase();
    if(s==='EX'&&name.includes('mega'))return 3;
    if(s==='EX')return 2;
  }catch{}
  return 1;
}
const checkBenchOut=owner=>[...benchFor(owner).querySelectorAll('img')].length===0;

function showVictory(winnerKey,reason){
  if(gameOver)return;
  gameOver=true;
  $('.main-layout')?.classList.add('disable-clicks');
  $('.side-panel')?.classList.add('disable-clicks');
  victoryTitle.textContent=winnerKey==='player1'?'Player 1 Wins!':'Player 2 Wins!';
  victoryDesc.textContent=reason||'Game over';
  p1PtsText.textContent=String(p1Points);
  p2PtsText.textContent=String(p2Points);
  victoryOverlay.style.display='flex';
}

async function handleKnockOut(owner, img, wasActive = false){
  const set=img.dataset.set,
        num=img.dataset.num;
  const foe=owner==='player1'?'player2':'player1';
  
  // Check if this was the active Pokemon
  const activeImg = getActiveImage(owner);
  const isActive = wasActive || (activeImg === img);
  
  console.log('[KO] Handling knockout:', {
    owner,
    pokemon: img.alt,
    isActive,
    wasActive
  });
  
  // üÜï A3 PASSIVE ABILITIES - Knockout triggers (BEFORE removing Pokemon)
  if (typeof getAbilityRow === 'function') {
    try {
      const pk = owner === 'player1' ? 'p1' : 'p2';
      const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
      
      if (abilityRow && typeof applyAbilityEffectFromCsv === 'function') {
        // counter_on_knockout - Pyukumuku (damage attacker)
        if (abilityRow.effect_type === 'counter_on_knockout' && isActive) {
          await applyAbilityEffectFromCsv(abilityRow, pk, { 
            attacker: foe,
            knockedPokemon: img 
          });
        }
        
        // move_energy_on_knockout - Passimian ex (move energy to bench)
        if (abilityRow.effect_type === 'move_energy_on_knockout' && isActive) {
          await applyAbilityEffectFromCsv(abilityRow, pk, { 
            knockedPokemon: img 
          });
        }
      }
    } catch (err) {
      console.warn('[KO Abilities] Failed to trigger:', err);
    }
  }
  
  // üÜï A3a TOOL - Electrical Cord (BEFORE removing Pokemon)
  if (isActive) {
    const slot = img.closest('.card-slot');
    const tool = getToolDataFromSlot(slot);
    
    if (tool && tool.num === '065' && tool.set === 'A3a') {
      console.log('[Electrical Cord] Checking if triggered...');
      
      // Check if Pokemon is Lightning type
      try {
        const meta = await fetchCardMeta(img.dataset.set, img.dataset.num);
        const isLightningType = meta.types?.some(t => t.toLowerCase() === 'lightning');
        
        if (isLightningType) {
          // Count Lightning energy attached
          const energyBox = slot?.querySelector('.energy-pips');
          const pips = energyBox?.querySelectorAll('.energy-pip');
          const lightningPips = Array.from(pips || []).filter(p => p.dataset.type === 'lightning');
          
          console.log(`[Electrical Cord] Lightning type with ${lightningPips.length} Lightning Energy`);
          
          if (lightningPips.length >= 2) {
            // Get benched Pokemon
            const pk = owner === 'player1' ? 'p1' : 'p2';
            const bench = [...benchFor(owner).querySelectorAll('img')];
            
            if (bench.length >= 2) {
              showPopup('Electrical Cord: Select 2 Benched Pok√©mon to receive Lightning Energy');
              
              // Select first bench Pokemon
              const first = await new Promise(resolve => {
                bench.forEach(b => b.classList.add('selectable'));
                const handler = (e) => {
                  const clicked = e.target.closest('img');
                  if (clicked && bench.includes(clicked)) {
                    bench.forEach(b => {
                      b.classList.remove('selectable');
                      b.removeEventListener('click', handler);
                    });
                    resolve(clicked);
                  }
                };
                bench.forEach(b => b.addEventListener('click', handler));
              });
              
              if (first) {
                // Select second bench Pokemon
                const remaining = bench.filter(b => b !== first);
                const second = await new Promise(resolve => {
                  remaining.forEach(b => b.classList.add('selectable'));
                  const handler = (e) => {
                    const clicked = e.target.closest('img');
                    if (clicked && remaining.includes(clicked)) {
                      remaining.forEach(b => {
                        b.classList.remove('selectable');
                        b.removeEventListener('click', handler);
                      });
                      resolve(clicked);
                    }
                  };
                  remaining.forEach(b => b.addEventListener('click', handler));
                });
                
                if (second) {
                  // Attach 1 Lightning to each
                  attachEnergy(first, 'lightning');
                  attachEnergy(second, 'lightning');
                  showPopup(`Electrical Cord: Distributed Lightning Energy to ${first.alt} and ${second.alt}!`);
                  console.log('[Electrical Cord] Distributed energy to 2 benched Pokemon');
                }
              }
            } else if (bench.length === 1) {
              // Only 1 bench Pokemon - give both energy to it
              attachEnergy(bench[0], 'lightning');
              attachEnergy(bench[0], 'lightning');
              showPopup(`Electrical Cord: Attached 2 Lightning Energy to ${bench[0].alt}!`);
              console.log('[Electrical Cord] Distributed 2 energy to single benched Pokemon');
            } else {
              console.log('[Electrical Cord] No benched Pokemon to distribute to');
            }
          }
        }
      } catch (err) {
        console.warn('[Electrical Cord] Failed to check:', err);
      }
    }
  }
  
  // üÜï Set flag for Marshadow's Revenge attack
  // Track that this player had a Pokemon KO'd this turn
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  const ownerPk = owner === 'player1' ? 'p1' : 'p2';
  globalThis.state.koLastTurn[ownerPk] = true;
  console.log(`[marshadow] Set KO flag for ${ownerPk} (owner: ${owner})`);
  
  // üÜï Check if Serperior was knocked out (Jungle Totem)
  const pokemonName = (img.alt || '').toLowerCase();
  if (pokemonName.includes('serperior')) {
    console.log('[KO] Serperior knocked out - updating energy visuals');
    // Remove phantom pips since Jungle Totem is gone
    setTimeout(() => {
      if (typeof globalThis.updateAllEnergyVisuals === 'function') {
        globalThis.updateAllEnergyVisuals();
      }
    }, 100); // Small delay to ensure DOM is updated
  }
  
  logEvent({
    player: foe,
    text:`Knocked out ${img.alt || 'a Pok√©mon'}.`,
    cardSet:set,cardNum:num
  });

  moveCardToDiscard(owner,img);
  const pts=await pointsForCard(set,num);
  if(foe==='player1')p1Points+=pts;else p2Points+=pts;
  updatePointsUI();
  if(p1Points>=3||p2Points>=3){
    showVictory(p1Points>=3?'player1':'player2','Reached 3 points');
    return true;
  }
  
  // Only check bench out if the ACTIVE Pokemon was knocked out
  if(isActive && checkBenchOut(owner)){
    console.log('[KO] Bench out - active Pokemon was KO\'d and no bench remaining');
    showVictory(foe,'Bench out');
    return true;
  }
  
  return false;
}

async function damageActiveOf(player, amount, options = {}) {
  const img = getActiveImage(player);
  if (!img) return { knocked: false, hpText: '' };
  
  const pk = player === 'player1' ? 'p1' : 'p2';
  
  // üÜï Check if this is from a direct attack (for Rocky Helmet)
  // Rocky Helmet should only trigger if the active Pokemon was attacked directly
  const isDirectAttack = options.isDirectAttack !== false; // Default true for backward compatibility
  const attackerImg = options.attackerImg; // For Safeguard ability

  amount = applySpecialEffectsToDamage(pk, amount);

  
  // Check for passive damage reduction
  const reduction = getPassiveDamageReduction(pk);
  if (reduction > 0) {
    amount = Math.max(0, amount - reduction);
    showPopup(`Ability reduced damage by ${reduction}!`);
  }
  
  // Check for Giant Cape or other max HP modifiers
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10) || 0;
  let chp = parseInt(img.dataset.chp || base || '0', 10) || base;
  
  // üÜï Check for Safeguard ability (Oricorio) - blocks all damage from ex Pokemon
  if (isDirectAttack && attackerImg && shouldBlockDamageFromEx(pk, attackerImg)) {
    // Show shield animation
    const shield = document.createElement('div');
    shield.className = 'safeguard-shield';
    shield.innerHTML = 'üõ°Ô∏è';
    shield.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 60px;
      z-index: 9999;
      animation: safeguardPulse 0.8s ease-out;
      pointer-events: none;
    `;
    slot.appendChild(shield);
    
    // Add CSS animation if not already present
    if (!document.getElementById('safeguard-animation-style')) {
      const style = document.createElement('style');
      style.id = 'safeguard-animation-style';
      style.textContent = `
        @keyframes safeguardPulse {
          0% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.3);
            filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.8));
          }
          50% {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
            filter: drop-shadow(0 0 20px rgba(59, 130, 246, 1));
          }
          100% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(1.5);
            filter: drop-shadow(0 0 30px rgba(59, 130, 246, 0.4));
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Remove shield after animation
    setTimeout(() => shield.remove(), 800);
    
    showPopup(`Safeguard: ${img.alt} takes no damage from ${attackerImg.alt}!`);
    return { knocked: false, hpText: `${chp} / ${base}` };
  }
  
  chp = Math.max(0, chp - amount);
  setHpOnImage(img, base, chp);
  
  slot.classList.add('damage-flash');
  setTimeout(() => slot.classList.remove('damage-flash'), 400);

  if (currentZoom.img && currentZoom.img === img) {
    const pct = base > 0 ? Math.round((chp / base) * 100) : 0;
    zoomHp.textContent = `HP: ${chp} / ${base}`;
    zoomHpBar.style.width = pct + "%";
    zoomHpBar.style.background = (chp === base)
      ? 'linear-gradient(90deg,#22c55e,#16a34a)'
      : 'linear-gradient(90deg,#f43f5e,#ef4444)';
  }

  // Check for counterattack ability
  // üÜï Only trigger counterattack if this was a direct attack
  if (amount > 0 && isDirectAttack) {
    const counterDmg = getCounterattackDamage(pk);
    if (counterDmg > 0) {
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counterattack: Dealt ${counterDmg} damage back!`);
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDmg, { isDirectAttack: false });
        // Check if counterattack KO'd the attacker
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          console.log('[counterattack] Attacker knocked out by counterattack!');
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              beginPromotionFlow(attacker);
            }
          }
        }
      }, 600);
    }
    
    // üÜï A3 - Check for counter_next_turn effect (Sandslash's Spike Armor)
    if (img.dataset.counterDamageNextTurn) {
      const counterDamage = parseInt(img.dataset.counterDamageNextTurn, 10);
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counter activated: Dealt ${counterDamage} damage back!`);
      delete img.dataset.counterDamageNextTurn; // Clear after use
      
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDamage, { isDirectAttack: false });
        // Check if counter KO'd the attacker
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          console.log('[counter-next-turn] Attacker knocked out by counter!');
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              beginPromotionFlow(attacker);
            }
          }
        }
      }, 800);
    }
    
    // üÜï Check for Rocky Helmet tool - Only trigger on direct attacks
    const tool = getToolDataFromSlot(slot);
    if (tool && tool.set && tool.num) {
      const cardId = `${tool.set}-${tool.num}`;
      
      // Rocky Helmet - A2-148
      if (cardId === 'A2-148') {
        const helmetDamage = 20;
        const attacker = player === 'player1' ? 'player2' : 'player1';
        showPopup(`Rocky Helmet: Dealt ${helmetDamage} damage back!`);
        setTimeout(async () => {
          const helmetResult = await damageActiveOf(attacker, helmetDamage, { isDirectAttack: false });
          // üÜï Check if Rocky Helmet KO'd the attacker
          if (helmetResult.knocked && typeof handleKnockOut === 'function') {
            console.log('[rocky-helmet] Attacker knocked out by Rocky Helmet!');
            const attackerImg = getActiveImage(attacker);
            if (attackerImg) {
              const gameEnded = await handleKnockOut(attacker, attackerImg, true);
              if (!gameEnded && typeof beginPromotionFlow === 'function') {
                beginPromotionFlow(attacker);
              }
            }
          }
        }, 800);
      }
      
      // üÜï Poison Barb - A3-146
      if (cardId === 'A3-146') {
        const attacker = player === 'player1' ? 'player2' : 'player1';
        const attackerPk = attacker === 'player1' ? 'p1' : 'p2';
        if (typeof setStatus === 'function') {
          setStatus(attackerPk, 'poisoned');
          showPopup(`Poison Barb: Poisoned the attacker!`);
          console.log('[poison-barb] Inflicted poison on attacker');
        }
      }
    }
  }

  if (chp <= 0) {
    // üÜï A3 PASSIVE ABILITY - Guts (flip to avoid knockout)
    if (typeof getAbilityRow === 'function' && typeof applyAbilityEffectFromCsv === 'function') {
      try {
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'flip_avoid_knockout') {
          const pk = player === 'player1' ? 'p1' : 'player2';
          const result = await applyAbilityEffectFromCsv(abilityRow, pk, { targetImg: img });
          
          if (result?.avoided) {
            // Survived! Don't process knockout
            console.log('[Guts] Pokemon survived knockout');
            return { knocked: false, owner: player };
          }
        }
      } catch (err) {
        console.warn('[Guts] Failed to check ability:', err);
      }
    }
    
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    return { knocked: true, owner };
  }
  
  return { knocked: false };
}
function animateCardToHand(pk, cardObj) {
  // Create ghost thumbnail
  const img = document.createElement('img');
  img.src = cardObj.image;
  img.style.position = 'fixed';
  img.style.width = '48px';
  img.style.height = '67px';
  img.style.pointerEvents = 'none';
  img.style.zIndex = 99999;
  img.style.borderRadius = '6px';
  img.style.left = '50%';
  img.style.top = '50%';
  img.style.transform = 'translate(-50%, -50%) scale(2)';
  img.style.opacity = '1';
  img.style.transition = 'all .4s ease-out';

  document.body.appendChild(img);

  // Destination: player's hand bar
  const handElm = pk === 'p1' ? document.getElementById('p1Hand') : document.getElementById('p2Hand');
  const rect = handElm.getBoundingClientRect();

  setTimeout(() => {
    img.style.left = rect.left + 40 + 'px';
    img.style.top = rect.top + 10 + 'px';
    img.style.transform = 'translate(0,0) scale(.6)';
    img.style.opacity = '0';
  }, 20);

  setTimeout(() => img.remove(), 420);
}

/* ========= discard UI ========= */
function renderDiscard(owner){
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  const {cards,energyCounts}=playerState[owner].discard;
  drawer.innerHTML=`
    <h3 style="margin:10px 0 6px;">
      ${owner==='player1'?'Player 1':'Player 2'} Discard (${cards.length+Object.values(energyCounts).reduce((a,b)=>a+b,0)})
    </h3>
    <button style="margin-bottom:10px" onclick="document.getElementById('${owner==='player1'?'p1DiscardDrawer':'p2DiscardDrawer'}').classList.remove('show')">Close</button>
  `;
  const energiesRow=document.createElement('div');
  energiesRow.style.display='flex';
  energiesRow.style.flexDirection='column';
  Object.keys(energyCounts).forEach(k=>{
    const row=document.createElement('div');
    row.className='discard-item';
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
    ico.style.width='26px';ico.style.height='26px';
    const cnt=document.createElement('span');
    cnt.className='discard-count';
    cnt.textContent=`x${energyCounts[k]}`;
    row.appendChild(ico);row.appendChild(cnt);
    energiesRow.appendChild(row);
  });
  drawer.appendChild(energiesRow);
  cards.forEach(c=>{
    const row=document.createElement('div');
    row.className='discard-item';
    const im=document.createElement('img');
    im.src=c.src;
    row.appendChild(im);
    drawer.appendChild(row);
  });
}

/* ========= attack menu + retreat ========= */
// Handle attack click - executes the attack (using same logic as buildZoomPanel)
async function handleAttackClick(attack, meta, ownerKey, activeDiv) {
  console.log('[attack] Executing attack:', attack.name, 'from', meta.name);
  
  // activeDiv is passed in as parameter
  if (!activeDiv) {
    console.error('[attack] No active Pokemon found');
    return;
  }
  
  const pk = ownerKey === 'p1' || ownerKey === 'p2' ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[attack] No card slot found');
    return;
  }

  // üÜï A2 FIX - Store effect context for special effects like Rampardos
  let effectContext = null;

  // Don't deduct energy - energy stays on Pokemon during attacks
  const cost = attack.cost || [];
  console.log('[attack] Attack cost:', cost, '(energy not discarded)');
  
  // Check if blocked by status
  if (typeof isActiveBlockedFromAttacking === 'function' && isActiveBlockedFromAttacking(pk)) {
    const imgBlocked = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
    const st = (imgBlocked?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup('This Pok√©mon is asleep and can\'t attack.');
    } else if (st === 'paralyzed') {
      showPopup('This Pok√©mon is paralyzed and can\'t attack.');
    }
    return;
  }
  
  // üÜï A2a MOVE EFFECT - Attack lock self check
  const attackerImg = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
  if (globalThis.__specialEffects?.[pk]?.attackLockSelf) {
    showPopup('This Pok√©mon can\'t attack this turn!');
    delete globalThis.__specialEffects[pk].attackLockSelf;
    return;
  }
  
  // üÜï A2a MOVE EFFECT - Attack lock with flip check
  if (globalThis.__specialEffects?.[pk]?.attackLockFlip) {
    showPopup('Must flip to attack...');
    
    const flip = Math.random() < 0.5;
    console.log(`[attack-lock-flip] Flipped: ${flip ? 'Heads' : 'Tails'}`);
    
    if (flip) {
      // Heads - attack succeeds
      showPopup('Heads! Attack proceeds.');
      delete globalThis.__specialEffects[pk].attackLockFlip;
    } else {
      // Tails - attack fails
      showPopup('Tails! Attack failed!');
      delete globalThis.__specialEffects[pk].attackLockFlip;
      closeAttackMenu();
      return;
    }
  }
  
  // üÜï A2 STATUS - Confusion check (flip on attack, damage self if tails)
  if (attackerImg && attackerImg.dataset.status?.toLowerCase() === 'confusion') {
    console.log('[confusion] Confused Pokemon attacking - flipping coin...');
    
    const flip = Math.random() < 0.5;
    console.log(`[confusion] Flipped: ${flip ? 'Heads' : 'Tails'}`);
    
    if (flip) {
      // Heads - attack succeeds, clear confusion
      showPopup('Confusion: Heads! Attack succeeds.');
      delete attackerImg.dataset.status;
      console.log('[confusion] Cleared confusion (heads)');
    } else {
      // Tails - attack fails, damage self 20
      showPopup('Confusion: Tails! This Pok√©mon hurt itself in confusion!');
      
      const player = pk === 'p1' ? 'player1' : 'player2';
      if (typeof damageActiveOf === 'function') {
        setTimeout(async () => {
          await damageActiveOf(player, 20, { isDirectAttack: false });
        }, 500);
      }
      
      // Clear confusion after hurting self
      delete attackerImg.dataset.status;
      console.log('[confusion] Cleared confusion (tails, hurt self)');
      
      // Close menu and don't continue attack
      closeAttackMenu();
      return;
    }
  }
  
  // Get opponent (pk format: p1/p2)
  const foePk = pk === 'p1' ? 'p2' : 'p1';
  const foe = foePk === 'p1' ? 'player1' : 'player2';  // Convert to player1/player2 for startTurn
  console.log('[attack] Attacker:', pk, '‚Üí Opponent:', foePk, '(', foe, ')');
  
  // Parse base damage
  let damage = 0;
  if (attack.damage) {
    const dmgStr = String(attack.damage);
    const match = dmgStr.match(/\d+/);
    if (match) damage = parseInt(match[0]);
  }
  
  // Apply move effect from CSV
  const effectState = {
    p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
    p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
    activeFor: typeof activeFor === 'function' ? activeFor : () => null,
    benchFor: typeof benchFor === 'function' ? benchFor : () => null,
    opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
    fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
    damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
    beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
    showPopup: showPopup,
    logEvent: typeof logEvent === 'function' ? logEvent : () => {}
  };
  
  try {
    if (typeof applyMoveEffectFromCsv === 'function') {
      const result = await applyMoveEffectFromCsv(effectState, pk, attack.name, damage);
      
      // üÜï A2 FIX - Handle returned object for special effects
      if (typeof result === 'object' && result.damage !== undefined) {
        damage = result.damage;
        effectContext = result.context;
      } else {
        damage = result;
      }
      
      // Giovanni global damage boost
      const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
      if (boost) {
        console.log('[attack] Giovanni boost applied +', boost);
        damage += boost;
      }
      
      // üÜï A3 - Next turn damage bonus (Crabominable ex)
      const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
      if (nextTurnBonus > 0) {
        console.log('[attack] Next turn bonus applied +', nextTurnBonus);
        damage += nextTurnBonus;
        // Clear after use
        if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
          globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
        }
      }
      
      // üÜï A2a MOVE EFFECT - Next turn attack bonuses (Donphan, Cyclizar)
      if (attackerImg) {
        const bonusKey = `${attackerImg.dataset.instanceId || attackerImg.alt}_${attack.name}`;
        const nextTurnBonus = globalThis.__attackBonuses?.[bonusKey] || 0;
        
        if (nextTurnBonus > 0) {
          damage += nextTurnBonus;
          console.log(`[next-turn-bonus] +${nextTurnBonus} damage for ${attack.name}`);
          showPopup(`+${nextTurnBonus} bonus damage!`);
          
          // Clear the bonus after use
          delete globalThis.__attackBonuses[bonusKey];
        }
      }
      
      // üÜï A3a TOOL - Beastite (damage scales with points scored)
      if (attackerImg) {
        const attackerSlot = attackerImg.closest('.card-slot');
        const tool = getToolDataFromSlot(attackerSlot);
        
        if (tool && tool.num === '066' && tool.set === 'A3a') {
          // Check if attacker is Ultra Beast
          const ULTRA_BEASTS = [
            'nihilego', 'buzzwole', 'pheromosa', 'xurkitree', 'celesteela',
            'kartana', 'guzzlord', 'poipole', 'naganadel', 'stakataka', 'blacephalon'
          ];
          
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isUltraBeast = ULTRA_BEASTS.some(ub => attackerName.includes(ub));
          
          if (isUltraBeast) {
            // Get attacker's points
            const attackerPlayer = attackerImg.closest('#player1') ? 'player1' : 'player2';
            const points = attackerPlayer === 'player1' ? p1Points : p2Points;
            
            const beastiteBonus = points * 10;
            if (beastiteBonus > 0) {
              damage += beastiteBonus;
              showPopup(`Beastite: +${beastiteBonus} damage! (${points} points √ó 10)`);
              console.log(`[Beastite] Added ${beastiteBonus} damage based on ${points} points`);
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[attack] Move effect error:', err);
  }
  
  // Apply weakness
  try {
    if (typeof getActiveImage === 'function') {
      const foeImg = getActiveImage(foe);
      if (foeImg && typeof fetchCardMeta === 'function') {
        const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const wk = metaFoe?.weaknesses?.[0];
        
        if (wk) {
          const wkType = (wk.type || '').toLowerCase();
          if (wkType !== 'colorless') {
            const atkType = (meta.types?.[0] || '').toLowerCase();
            if (atkType === wkType) {
              console.log('[attack] Weakness: +20 damage');
              damage += 20;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[attack] Weakness check failed:', err);
  }
  
  // üÜï A2 PASSIVE ABILITIES - Fighting Coach (boost attacker damage)
  try {
    const attackerType = (meta.types?.[0] || '').toLowerCase();
    if (attackerType) {
      const fightingCoachBoost = getFightingCoachBoost(pk, attackerType);
      if (fightingCoachBoost > 0) {
        damage += fightingCoachBoost;
        console.log(`[Fighting Coach] Boosted damage by +${fightingCoachBoost}`);
      }
    }
  } catch (err) {
    console.error('[attack] Fighting Coach check failed:', err);
  }
  
  // üÜï A2b TRAINER - Red (boost damage vs ex)
  try {
    const exBonus = globalThis.state?.temp?.[pk]?.damageVsEx || 0;
    if (exBonus > 0) {
      // Check if opponent is ex
      const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
      if (foeImg && typeof fetchCardMeta === 'function') {
        const foeMeta = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const isEx = foeMeta.suffix?.toUpperCase() === 'EX';
        
        if (isEx) {
          damage += exBonus;
          console.log(`[Red] +${exBonus} damage vs Pok√©mon ex`);
        }
      }
    }
  } catch (err) {
    console.error('[attack] Red ex bonus check failed:', err);
  }
  
  // üÜï A2 PASSIVE ABILITIES - Thick Fat (reduce damage from Fire/Water)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg) {
      const attackerType = (meta.types?.[0] || '').toLowerCase();
      const thickFatReduction = getThickFatReduction(foeImg, attackerType);
      if (thickFatReduction > 0) {
        damage = Math.max(0, damage - thickFatReduction);
        showPopup(`Thick Fat: Reduced ${thickFatReduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] Thick Fat check failed:', err);
  }
  
  // üÜï A2 PASSIVE ABILITIES - Guarded Grill (flip to reduce damage)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      damage = applyGuardedGrill(foeImg, damage);
    }
  } catch (err) {
    console.error('[attack] Guarded Grill check failed:', err);
  }
  
  // üÜï A2a PASSIVE ABILITY - reduce_damage_if_arceus (Raichu, Magnezone)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const foePk = foe === 'player1' ? 'p1' : 'p2';
      
      // Check if defender has reduce_damage_if_arceus ability
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_damage_if_arceus' && hasArceusInPlay(foePk)) {
        const reduction = parseInt(abilityRow.param1 || '30', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
        console.log(`[${abilityRow.abilityName}] Arceus in play, reduced damage by ${reduction}`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_damage_if_arceus check failed:', err);
  }
  
  // üÜï A3a PASSIVE ABILITY - Luxray Intimidating Fang (reduce opponent damage)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      // Check if defender has reduce_opponent_damage ability
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_opponent_damage') {
        const reduction = parseInt(abilityRow.param1 || '20', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
        console.log(`[${abilityRow.abilityName}] Reduced damage by ${reduction}`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_opponent_damage check failed:', err);
  }
  
  // Apply damage
  let knocked = false;
  if (typeof damageActiveOf === 'function') {
    const result = await damageActiveOf(foe, damage, { attackerImg: attackerImg });
    knocked = result.knocked;
    showPopup(`${meta.name} used ${attack.name}${damage > 0 ? ` for ${damage} damage!` : '!'}`);
  } else {
    showPopup(`${meta.name} used ${attack.name}!`);
  }
  
  // Close menu
  closeAttackMenu();
  
  // Handle KO
  if (knocked && typeof handleKnockOut === 'function' && typeof getActiveImage === 'function') {
    const foeImg = getActiveImage(foe);
    if (foeImg) {
      const ended = await handleKnockOut(foe, foeImg);
      if (ended) return;
      if (typeof beginPromotionFlow === 'function') {
        beginPromotionFlow(foe);
      }
    }
  }
  
  // üÜï A2 FIX - Rampardos Head Smash: Self-damage only if KO
  if (knocked && effectContext?.checkKoForRecoil) {
    const recoilDamage = effectContext.checkKoForRecoil;
    const attacker = pk === 'p1' ? 'player1' : 'player2'; // Convert pk to player format
    console.log(`[Rampardos] Opponent KO'd, applying ${recoilDamage} recoil damage to ${attacker}`);
    setTimeout(async () => {
      if (typeof damageActiveOf === 'function') {
        await damageActiveOf(attacker, recoilDamage, { isDirectAttack: false });
        showPopup(`Rampardos took ${recoilDamage} recoil damage!`);
      }
    }, 800);
  }
  
  // üÜï A3b TOOL - Leftovers (heal at end of turn)
  // This happens at the END of the current player's turn, BEFORE switching to opponent
  if (attackerImg) {
    const currentPlayerForLeftovers = attackerImg.closest('#player1') ? 'player1' : 'player2';
    const currentActiveImg = getActiveImage(currentPlayerForLeftovers);
    
    if (currentActiveImg) {
      const slot = currentActiveImg.closest('.card-slot');
      const tool = getToolDataFromSlot(slot);
      
      if (tool && tool.num === '067' && tool.set === 'A3b') {
        const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(currentActiveImg.dataset.hp, 10);
        const curHp = parseInt(currentActiveImg.dataset.chp, 10);
        
        if (curHp < maxHp) {
          const healAmount = 10;
          const newHp = Math.min(maxHp, curHp + healAmount);
          currentActiveImg.dataset.chp = String(newHp);
          
          // Update HP display
          if (typeof setHpOnImage === 'function') {
            setHpOnImage(currentActiveImg, maxHp, newHp);
          }
          
          showPopup(`Leftovers: Healed 10 damage from ${currentActiveImg.alt}!`);
          console.log('[Leftovers] Healed 10 damage at end of turn');
        }
      }
    }
  }
  
  // Start opponent's turn
  if (typeof startTurn === 'function') {
    setTimeout(() => startTurn(foe), 300);
  }
  
  console.log('[attack] Attack complete');
}

// Handle retreat click (using game's promotion system)
function handleRetreat(activeDiv, meta, retreatCost) {
  console.log('[RETREAT] === STARTING RETREAT ===');
  console.log('[retreat] Attempting to retreat:', meta.name, 'cost:', retreatCost);
  console.log('[RETREAT] activeDiv:', activeDiv);
  console.log('[RETREAT] Current flag states:', {
    isRetreatSelection,
    isPromotionPhase,
    isEvoMode,
    hasRetreatedThisTurn
  });
  
  // Check if already retreated this turn
  if (hasRetreatedThisTurn) {
    console.log('[RETREAT] BLOCKED - Already retreated this turn');
    showPopup('You can only retreat once per turn!');
    return;
  }
  
  // Check if activeDiv is valid
  if (!activeDiv) {
    console.error('[RETREAT] ERROR - activeDiv is null!');
    showPopup('Cannot retreat - invalid active area');
    return;
  }
  
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[retreat] No card slot found');
    return;
  }
  
  // Check if we have enough energy (only if retreat costs something)
  if (retreatCost > 0) {
    const energyPipsContainer = slot.querySelector('.energy-pips');
    if (!energyPipsContainer) {
      console.error('[retreat] No energy pips found');
      return;
    }
    
    const pips = energyPipsContainer.querySelectorAll('.energy-pip');
    if (pips.length < retreatCost) {
      showPopup(`Not enough energy to retreat! Need ${retreatCost}, have ${pips.length}`);
      return;
    }
  } else {
    console.log('[retreat] Free retreat (cost 0), skipping energy check');
  }
  
  // Determine which player owns this Pokemon
  let ownerKey = null;
  if (activeDiv.closest('#player1')) ownerKey = 'player1';
  else if (activeDiv.closest('#player2')) ownerKey = 'player2';
  
  if (!ownerKey) {
    console.error('[retreat] Could not determine owner');
    return;
  }
  
  // Check if bench has Pokemon using game's benchFor function
  let hasBench = false;
  if (typeof benchFor === 'function') {
    const benchDiv = benchFor(ownerKey);
    if (benchDiv) {
      const benchSlots = benchDiv.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
      console.log('[retreat] Bench check: found', occupied.length, 'Pokemon');
    }
  } else {
    // Fallback: check bench manually
    const pk = ownerKey === 'player1' ? 'p1' : 'p2';
    const bench = document.querySelector(`#${pk}-bench`);
    if (bench) {
      const benchSlots = bench.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
      console.log('[retreat] Bench check (fallback): found', occupied.length, 'Pokemon');
    }
  }
  
  if (!hasBench) {
    showPopup('No bench Pokemon to retreat to!');
    return;
  }
  
  // Store retreat cost for later (will be paid only after successful swap)
  const storedRetreatCost = retreatCost;
  
  // Close the menu first
  console.log('[RETREAT] Closing menu before retreat');
  closeAttackMenu();
  console.log('[RETREAT] Menu closed, flag states:', {
    isRetreatSelection,
    isPromotionPhase,
    isEvoMode
  });
  
  // Set retreat selection mode (blocks menu during selection)
  isRetreatSelection = true;
  console.log('[RETREAT] Set isRetreatSelection = true, menu now blocked');
  
  // Custom retreat promotion
  showPopup(`${meta.name} retreated! Choose new active Pokemon (or click anywhere to cancel).`);
  
  // Get bench div for highlighting
  const benchDiv = typeof benchFor === 'function' ? benchFor(ownerKey) : 
    document.querySelector(`#${ownerKey === 'player1' ? 'p1' : 'p2'}-bench`);
  
  if (!benchDiv) {
    console.error('[retreat] Could not find bench div');
    return;
  }
  
  // Highlight bench Pokemon
  const benchImgs = benchDiv.querySelectorAll('img');
  benchImgs.forEach(img => {
    if (img.dataset.set && img.dataset.num) {
      img.classList.add('promote-glow');
    }
  });
  
  // One-time click handler for selection or cancellation
  const selectReplacement = (e) => {
    console.log('[SELECT-REPLACEMENT] Fired! Target:', e.target, 'isRetreatSelection:', isRetreatSelection);
    
    // CRITICAL: Only respond if we're still in retreat mode
    // If flag was already reset, remove listener and ignore
    if (!isRetreatSelection) {
      document.body.removeEventListener('click', selectReplacement, true);
      console.log('[RETREAT] Guard check: isRetreatSelection is false, removing listener and exiting');
      return;
    }
    
    console.log('[SELECT-REPLACEMENT] Guard check passed, processing click');
    
    // Check if clicked a bench Pokemon
    const chosenImg = e.target.closest(`#${ownerKey} .bench img`);
    
    if (chosenImg && chosenImg.dataset.set && chosenImg.dataset.num) {
      // Valid bench Pokemon clicked
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      document.body.removeEventListener('click', selectReplacement, true);
      
      // Reset retreat mode IMMEDIATELY so guard check works
      isRetreatSelection = false;
      console.log('[RETREAT] Reset isRetreatSelection immediately after removing listener');
      console.log('[RETREAT] Swapping Pokemon');
      
      // Remove glow from all
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      
      // Perform the swap using game's helper if available
      if (typeof activeFor === 'function') {
        const activeDiv = activeFor(ownerKey);
        const activeSlot = activeDiv.querySelector('.card-slot');
        const benchSlot = chosenImg.closest('.card-slot');
        const activeImg = activeSlot.querySelector('img');
        
        // Get attachments
        const activePack = typeof detachAttachments === 'function' ? 
          detachAttachments(activeSlot) : { energy: [], tool: null };
        const benchPack = typeof detachAttachments === 'function' ? 
          detachAttachments(benchSlot) : { energy: [], tool: null };
        
        // Swap images
        if (activeImg) {
          // Clear status from active Pokemon
          if (typeof clearStatusOnImg === 'function') {
            clearStatusOnImg(activeImg);
          }
          activeSlot.removeChild(activeImg);
          benchSlot.removeChild(chosenImg);
          activeSlot.appendChild(chosenImg);
          benchSlot.appendChild(activeImg);
        } else {
          // Active is empty, just move bench to active
          benchSlot.removeChild(chosenImg);
          activeSlot.appendChild(chosenImg);
        }
        
        // Reattach attachments
        if (typeof attachAttachments === 'function') {
          attachAttachments(activeSlot, benchPack);
          if (activeImg) {
            attachAttachments(benchSlot, activePack);
          }
        }
        
        // Mark slots
        if (typeof markSlot === 'function') {
          markSlot(activeSlot, true);
          markSlot(benchSlot, !!benchSlot.querySelector('img'));
        }
        
        // Update player background
        if (typeof updatePlayerTypeBackground === 'function') {
          const playerNum = activeDiv.id.includes('p1') ? 1 : 2;
          updatePlayerTypeBackground(playerNum);
        }
        
        // NOW remove retreat cost energy (only on successful retreat)
        if (storedRetreatCost > 0) {
          // Find the Pokemon that retreated (now on bench)
          const retreatedSlot = benchSlot; // The active Pokemon is now in benchSlot
          const energyPipsContainer = retreatedSlot.querySelector('.energy-pips');
          
          if (energyPipsContainer) {
            const pips = energyPipsContainer.querySelectorAll('.energy-pip:not(.phantom-pip)');
            console.log('[retreat] Removing', storedRetreatCost, 'energy from retreated Pokemon');
            
            // Add energy to discard pile
            for (let i = 0; i < storedRetreatCost && i < pips.length; i++) {
              const energyType = pips[i].dataset.type || 'colorless';
              playerState[ownerKey].discard.energyCounts[energyType] = 
                (playerState[ownerKey].discard.energyCounts[energyType] || 0) + 1;
              pips[i].remove();
              console.log('[retreat] Discarded', energyType, 'energy');
            }
            
            // Also remove phantom pips for discarded energy
            const phantomPips = energyPipsContainer.querySelectorAll('.energy-pip.phantom-pip');
            for (let i = 0; i < storedRetreatCost && i < phantomPips.length; i++) {
              phantomPips[i].remove();
            }
          }
        } else {
          console.log('[retreat] Free retreat (cost 0)');
        }
        
        showPopup('Promoted to Active.');

        // IMMEDIATELY clean up any menu state and dispatch click
        console.log('[RETREAT] Starting immediate cleanup');
        
        // 1. Force close any existing menus
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
          console.log('[RETREAT] Called closeAttackMenu');
        }
        
        // 2. Remove menu-open class from all slots
        document.querySelectorAll('.card-slot.menu-open').forEach(slot => {
          slot.classList.remove('menu-open');
        });
        
        // 3. Remove any attack menu elements
        document.querySelectorAll('.attack-menu').forEach(menu => {
          menu.remove();
        });
        
        // 4. Dispatch click on background to trigger handlers
        const background = document.querySelector('.board') || document.body;
        const clickEvent = new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: 10,
          clientY: 10
        });
        background.dispatchEvent(clickEvent);
        console.log('[RETREAT] Immediate cleanup complete - closed menus and dispatched click');

        
        // isRetreatSelection already reset immediately after listener removal
        lastRetreatTime = Date.now();  // Record when retreat completed
        
        // Mark that we've retreated this turn (prevent multiple retreats)
        hasRetreatedThisTurn = true;
        console.log('[RETREAT] Set hasRetreatedThisTurn = true');
        console.log('[RETREAT] SUCCESS - Swap complete, ready for menu');
      }
    } else {
      // Clicked somewhere else - cancel
      document.body.removeEventListener('click', selectReplacement, true);
      
      // Reset retreat mode
      isRetreatSelection = false;
      console.log('[RETREAT] CANCEL - Reset isRetreatSelection = false, menu now unblocked');
      console.log('[RETREAT] SUCCESS - Reset isRetreatSelection = false, menu now unblocked');
      
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      showPopup('Retreat canceled (no replacement selected).');
    }
  };
  
  // Add click listener with slight delay to prevent immediate trigger
  setTimeout(() => {
    document.body.addEventListener('click', selectReplacement, true);
    console.log('[RETREAT] selectReplacement listener ADDED to document.body');
  }, 100);
  
  console.log('[retreat] Retreat complete, awaiting replacement selection');
}

// Handle ability click (using same logic as buildZoomPanel)
async function applyAbilityEffect(abilityRow, ownerKey, sourceImg = null) {
  console.log('[ability] Activating ability:', abilityRow);
  console.log('[ability] ownerKey received:', ownerKey);
  console.log('[ability] sourceImg:', sourceImg?.alt || 'none');
  
  if (typeof applyAbilityEffectFromCsv === 'function') {
    // ownerKey is now p1/p2 (not player1/player2)
    // Handle both formats for compatibility
    let pk;
    if (ownerKey === 'p1' || ownerKey === 'p2') {
      pk = ownerKey;  // Already correct
    } else {
      pk = ownerKey === 'player1' ? 'p1' : 'p2';  // Fallback conversion
    }
    console.log('[ability] Converted to pk:', pk);
    
    // Shared state object for effects.js (same as buildZoomPanel)
    const effectState = {
      p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
      p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
      activeFor: typeof activeFor === 'function' ? activeFor : () => null,
      benchFor: typeof benchFor === 'function' ? benchFor : () => null,
      opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
      fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
      damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
      beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
      showPopup: showPopup,
      logEvent: typeof logEvent === 'function' ? logEvent : () => {},
      attachEnergyToSlot: typeof attachEnergyToSlot === 'function' ? attachEnergyToSlot : () => {},
      energyZoneDiv: typeof energyZoneDiv !== 'undefined' ? energyZoneDiv : null,
      renderEnergyZone: typeof renderEnergyZone === 'function' ? renderEnergyZone : () => {},
      getActiveImage: typeof getActiveImage === 'function' ? getActiveImage : () => null
    };
    
    try {
      const result = await applyAbilityEffectFromCsv(effectState, pk, abilityRow, { sourceImg });
      showPopup(`Used ability: ${abilityRow.abilityName || 'Unknown'}`);
      
      // Close zoom modal if open (same as buildZoomPanel does)
      if (typeof zoomBackdrop !== 'undefined' && zoomBackdrop.classList.contains('show')) {
        zoomBackdrop.classList.remove('show');
        if (typeof currentZoom !== 'undefined') {
          currentZoom = { img: null, meta: null };
        }
      }
      
      // Check if ability caused a KO (e.g., Greninja's Water Shuriken)
      if (result && result.knocked) {
        console.log('[ability] KO detected, result:', result);
        const foe = pk === 'p1' ? 'player2' : 'player1';
        
        // Use the knockedImg from result if available (for abilities that target any Pokemon)
        // Otherwise fall back to active Pokemon
        const foeImg = result.knockedImg || getActiveImage(foe);
        
        if (foeImg && typeof handleKnockOut === 'function') {
          console.log('[ability] Handling KO for:', foeImg.alt);
          
          // Check if knocked Pokemon was active
          const foeActive = getActiveImage(foe);
          const wasActive = (foeImg === foeActive);
          
          const ended = await handleKnockOut(foe, foeImg, wasActive);
          if (!ended && typeof beginPromotionFlow === 'function') {
            // Only promote if active was KO'd
            if (wasActive) {
              beginPromotionFlow(foe);
            }
          }
        }
      }
    } catch (err) {
      console.error('[ability] Ability effect error:', err);
      showPopup('Ability failed.');
    }
  } else {
    console.warn('[ability] applyAbilityEffectFromCsv not found');
    showPopup(`Used ability: ${abilityRow.abilityName || 'Unknown'}`);
  }
}

function closeAttackMenu(){
  if(openAttackMenu){
    // Remove menu-open mark from card slot
    const menuOpenSlots = document.querySelectorAll('.card-slot.menu-open');
    menuOpenSlots.forEach(slot => slot.classList.remove('menu-open'));
    // Remove escape key handler
    if(openAttackMenu._escapeHandler){
      document.removeEventListener('keydown', openAttackMenu._escapeHandler);
    }
    // Remove click outside handler
    if(openAttackMenu._clickOutsideHandler){
      document.removeEventListener('click', openAttackMenu._clickOutsideHandler);
      console.log('[MENU] Removed closeOnClickOutside listener');
    }
    // Remove backdrop if it exists
    if(openAttackMenu._backdrop){
      openAttackMenu._backdrop.remove();
    }
    // Remove menu
    if(openAttackMenu.parentElement){
      openAttackMenu.parentElement.removeChild(openAttackMenu);
    }
  }
  openAttackMenu=null;
}

function computeRetreatCost(activeDiv, meta) {
  const base = Number(meta.retreat || meta.retreatCost || 0) || 0;

  // If this card is not actually in an .active div (e.g. opened from log),
  // just return the base retreat cost and skip temp modifiers.
  if (!activeDiv) return base;
  
  // üÜï A2 PASSIVE ABILITY - Levitate (zero retreat if has energy)
  const activeImg = activeDiv.querySelector('img');
  if (activeImg && typeof hasLevitateZeroRetreat === 'function' && hasLevitateZeroRetreat(activeImg)) {
    return 0;
  }
  
  // üÜï A2a PASSIVE ABILITY - zero_retreat_if_arceus (Heatran, Rotom)
  // Check if active Pokemon has zero_retreat_if_arceus ability and Arceus is in play
  if (activeImg && activeImg.dataset.set && activeImg.dataset.num) {
    try {
      // Synchronous check via globalThis.abilityCache
      const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      console.log(`[retreat-debug] Checking ${activeImg.alt} (${cacheKey})`);
      console.log(`[retreat-debug] Ability row:`, abilityRow);
      console.log(`[retreat-debug] Cache size:`, Object.keys(globalThis.abilityCache || {}).length);
      
      if (abilityRow?.effect_type === 'zero_retreat_if_arceus') {
        // Determine which player owns this Pokemon
        const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';
        
        console.log(`[retreat-debug] ${activeImg.alt} has zero_retreat_if_arceus ability`);
        console.log(`[retreat-debug] Checking for Arceus for player ${pk}`);
        
        // Check for Arceus in play
        if (typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          console.log('[Arceus retreat] Zero retreat cost (Arceus in play)');
          return 0;
        } else {
          console.log('[retreat-debug] No Arceus found in play');
        }
      }
    } catch (e) {
      console.error('[retreat-debug] Error checking Arceus retreat:', e);
      // Ability check failed, continue with normal cost
    }
  }
  
  // üÜï A2a PASSIVE ABILITY - reduce_active_basic_retreat_cost (Shaymin)
  // Check if player has Shaymin on bench and active is Basic
  if (activeImg && meta.stage?.toLowerCase() === 'basic') {
    // Determine which player owns this Pokemon
    const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';
    const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
    const benchImgs = benchDiv ? [...benchDiv.querySelectorAll('img')] : [];
    
    console.log(`[shaymin-debug] Active Pokemon is Basic (${activeImg.alt}), checking for Shaymin on bench`);
    console.log(`[shaymin-debug] Bench has ${benchImgs.length} Pokemon`);
    
    // Check if any benched Pokemon is Shaymin with reduce_active_basic_retreat_cost ability
    for (const benchImg of benchImgs) {
      const name = (benchImg.alt || '').toLowerCase();
      console.log(`[shaymin-debug] Checking bench Pokemon: ${benchImg.alt}`);
      
      if (name.includes('shaymin')) {
        // Check if this Shaymin has the ability
        try {
          const cacheKey = `${benchImg.dataset.set}-${benchImg.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          console.log(`[shaymin-debug] Found Shaymin (${cacheKey}), ability:`, abilityRow);
          
          if (abilityRow?.effect_type === 'reduce_active_basic_retreat_cost') {
            const reduction = parseInt(abilityRow.param1 || '1', 10);
            console.log(`[Shaymin Sky Support] -${reduction} retreat cost for active Basic`);
            return Math.max(0, base - reduction);
          }
        } catch (e) {
          console.error(`[shaymin-debug] Error checking Shaymin:`, e);
          // Continue checking other Shaymin
        }
      }
    }
  }

  const abs = activeDiv.dataset.tempRetreat;
  const red = Number(activeDiv.dataset.tempRetreatReduce || '0') || 0;

  if (abs != null) return Math.max(0, Number(abs));
  return Math.max(0, base - red);
}

// Set temporary retreat cost reduction (Leaf, X Speed)
globalThis.setTempRetreatFor = function(pk, amount, mode = 'reduce') {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) {
    console.warn('[retreat] No active div for', pk);
    return;
  }
  
  if (mode === 'reduce') {
    activeDiv.dataset.tempRetreatReduce = String(amount || 0);
    console.log(`[retreat] Set tempRetreatReduce=${amount} for ${pk}`);
  } else if (mode === 'set') {
    activeDiv.dataset.tempRetreat = String(amount || 0);
    console.log(`[retreat] Set tempRetreat=${amount} for ${pk}`);
  }
};

// Clear temporary retreat cost for a player
globalThis.clearTempRetreatFor = function(pk) {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) return;
  
  delete activeDiv.dataset.tempRetreat;
  delete activeDiv.dataset.tempRetreatReduce;
  console.log(`[retreat] Cleared temp retreat for ${pk}`);
};

function addRetreatRow(menu, activeDiv, meta){
  const slot = activeDiv.querySelector('.card-slot');
  const costCount = computeRetreatCost(activeDiv, meta);
  const row = document.createElement('div');
  row.style.marginTop = '6px';
  row.innerHTML = '<div class="thin"></div>';

  const btn = document.createElement('div');
  btn.className = 'attack-item';

  const left = document.createElement('div');
  left.style.display = 'flex';
  left.style.alignItems = 'center';
  left.style.gap = '6px';
  const nm = document.createElement('div');
  nm.className = 'attack-name';
  nm.textContent = 'Retreat';
  left.appendChild(nm);

  const icons = document.createElement('div');
  icons.className = 'attack-cost';
  if (costCount > 0) {
    const flags = satisfiedFlags(countPipsOn(slot), Array(costCount).fill('colorless'));
    for (let i = 0; i < costCount; i++) {
      const ic = document.createElement('div');
      ic.className = 'cost-icon';
      ic.style.backgroundImage = `url('${ENERGY_ICONS.colorless}')`;
      if (!flags[i]) ic.classList.add('missing');
      icons.appendChild(ic);
    }
  }
  left.appendChild(icons);

  const arrow = document.createElement('div');
  arrow.style.fontWeight = '900';
  arrow.textContent = '‚ü≤';
  btn.appendChild(left);
  btn.appendChild(arrow);

    const canPay = costCount === 0 || canPayCostFromAPI(slot, Array(costCount).fill('colorless'));
  const hasBench = [...benchFor(currentPlayer).querySelectorAll('img')].length > 0;

  const activeImg = activeDiv.querySelector('img');
  const st = (activeImg?.dataset.status || '').toLowerCase();
  const blockedByStatus = st === 'asleep' || st === 'paralyzed';

  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';

// CHECK RETREAT LOCK
if (!canRetreat(pk)) {
  btn.classList.add('muted');
  btn.onclick = () => {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup("Can't retreat - this Pok√©mon is asleep!");
    } else if (st === 'paralyzed') {
      showPopup("Can't retreat - this Pok√©mon is paralyzed!");
    } else {
      showPopup("Can't retreat - this Pok√©mon is locked!");
    }
  };
  return;
}

const canRetreatNormally = hasBench && canPay && !hasRetreatedThisTurn && !blockedByStatus;

if (canRetreatNormally) {
  btn.classList.add('payable');
  
  // Apply type-based coloring using data-type attribute (like attacks do)
  const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
  if (mainType) {
    btn.setAttribute('data-type', mainType);
    console.log('[RETREAT] Set data-type:', mainType);
  }
} else {
  btn.classList.add('muted');
}
btn.onclick = () => {
  // Check if retreat is blocked
  if (!canRetreatNormally) {
    if (hasRetreatedThisTurn) {
      showPopup('You can only retreat once per turn.');
    } else if (blockedByStatus) {
      showPopup('Cannot retreat while Asleep or Paralyzed.');
    } else {
      showPopup('Cannot retreat.');
    }
    return;
  }

  // EXECUTE RETREAT
  
  // 1. Discard energy for retreat cost
  let toDiscard = costCount;
  const energyBox = slot.querySelector('.energy-pips');
  if (energyBox && toDiscard > 0) {
    const pips = [...energyBox.querySelectorAll('.energy-pip')];
    for (const pip of pips) {
      if (toDiscard <= 0) break;
      pip.remove();
      toDiscard--;
      const type = (pip.dataset.type || 'colorless').toLowerCase();
      playerState[currentPlayer].discard.energyCounts[type] =
        (playerState[currentPlayer].discard.energyCounts[type] || 0) + 1;
    }
  }

  // 2. Consume temporary retreat cost reduction
  if (activeDiv.dataset.tempRetreatReduce != null) {
    delete activeDiv.dataset.tempRetreatReduce;
  }

  // 3. Mark that retreat has been used this turn
  hasRetreatedThisTurn = true;

  // 4. Move Active Pokemon to bench
  const activeSlot = activeDiv.querySelector('.card-slot');
  const benchDiv = benchFor(currentPlayer);
  const emptyBenchSlot = benchDiv.querySelector('.card-slot[data-empty="1"]');
  
  if (emptyBenchSlot && activeSlot) {
    // Detach all attachments (energy, HP, tools)
    const attachments = detachAttachments(activeSlot);
    
    // Move the card image
    const activeImg = activeSlot.querySelector('img');
    if (activeImg) {
      emptyBenchSlot.innerHTML = '';
      emptyBenchSlot.appendChild(activeImg.cloneNode(true));
      emptyBenchSlot.dataset.empty = '0';
      
      // Reattach everything to new bench position
      attachAttachments(emptyBenchSlot, attachments);
    }
    
    // Clear active slot
    activeSlot.innerHTML = '';
    markSlot(activeSlot, false);
    markSlot(emptyBenchSlot, true);
  }

  // 5. Log the retreat
  logEvent({
    player: currentPlayer,
    text: 'Retreated their Active Pok√©mon.'
  });

  // 6. Close attack menu
  closeAttackMenu();

  // 7. Begin promotion flow to choose new active
  beginPromotionFlow(currentPlayer);
};
  row.appendChild(btn);
  menu.appendChild(row);
}


function onPokemonClick(player, slot) {
    const card = (slot === "active")
        ? activePokemon[player]
        : benchPokemon[player][slot];

    // Ability check FIRST
    if (card && ABILITY_EFFECTS[card.id]) {
        openAbilityUI(player, card);
        return; // stop, do NOT open attack menu
    }

    // fallback to attacks
    showAttackMenuFor(player, slot);
}


/* ========= zoom ========= */
async function buildZoomPanel(meta,img){
  currentZoom={img,meta};

  zoomTitle.textContent=meta.name||'Pok√©mon';

  const mainType=(meta.types&&meta.types[0])?String(meta.types[0]).toLowerCase():null;
  zoomType.style.display=mainType?"block":"none";
  if(mainType)zoomType.style.backgroundImage=`url('${energyIconUrl(mainType)}')`;

  // Check for Giant Cape or other max HP modifiers
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp||meta.hp||'0',10)||0;
  const chp=parseInt(img.dataset.chp||base||'0',10)||base;

  zoomHp.textContent=`HP: ${chp} / ${base}`;
  
  // Make HP green if Giant Cape is attached
  if (modifiedMaxHp) {
    zoomHp.style.color = '#22c55e';
    zoomHp.style.fontWeight = '700';
  } else {
    zoomHp.style.color = '';
    zoomHp.style.fontWeight = '';
  }
  
  const pct=base>0?Math.round((chp/base)*100):0;

  zoomHpBar.style.width=pct+'%';
  zoomHpBar.style.background=
    (chp===base)
      ?'linear-gradient(90deg,#22c55e,#16a34a)'
      :'linear-gradient(90deg,#f43f5e,#ef4444)';

        /* Status icon in zoom header */
  if (zoomStatusIcon) {
    const sKey = (img.dataset.status || '').toLowerCase();
    const url = STATUS_ICON_URLS[sKey];
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }

  /* Energy section */
  const pips=countPipsOn(slot);

  zoomEnergyCount.textContent=`x${pips.total||0}`;
  zoomEnergyIcons.innerHTML='';

  Object.keys(pips).filter(k=>k!=='total').forEach(k=>{
    for(let i=0;i<pips[k];i++){
      const ico=document.createElement('span');
      ico.className='mini-icon';
      ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
      zoomEnergyIcons.appendChild(ico);
    }
  });

  /* Tool display */
  zoomTools.innerHTML='';
  const tool=getToolDataFromSlot(slot);

  if(tool){
    // Show tool overlaid on card image
    if (zoomToolImg) {
      zoomToolImg.src = tool.src;
      zoomToolImg.style.display = 'block';
    }
    
    // Also show in tools section
    const tImg=document.createElement('img');
    tImg.src=tool.src;
    tImg.alt='Tool';
    tImg.style.borderRadius='4px';
    tImg.style.boxShadow='0 2px 6px rgba(0,0,0,.6)';
    tImg.style.cursor='pointer';
    tImg.onclick=async ev=>{
      ev.stopPropagation();
      await openToolModal(tool.set,tool.num,tool.src);
    };
    zoomTools.appendChild(tImg);
  }else{
    // Hide tool overlay
    if (zoomToolImg) {
      zoomToolImg.style.display = 'none';
    }
    
    const none=document.createElement('div');
    none.className='chip';
    none.textContent='none';
    zoomTools.appendChild(none);
  }

  /* Abilities */
  /* Abilities */
  zoomAbilities.style.display = 'none';
  zoomAbilities.innerHTML = '';

  // Ensure ability CSV is loaded
  if (typeof ensureAbilityEffectsLoaded === 'function') {
    await ensureAbilityEffectsLoaded();
  }

  // Get abilities from BOTH meta AND CSV
  const metaAbilities = extractAbilities(meta);
  const abilityRows = (window.ABILITY_EFFECT_ROWS || []);
  
  console.log('[ZOOM] Meta abilities:', metaAbilities);
  console.log('[ZOOM] CSV rows loaded:', abilityRows.length);
  
  // Find CSV abilities for this card
  const setId = img.dataset.set;
  const numId = img.dataset.num;
  const csvAbilities = abilityRows.filter(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === String(numId).padStart(3, '0')
  );
  
  console.log('[ZOOM] CSV abilities for', setId, numId, ':', csvAbilities);
  
  // Combine abilities: prefer meta abilities, but add CSV ones if not in meta
  const allAbilities = [...metaAbilities];
  csvAbilities.forEach(csvAb => {
    const alreadyHas = metaAbilities.some(metaAb => 
      (metaAb.name || '').toLowerCase() === (csvAb.abilityName || '').toLowerCase()
    );
    if (!alreadyHas) {
      // Add CSV ability that wasn't in meta
      allAbilities.push({
        name: csvAb.abilityName,
        effect: csvAb.text || '',
        type: csvAb.abilityType
      });
    }
  });
  
  console.log('[ZOOM] All abilities:', allAbilities);
  if (allAbilities.length) {
    const bandClr = (TYPE_HEX[mainType || 'colorless'] || '#94a3b8');

  let ownerKey = null;
  if (img.closest("#player1") && !img.closest(".hand")) ownerKey = "player1";
  else if (img.closest("#player2") && !img.closest(".hand")) ownerKey = "player2";


    allAbilities.forEach(ab => {
      const box = document.createElement('div');
      box.className = 'ability-box';

      const head = document.createElement('div');
      head.className = 'ability-head';
      head.style.background = bandClr;
      head.style.color = '#0b0f14';

      const badge = document.createElement('img');
      badge.src = ABILITY_BADGE;
      badge.alt = '';

      const nm = document.createElement('div');
      nm.className = 'ability-name';
      nm.textContent = ab.name || 'Ability';

      head.appendChild(badge);
      head.appendChild(nm);

      const tx = document.createElement('div');
      tx.className = 'ability-text';
      tx.textContent = ab.effect || '';

      box.appendChild(head);
      box.appendChild(tx);
      zoomAbilities.appendChild(box);

      // --------- Wiring to CSV / ability engine ----------
      // --------- Wiring to CSV / ability engine ----------
      if (!ownerKey || !currentPlayer) {
        box.classList.add('ability-disabled');
        return;
      }
      const isCurrentPlayersCard = (ownerKey === currentPlayer);
      const setId  = img.dataset.set;
      const numId  = img.dataset.num;
      
      // Use the img parameter directly - it's the actual clicked Pokemon!
      // Don't use querySelector - it finds the FIRST matching Pokemon, not the clicked one
      const actualPokemonImg = img;
      const cardKey = getAbilityCardKey(setId, numId, actualPokemonImg);
      console.log('[ZOOM-ABILITY] Using clicked img directly');
      console.log('[ZOOM-ABILITY] cardKey:', cardKey, 'instanceId:', actualPokemonImg?.dataset.instanceId);

      // Match row from ability_effects.csv
      const row = abilityRows.find(r =>
        r.set === setId &&
        String(r.number).padStart(3, '0') === String(numId).padStart(3, '0') &&
        (r.abilityName || '').toLowerCase() === (ab.name || '').toLowerCase()
      );
      
      // Convert ownerKey to p1/p2 format if needed
      const ownerPk = (ownerKey === 'p1' || ownerKey === 'p2') ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
      
      // Check if this is an "unlimited" ability
      const isUnlimited = row && (
        (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
        (row.text && /as often as you like/i.test(row.text))
      );
      
      const alreadyUsed = !isUnlimited && !!window.usedAbilitiesThisTurn[ownerPk]?.[cardKey];
      console.log('[ZOOM-ABILITY] Checking:', ownerPk, cardKey, 'alreadyUsed:', alreadyUsed, 'isUnlimited:', isUnlimited);

      // Check if in active slot (for abilities that require being active)
      const isActiveSlot = img.closest('.active') !== null;
      const requiresActive = row ? abilityRequiresActive(row) : false;
      
      // üÜï Check if this is a passive ability
      const isPassive = row && row.abilityType === 'passive';

      // If it's passive, show it with PASSIVE label but keep colored background
      if (isPassive) {
        // Keep the type-colored background (bandClr already set above)
        // Just add PASSIVE label - don't change opacity or saturation
        
        const passiveLabel = document.createElement('span');
        passiveLabel.textContent = 'PASSIVE';
        passiveLabel.style.cssText = `
          display: inline-block;
          padding: 2px 6px;
          background: rgba(0, 0, 0, 0.4);
          border-radius: 3px;
          font-size: 9px;
          font-weight: bold;
          color: rgba(255, 255, 255, 0.9);
          margin-left: 6px;
          letter-spacing: 0.5px;
          vertical-align: middle;
        `;
        nm.appendChild(passiveLabel);
        
        // Mark as disabled (not clickable) but don't change visual appearance
        box.classList.add('ability-disabled');
        
        // Don't add click handler for passive abilities
        return;
      }

      // Only make it clickable if:
      // - we have a CSV row
      // - it is an "active" ability (not passive)
      // - it belongs to the current player
      // - it has not been used this turn
      // - if it requires active, the pokemon is in active slot
      if (!row || row.abilityType !== 'active' ||
          !isCurrentPlayersCard || alreadyUsed || gameOver ||
          (requiresActive && !isActiveSlot)) {
        box.classList.add('ability-disabled');
        return;
      }

      box.classList.add('ability-glow');

      box.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        
        // Check if already used (but allow unlimited abilities)
        const isUnlimitedAbility = 
          (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
          (row.text && /as often as you like/i.test(row.text));
        
        if (!isUnlimitedAbility && window.usedAbilitiesThisTurn[ownerPk]?.[cardKey]) return;

        // Close zoom modal IMMEDIATELY so user can interact with board
        if (zoomBackdrop && zoomBackdrop.classList.contains('show')) {
          console.log('[ZOOM] Closing zoom backdrop for ability interaction');
          zoomBackdrop.classList.remove('show');
          currentZoom = { img: null, meta: null };
        }

        if (typeof applyAbilityEffectFromCsv !== 'function') {
          console.warn('applyAbilityEffectFromCsv missing');
          showPopup('Ability engine not available.');
          return;
        }

        // ownerPk already in p1/p2 format
        const pk = ownerPk;

        // Shared state object for effects.js (similar to move effects)
        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent,
          attachEnergyToSlot,
          energyZoneDiv,
          renderEnergyZone,
          getActiveImage
        };

try {
          const result = await applyAbilityEffectFromCsv(effectState, pk, row, { abilityPokemon: actualPokemonImg });

          // Check if this is an "unlimited" ability (can be used multiple times per turn)
          const isUnlimited = 
            (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
            (row.text && /as often as you like/i.test(row.text));

          // Only mark as used if NOT unlimited
          if (!isUnlimited) {
            if (!window.usedAbilitiesThisTurn[ownerPk]) {
              window.usedAbilitiesThisTurn[ownerPk] = {};
            }
            window.usedAbilitiesThisTurn[ownerPk][cardKey] = true;
            
            console.log('[ZOOM] Ability used (once per turn):', ownerPk, cardKey, 'instanceId:', actualPokemonImg?.dataset.instanceId);
            console.log('[ZOOM] usedAbilitiesThisTurn:', JSON.stringify(window.usedAbilitiesThisTurn));

            box.classList.remove('ability-glow');
            box.classList.add('ability-disabled');
          } else {
            console.log('[ZOOM] Ability used (unlimited):', ownerPk, cardKey, 'instanceId:', actualPokemonImg?.dataset.instanceId);
            // Keep ability glowing - can be used again!
          }

          // Update attack menu if open
          if (openAttackMenu) {
            const abilityRow = openAttackMenu.querySelector('.attack-ability-row');
            if (abilityRow) {
              abilityRow.classList.add('used');
            }
          }
          
          // Check if ability caused a KO (e.g., Greninja's Water Shuriken)
          console.log('[ZOOM] Ability result:', result);
          if (result && result.knocked) {
            console.log('[ZOOM] Ability caused KO, handling...');
            const foePk = ownerPk === 'p1' ? 'p2' : 'p1';
            const foe = foePk === 'p1' ? 'player1' : 'player2';
            
            // Use the knockedImg from result if available (for abilities that target any Pokemon)
            const foeImg = result.knockedImg || getActiveImage(foe);
            
            if (foeImg && typeof handleKnockOut === 'function') {
              console.log('[ZOOM] Handling KO for:', foeImg.alt);
              
              // Check if knocked Pokemon was active
              const foeActive = getActiveImage(foe);
              const wasActive = (foeImg === foeActive);
              
              const ended = await handleKnockOut(foe, foeImg, wasActive);
              if (!ended && typeof beginPromotionFlow === 'function') {
                // Only promote if active was KO'd
                if (wasActive) {
                  beginPromotionFlow(foe);
                }
              }
            }
          }

        } catch (err) {
          console.error('Ability effect error:', err);
          showPopup('Ability failed.');
        }
      });
    });

    zoomAbilities.style.display = 'block';
  }

  /* Attacks */
  zoomAttacks.innerHTML='';
  
  // üÜï Check if this is a fossil - show Discard instead of attacks
  const isFossil = img.dataset.isFossil === 'true';
  
  if (isFossil) {
    const discardCard = document.createElement('div');
    discardCard.className = 'zoom-attack';
    discardCard.style.cursor = 'pointer'; // Make it look clickable
    
    const top = document.createElement('div');
    top.className = 'top';
    top.style.background = '#94a3b8'; // Colorless
    top.style.color = '#fff';
    
    const nm = document.createElement('div');
    nm.className = 'name';
    nm.textContent = 'Discard';
    
    top.appendChild(nm);
    discardCard.appendChild(top);
    
    const divider = document.createElement('div');
    divider.className = 'thin';
    const eff = document.createElement('div');
    eff.className = 'effect';
    eff.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    
    discardCard.appendChild(divider);
    discardCard.appendChild(eff);
    
    // üÜï Add click handler for discard
    discardCard.addEventListener('click', async (e) => {
      e.stopPropagation();
      
      // Determine which player owns this fossil
      const ownerDiv = img.closest('#player1, #player2');
      const pk = ownerDiv?.id === 'player1' ? 'p1' : 'p2';
      
      // Close zoom panel
      if (zoomBackdrop) {
        zoomBackdrop.classList.remove('show');
      }
      currentZoom = { img: null, meta: null };
      
      // Check if fossil is active
      const isActive = !!img.closest('.active');
      
      // Discard the fossil (no point given)
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(img, pk, false);
      }
      
      showPopup(`${meta.name || 'Fossil'} was discarded.`);
      
      // If it was active, promote from bench
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          // Bench out!
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pok√©mon left!');
          return;
        }
        
        // Promote from bench - pk is the fossil owner
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); // pk = fossil owner (p1 or p2)
        }
      }
    });
    
    zoomAttacks.appendChild(discardCard);
    
    console.log('[zoom] Showing Discard option for fossil');
  } else {
    // Normal Pokemon - show attacks

  (meta.attacks||[]).forEach(atk=>{
    const card=document.createElement('div');
    card.className='zoom-attack';

    const top=document.createElement('div');
    top.className='top';

    const left=document.createElement('div');
    left.style.display='flex';
    left.style.alignItems='center';
    left.style.gap='6px';

    const nm=document.createElement('div');
    nm.className='name';
    nm.textContent=atk.name||'Attack';

    const cost=makeCostIcons(atk.cost||[], slot, img);
    left.appendChild(nm);
    left.appendChild(cost);

    const dmg=document.createElement('div');
    dmg.className='dmg';
    dmg.textContent=(atk.damage||'').toString();

    top.appendChild(left);
    top.appendChild(dmg);
    card.appendChild(top);

    /* Effect text row */
    const divider=document.createElement('div');
    divider.className='thin';
    const eff=document.createElement('div');
    eff.className='effect';
    eff.textContent=atk.effect?String(atk.effect):'';

    card.appendChild(divider);
    card.appendChild(eff);

    const payable=canPayCostFromAPI(slot,atk.cost||[], img);

    if(payable&&mainType){
      top.style.background=TYPE_HEX[mainType]||'#94a3b8';
      top.style.color='#fff';
      nm.style.color='#fff';
      dmg.style.color='#fff';
    }else{
      top.style.background='#2a2f36';
      top.style.color='#e5e7eb';
      card.classList.add('muted');
    }

    const isActiveCurrent = (currentPlayer && activeFor(currentPlayer).querySelector('img') === img);

    if (isActiveCurrent) {
      card.onclick = async () => {
        const pk  = currentPlayer === 'player1' ? 'p1' : 'p2';

        // Block attacks if Asleep or Paralyzed
        if (isActiveBlockedFromAttacking(pk)) {
          const imgBlocked = getActiveImg(pk);
          const st = (imgBlocked?.dataset.status || '').toLowerCase();
          if (st === 'asleep') {
            showPopup('This Pok√©mon is asleep and can‚Äôt attack.');
          } else if (st === 'paralyzed') {
            showPopup('This Pok√©mon is paralyzed and can‚Äôt attack.');
          }
          return;
        }

        if (!payable) {
          showPopup('Not enough energy to use this attack.');
          return;
        }

        const foe = opponentOf(currentPlayer);

        let damage = parseDamage(atk.damage);

        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent
        };

        // Single call to effects.js
        try {
          damage = await applyMoveEffectFromCsv(
            effectState,
            pk,
            atk.name,
            damage
          );
          // Giovanni global damage boost
          const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
          if (boost) {
            console.log("[Giovanni boost applied] +", boost, "‚Üí", damage + boost);
            damage += boost;
          }
          
          // üÜï A3 - Next turn damage bonus (Crabominable ex)
          const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
          if (nextTurnBonus > 0) {
            console.log('[zoom attack] Next turn bonus applied +', nextTurnBonus);
            damage += nextTurnBonus;
            // Clear after use
            if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
              globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
            }
          }

        } catch (err) {
          console.error('Move effect error (zoom):', err);
        }

        // Weakness
        try {
          const foeImg = getActiveImage(foe);
          if (foeImg) {
            const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
            const wk = metaFoe?.weaknesses?.[0];

            if (wk) {
              const wkType = (wk.type || '').toLowerCase();
              if (wkType !== 'colorless') {
                const atkType = (meta.types?.[0] || '').toLowerCase();
                if (atkType === wkType) {
                  damage += 20;
                }
              }
            }
          }
        } catch (err) {
          console.error('Weakness check failed (zoom):', err);
        }

        const result = await damageActiveOf(foe, damage, { attackerImg: img });
        // Status icon inside fullscreen modal
        const st = (img.dataset.status || "").toLowerCase();
        if (st && STATUS_ICON_URLS[st]) {
          zoomStatus.style.display = "block";
          zoomStatus.style.backgroundImage = `url('${STATUS_ICON_URLS[st]}')`;
        } else {
          zoomStatus.style.display = "none";
          zoomStatus.style.backgroundImage = "";
        }

        // Close zoom
        zoomBackdrop.classList.remove('show');
        currentZoom = { img: null, meta: null };

        // Handle KO
        if (result.knocked) {
          const foeImg2 = getActiveImage(foe);
          if (foeImg2) {
            const ended = await handleKnockOut(foe, foeImg2);
            if (ended) return;
            beginPromotionFlow(foe);
          }
        }

        setTimeout(() => startTurn(foe), 300);
      };
    } else {
      // Not current active: just visually muted
      card.classList.add('muted');
    }



    zoomAttacks.appendChild(card);
  });
  
  } // End of else (normal Pokemon attacks)

  /* Weakness display */
  zoomWeakness.innerHTML='';
  {
    const wk=(meta.weaknesses&&meta.weaknesses[0])||null;
    if(wk){
      const k=String(wk.type||'').toLowerCase();
      if(k==='colorless'){
        zoomWeakness.textContent='‚Äî';
      }else{
        const ico=document.createElement('span');
        ico.className='mini-icon';
        ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;

        const val=document.createElement('span');
        val.className='mini-badge';
        val.textContent=wk.value||'';

        zoomWeakness.appendChild(ico);
        zoomWeakness.appendChild(val);
      }
    }else zoomWeakness.textContent='‚Äî';
  }

  /* Retreat cost display */
  zoomRetreat.innerHTML='';
  const rcost=computeRetreatCost(img.closest('.active'),meta);

  for(let i=0;i<rcost;i++){
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${ENERGY_ICONS.colorless}')`;
    zoomRetreat.appendChild(ico);
  }
}
/* ========= tool modal ========= */
async function openToolModal(set,num,src){
  if(!toolBackdrop)return;
  toolImg.src=src||'';
  toolTitle.textContent='Tool';
  toolMeta.textContent='';
  toolText.textContent='';
  toolBackdrop.classList.add('show');
  try{
    const meta=await fetchCardMeta(set,num);
    toolTitle.textContent=meta.name||'Tool';
    toolMeta.textContent=(meta.trainerType?meta.trainerType:'Tool');
    toolText.textContent=(meta.effect||meta.description||'');
  }catch{
    toolText.textContent='No details available.';
  }
}
if(toolBackdrop){
  toolBackdrop.addEventListener('click',e=>{
    if(e.target===toolBackdrop)toolBackdrop.classList.remove('show');
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape')toolBackdrop.classList.remove('show');
  });
}

/* ========= evolution ========= */
function clearGlow(){
  $$('.glow-evo,.promote-glow').forEach(el=>el.classList.remove('glow-evo','promote-glow'));
  isEvoMode=false;evoMeta=null;evoOwner=null;evoHandCard=null;
}

async function evolveCard(target,meta,handCard,owner,set,num){
  if(globalThis.turnNumber<=2){
    showPopup('You can‚Äôt evolve during the first two turns.');
    clearGlow();
    return;
  }
  const playedTurn=parseInt(target.dataset.playedTurn||'0',10);
  if(playedTurn===globalThis.turnNumber){
    showPopup('Can‚Äôt evolve the turn it was played.');
    clearGlow();
    return;
  }

  // üÜï A3a - Check if Aerodactyl ex is blocking evolution of active Pokemon
  const pk = owner === 'player1' ? 'p1' : 'p2';
  const oppPk = pk === 'p1' ? 'p2' : 'p1';
  const activeDiv = owner === 'player1' ? p1Active : p2Active;
  const activeImg = activeDiv?.querySelector('img');
  const isTargetActive = target === activeImg;
  
  if (isTargetActive) {
    // Check if opponent has Aerodactyl ex with Primeval Law
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppBench = oppPk === 'p1' ? p1Bench : p2Bench;
    const oppPokemon = [
      ...(oppActive?.querySelectorAll('img') || []),
      ...(oppBench?.querySelectorAll('img') || [])
    ];
    
    for (const oppImg of oppPokemon) {
      const cacheKey = `${oppImg.dataset.set}-${oppImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'block_evolution') {
        const targetParam = abilityRow.param1 || 'opponent';
        if (targetParam === 'opponent' || targetParam === 'all') {
          showPopup('Cannot evolve Active Pok√©mon - blocked by Primeval Law!');
          clearGlow();
          return;
        }
      }
    }
  }

  const prevHp=parseInt(target.dataset.hp||'0',10);
  const prevChp=parseInt(target.dataset.chp||prevHp||'0',10);

  const padded=String(num).padStart(3,'0');
  const evolvedImage=`https://assets.tcgdex.net/en/tcgp/${set}/${padded}/high.png`;
  const evo=document.createElement('img');
  evo.className='card-img';
  evo.alt=meta.name;
  evo.src=evolvedImage;
  evo.dataset.playedTurn=globalThis.turnNumber;
  
  // Preserve instance ID from base Pokemon
  if (target.dataset.instanceId) {
    evo.dataset.instanceId = target.dataset.instanceId;
  }
  evo.dataset.evolvedFrom=(meta.evolveFrom||'').toLowerCase();
  evo.dataset.set=set;
  evo.dataset.num=num;

  const slot=target.closest('.card-slot');

  
/* clear any special condition on the old Pok√©mon */
  clearStatusOnImg(target);
/* -----------------------------
   ATTACHMENT TRANSFER ‚Äî correct + minimal
------------------------------ */
const energyBox = slot.querySelector('.energy-pips');
const hpOverlay = slot.querySelector('.hp-overlay');
const toolThumb = slot.querySelector('.tool-thumb');

// All attachments remain in the same slot; only the image changes.
// So we simply keep these elements alive and re-append them after replacing the img.

const oldImg = slot.querySelector('img'); // original card image
const hadEnergy = !!energyBox;
const hadHP     = !!hpOverlay;
const hadTool   = !!toolThumb;

// Remove old image
if (oldImg) oldImg.remove();

// Insert new card image
// Insert new evolved card image
slot.insertBefore(evo, slot.firstChild);

// Restore overlays
if (hadEnergy) slot.appendChild(energyBox);
if (hadHP)     slot.appendChild(hpOverlay);
if (hadTool)   slot.appendChild(toolThumb);

// Preserve tool data mapping
const toolObj = getToolDataFromSlot(slot);
if (toolObj) {
  setToolDataOnSlot(slot, toolObj);
}


  // Calculate new HP, accounting for Giant Cape if attached
  const newHp = parseInt(meta.hp||'0',10) || prevHp || 0;
  
  // Check if Giant Cape or Leaf Cape is attached
  const toolData = getToolDataFromSlot(slot);
  const isGiantCape = toolData && (toolData.set === 'A2' && toolData.num === '147');
  const isLeafCape = toolData && (toolData.set === 'A3' && toolData.num === '147');
  const hasHpBoostingTool = isGiantCape || isLeafCape;
  const hpBonus = isGiantCape ? 20 : (isLeafCape ? 30 : 0);
  
  // Calculate HP increase from evolution (base HP difference)
  const hpIncrease = newHp - prevHp;
  
  // New current HP = old current HP + HP increase
  // This preserves the same damage amount relative to the NEW max HP
  const newChp = Math.max(0, prevChp + hpIncrease);
  
  // Calculate new max HP: evolved HP + cape bonus
  const newMaxHp = newHp + hpBonus;
  
  // If HP-boosting tool is attached, update slot's maxHp
  if (hasHpBoostingTool) {
    slot.dataset.maxHp = String(newMaxHp);
    console.log(`[evolve] HP tool active, base HP: ${prevHp} ‚Üí ${newHp} (+${hpIncrease})`);
    console.log(`[evolve] Current HP: ${prevChp} ‚Üí ${newChp} (+${hpIncrease})`);
    console.log(`[evolve] Final display: ${newChp} / ${newMaxHp}`);
  } else {
    // No HP-boosting tool, clear any old maxHp data
    delete slot.dataset.maxHp;
    console.log(`[evolve] No HP tool, base HP: ${prevHp} ‚Üí ${newHp} (+${hpIncrease})`);
    console.log(`[evolve] Current HP: ${prevChp} ‚Üí ${newChp} (+${hpIncrease})`);
  }
  
  setHpOnImage(evo, newHp, newChp);
  markSlot(slot,true);
  removeFromHand(owner,set,num);
  renderAllHands();

  logEvent({
    player: owner,
    text:`Evolved ${meta.evolveFrom || 'a Pok√©mon'} into ${meta.name}.`,
    cardSet:set,cardNum:num
  });

  showPopup(`${meta.evolveFrom} ‚Üí ${meta.name}`);
  
  // üÜï A3b - Sylveon ex Happy Ribbon (draw on evolution)
  try {
    const cacheKey = `${set}-${num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'draw_on_evolution') {
      const pkForAbility = owner === 'player1' ? 'p1' : 'p2';
      // Use effectState structure like other places
      const effectState = {
        p1: playerState.player1,
        p2: playerState.player2
      };
      
      if (typeof applyAbilityEffectFromCsv === 'function') {
        await applyAbilityEffectFromCsv(effectState, pkForAbility, abilityRow, {});
        console.log('[Happy Ribbon] Drew cards on evolution');
      }
    }
  } catch (err) {
    console.error('[Evolution] Happy Ribbon check failed:', err);
  }
  
  if(currentZoom.img&&currentZoom.img===evo){
    await buildZoomPanel(meta,evo);
  }
}

/* ========= board interactions ========= */
function handFind(owner,set,num){
  return playerState[owner].hand.find(c=>c.set===set&&String(c.number||c.num)===String(num))||null;
}

function attachEnergyToSlot(owner,slot,energyKey){
  if(!slot||!energyKey)return;
  const img=slot.querySelector('img');
  if(!img){showPopup('Select a Pok√©mon in play.');return}
  const area=currentPlayer==='player1'?$('#player1'):$('#player2');
  if(!area.contains(slot)||slot.closest('.hand')){
    showPopup('Attach only to Pok√©mon in play.');
    return;
  }
  const set=img.dataset.set,num=img.dataset.num;
  fetchCardMeta(set,num).then(meta=>{
    const isFossil = img.dataset.isFossil === 'true';
    if(String(meta.category||'').toLowerCase()!=='pokemon' && !isFossil){
      showPopup('You can only attach to Pok√©mon.');
      return;
    }
    let box=slot.querySelector('.energy-pips');
    if(!box){
      box=document.createElement('div');
      box.className='energy-pips';
      slot.appendChild(box);
    }
    const pip=document.createElement('div');
    pip.className='energy-pip';
    pip.dataset.type=energyKey;
    pip.style.backgroundImage=`url('${ENERGY_ICONS[energyKey]||''}')`;
    box.appendChild(pip);
    
    // üÜï Check if we need to add doubled visual pip (Jungle Totem)
    addDoubledEnergyVisuals(img, box, energyKey);
    
    // üÜï A2 PASSIVE ABILITY - Nightmare Aura (damage on Dark energy attach)
    if (typeof triggerNightmareAura === 'function') {
      triggerNightmareAura(img, energyKey);
    }
    
    // üÜï A3 PASSIVE ABILITY - Comatose (self-sleep on energy attach to active)
    (async () => {
      try {
        const pk = owner === 'player1' ? 'p1' : 'p2';
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'inflict_status_on_energy_attach') {
          if (typeof applyAbilityEffectFromCsv === 'function') {
            // Need to pass state object
            const state = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            await applyAbilityEffectFromCsv(state, pk, abilityRow, { targetImg: img });
          }
        }
      } catch (err) {
        console.warn('[Komala] Failed to trigger ability:', err);
      }
    })();
    
    hasAttachedEnergyThisTurn=true;
    renderEnergyZone();
    showPopup('Energy attached');

    logEvent({
      player: owner,
      text:`Attached ${energyKey} Energy.`,
      cardSet:set,cardNum:num
    });

    if(currentZoom.img&&slot.contains(currentZoom.img)){
      buildZoomPanel(meta,currentZoom.img);
    }
  }).catch(()=>showPopup('Error verifying card.'));
}

// Add visual doubled energy pips (at 70% opacity) for Jungle Totem
function addDoubledEnergyVisuals(img, energyBox, energyKey) {
  if (!img || !energyBox || !energyKey) return;
  
  // Determine owner
  const p1Active = document.querySelector('#player1 .active img');
  const p1Bench = Array.from(document.querySelectorAll('#player1 .bench img'));
  const p2Active = document.querySelector('#player2 .active img');
  const p2Bench = Array.from(document.querySelectorAll('#player2 .bench img'));
  
  let owner = null;
  if (img === p1Active || p1Bench.includes(img)) owner = 'p1';
  else if (img === p2Active || p2Bench.includes(img)) owner = 'p2';
  
  if (!owner) return;
  
  // Check if Serperior is in play (Jungle Totem)
  const allMyPokemon = owner === 'p1' ? [p1Active, ...p1Bench] : [p2Active, ...p2Bench];
  let hasSerperior = false;
  
  for (const pokemon of allMyPokemon) {
    if (pokemon && pokemon.alt && pokemon.alt.toLowerCase().includes('serperior')) {
      hasSerperior = true;
      break;
    }
  }
  
  // Only double Grass energy on Grass Pokemon with Serperior in play
  if (hasSerperior && energyKey.toLowerCase() === 'grass') {
    const types = (img.dataset.pokemonTypes || '').toLowerCase().split(',');
    if (types.includes('grass')) {
      // Add phantom pip at 70% opacity
      const phantomPip = document.createElement('div');
      phantomPip.className = 'energy-pip phantom-pip';
      phantomPip.dataset.type = energyKey;
      phantomPip.dataset.phantom = 'true';  // Mark as phantom
      phantomPip.style.backgroundImage = `url('${ENERGY_ICONS[energyKey]||''}')`;
      phantomPip.style.opacity = '0.7';
      phantomPip.title = 'Doubled by Jungle Totem';
      energyBox.appendChild(phantomPip);
      
      console.log(`[jungle-totem-visual] Added phantom grass pip to ${img.alt}`);
    }
  }
}

// Update all energy visuals when Serperior enters/leaves play
function updateAllEnergyVisuals() {
  // Disconnect observer temporarily to prevent infinite loop
  const observer = globalThis.pokemonTypeObserver;
  if (observer) {
    observer.disconnect();
  }
  
  // Check both players
  ['p1', 'p2'].forEach(owner => {
    const area = owner === 'p1' ? document.querySelector('#player1') : document.querySelector('#player2');
    if (!area) return;
    
    const allSlots = Array.from(area.querySelectorAll('.card-slot'));
    
    allSlots.forEach(slot => {
      const img = slot.querySelector('img');
      const energyBox = slot.querySelector('.energy-pips');
      if (!img || !energyBox) return;
      
      // Remove all existing phantom pips
      energyBox.querySelectorAll('.phantom-pip').forEach(p => p.remove());
      
      // Get real energy pips (non-phantom)
      const realPips = Array.from(energyBox.querySelectorAll('.energy-pip:not(.phantom-pip)'));
      
      // Re-add phantom pips for each real grass energy
      realPips.forEach(pip => {
        const energyType = pip.dataset.type;
        if (energyType) {
          addDoubledEnergyVisuals(img, energyBox, energyType);
        }
      });
    });
  });
  
  // Reconnect observer after updates
  if (observer && document.body) {
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
  console.log('[jungle-totem-visual] Updated all energy visuals');
}

// Expose globally
globalThis.updateAllEnergyVisuals = updateAllEnergyVisuals;


/* primary click */
document.body.addEventListener('click', async e => {
  if (e.button !== 0) return;

  /* üÜï Tool thumbnail click - show tool details */
  const toolThumb = e.target.closest('.tool-thumb');
  if (toolThumb) {
    e.stopPropagation();
    e.preventDefault();
    
    const slot = toolThumb.closest('.card-slot');
    const toolData = getToolDataFromSlot(slot);
    const pokemonImg = slot.querySelector('img:not(.tool-thumb)');
    
    if (toolData && toolData.set && toolData.num) {
      try {
        const meta = await fetchCardMeta(toolData.set, toolData.num);
        
        // Show in hand modal (for trainers)
        if (handBackdrop && handImg && handToolImg) {
          // Show Pokemon card
          if (pokemonImg) {
            handImg.src = pokemonImg.src;
          }
          
          // Show tool on top
          handToolImg.src = toolData.src || toolThumb.src;
          handToolImg.style.display = 'block';
          
          handBackdrop.classList.add('show');
          handTitle.textContent = meta.name || 'Tool';
          
          if (handType) {
            handType.textContent = 'Tool';
            handType.style.background = trainerColor('tool');
          }
          if (handEffect) {
            handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
          }
        }
        
        console.log('[tool-click] Showing tool details:', meta.name);
      } catch (err) {
        showPopup('Could not load tool data.');
        console.error('[tool-click] Error:', err);
      }
    }
    
    return;
  }

  /* tool attach flow */
  if (toolAttachPending) {
    const targetImg = e.target.closest('.active img, .bench img');
    if (targetImg) {
      const owner = targetImg.closest('#player1') ? 'player1' : 'player2';
      if (owner !== toolAttachPending.owner) {
        showPopup('Attach Tools to your own Pok√©mon.');
      } else {
        const targetSlot = targetImg.closest('.card-slot');
        if (getToolDataFromSlot(targetSlot)) {
          showPopup('This Pok√©mon already has a Tool attached.');
        } else {
          // Attach tool visually
          await attachToolToSlot(owner, targetSlot, {
            set: toolAttachPending.set,
            num: toolAttachPending.num,
            src: toolAttachPending.src
          });
          
          // üÜï Apply tool effect!
          const cardId = csvIdFor(toolAttachPending.set, toolAttachPending.num);
          const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
          
          if (effect && effect.effect_type) {
            console.log('[tool] Applying effect:', effect.effect_type);
            // Tools need to know which Pokemon they're attached to
            // Store target in a temp variable for the effect
            globalThis.toolAttachTarget = targetImg;
            
            try {
              await applyTrainerEffect(effect, owner, null); // null = no trainer card for tools
              
              // Effect succeeded - finish attachment
              removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
              renderAllHands();

              logEvent({
                player: owner,
                text: 'Attached Tool.',
                cardSet: toolAttachPending.set,
                cardNum: toolAttachPending.num
              });

              toolAttachPending = null;
              
            } catch (err) {
              // Effect failed (e.g., wrong type for Leaf Cape)
              console.log('[tool] Effect failed, removing tool:', err.message);
              
              // Remove the tool that was just attached
              const toolThumb = targetSlot.querySelector('.tool-thumb');
              if (toolThumb) toolThumb.remove();
              setToolDataOnSlot(targetSlot, null);
              
              showPopup(err.message || 'Cannot attach this Tool here.');
              // Card stays in hand
            } finally {
              globalThis.toolAttachTarget = null;
            }
          } else {
            // No effect to apply - just finish attachment
            removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
            renderAllHands();

            logEvent({
              player: owner,
              text: 'Attached Tool.',
              cardSet: toolAttachPending.set,
              cardNum: toolAttachPending.num
            });

            toolAttachPending = null;
          }
        }
      }
      e.stopPropagation();
      return;
    }
  }

  /* energy pick */
  if (selectedEnergy) {
    const img = e.target.closest('.card-slot img');
    if (!img) return;
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    if (owner !== currentPlayer) {
      showPopup('Attach Energy to your own Pok√©mon.');
      return;
    }
    attachEnergyToSlot(owner, img.closest('.card-slot'), selectedEnergy);
    selectedEnergy = null;
    return;
  }

  /* ========================================
     FIXED: Attack Menu Opening
  ======================================== */
  
  // Check if clicking on Active Pok√©mon (not in hand)
  const clickedImg = e.target.closest('img');
  
  if (clickedImg && !clickedImg.closest('.hand')) {
    // Check if this is the current player's Active Pok√©mon
    const activeArea = currentPlayer ? activeFor(currentPlayer) : null;
    
    if (activeArea && activeArea.contains(clickedImg)) {
      // Check if we're in a special mode that should block attack menu
      if (isEvoMode || toolAttachPending || selectedEnergy || isPromotionPhase || isRetreatSelection || abilityJustUsed) {
        console.error('[MENU-BLOCKED] Cannot open menu, special mode active:', {
          isEvoMode,
          toolAttachPending: !!toolAttachPending,
          selectedEnergy,
          isPromotionPhase,
          isRetreatSelection,
          abilityJustUsed,
          timestamp: new Date().toISOString()
        });
        return;
      }
      
      console.log('[MENU-ALLOWED] Opening menu, all flags clear:', {
        isEvoMode,
        toolAttachPending: !!toolAttachPending,
        selectedEnergy,
        isPromotionPhase,
        isRetreatSelection
      });

      const set = clickedImg.dataset.set;
      const num = clickedImg.dataset.num;
      
      console.log('[attack-menu] Attempting to open for:', set, num);
      
      if (!set || !num) {
        console.error('[attack-menu] Missing set/num:', { set, num });
        closeAttackMenu();
        return;
      }

      try {
        const meta = await fetchCardMeta(set, num);
        console.log('[attack-menu] Fetched meta:', meta);
        
        if (!meta) {
          showPopup('Could not load card data.');
          return;
        }
        
        // Check if this is a Pok√©mon card OR a fossil
        const category = String(meta.category || '').toLowerCase();
        const isFossil = clickedImg.dataset.isFossil === 'true';
        
        if (category !== 'pokemon' && !isFossil) {
          console.warn('[attack-menu] Not a Pok√©mon card:', category);
          showPopup('This is not a Pok√©mon card.');
          return;
        }
        
        // Open the attack menu with the clicked image
        showAttackMenuFor(clickedImg, meta);
        
      } catch (err) {
        console.error('[attack-menu] Error loading card:', err);
        showPopup('No attacks available.');
      }
      
      return;
    }
  }

  /* hand interactions - only if not clicking active */
/* hand interactions - only if not clicking active */
if (e.target.tagName !== 'IMG') return;
const inHand = e.target.closest('.hand');
if (!inHand) return;

const owner = e.target.dataset.owner;
const set = e.target.dataset.set;
const num = e.target.dataset.num;
const trainerCardImg = e.target; // Store reference to the trainer card image

// During game, only current player can interact with their hand
// During setup (currentPlayer is null), anyone can place cards
if (currentPlayer && owner !== currentPlayer) return;

// üÜï Check if Pokemon Communication is active
if (globalThis.__pokemonCommActive) {
  const selData = globalThis.__pokemonCommSelection;
  if (selData) {
    // Check if this card is one of the eligible Pokemon
    const clickedCard = selData.hand.find(c => 
      (c.set === set && String(c.number || c.num) === String(num))
    );
    
    if (clickedCard && selData.pokemonInHand.includes(clickedCard)) {
      // Valid selection!
      globalThis.__pokemonCommActive = false;
      globalThis.__pokemonCommSelection = null;
      
      if (globalThis.__pokemonCommResolve) {
        globalThis.__pokemonCommResolve(clickedCard);
        globalThis.__pokemonCommResolve = null;
      }
      
      console.log('[Pokemon Communication] Selected:', clickedCard.name);
      return;
    }
  }
}

let meta = null;
try {
  meta = await fetchCardMeta(set, num);
} catch {}

/* trainer */
if (meta && String(meta.category || '').toLowerCase() === 'trainer') {
  if (isSetupPhase) {
    showPopup("You can't play Trainer cards during setup.");
    return;
  }
  
  const ttype = String(meta.trainerType || '').toLowerCase();
  const cardId = csvIdFor(set, num);
  const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
  
  const doEffect = async () => {
    if (effect) {
      await applyTrainerEffect(effect, owner, trainerCardImg, true); // throwOnError = true for items
    } else {
      console.warn('No CSV effect for', cardId);
    }
  };

  if (ttype === 'supporter') {
    // CHECK SUPPORTER BLOCK
        const pk = owner === 'player1' ? 'p1' : 'p2';

    if (!canUseSupporter(pk)) {
      showPopup("Can't use Supporter cards this turn!");
      return;
    }
    // Check if Gengar ex is blocking Supporters
    if (isGengarBlocking(owner)) {
      showPopup('Shadowy Spellbind: You cannot play Supporter cards!');
      return;
    }
    
    if (hasPlayedSupporterThisTurn[owner]) {
      showPopup('Only one Supporter per turn.');
      return;
    }
    
    addTrainerToDiscard(owner, e.target);
    removeFromHand(owner, set, num);
    renderAllHands();
    hasPlayedSupporterThisTurn[owner] = true;
    
    // Track for Silvally - Brave Buddies
    const pkForSilvally = owner === 'player1' ? 'p1' : 'p2';
    if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
    globalThis.__supporterPlayedThisTurn[pkForSilvally] = true;
    console.log(`[Supporter] Marked ${pkForSilvally} as having played Supporter this turn`);
    await doEffect();
    showPopup('Supporter played');

    logEvent({
      player: owner,
      text: `Played Supporter: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });

    return;
  } else if (ttype === 'item') {
    // Try to apply effect first
    try {
      await doEffect();
      
      // Only remove from hand if effect succeeded
      addTrainerToDiscard(owner, e.target);
      removeFromHand(owner, set, num);
      renderAllHands();
      showPopup('Item played');

      logEvent({
        player: owner,
        text: `Played Item: ${meta.name}.`,
        cardSet: set,
        cardNum: num
      });
    } catch (err) {
      // Effect failed - card stays in hand
      console.log('[item] Effect failed:', err.message);
      showPopup(err.message || 'Cannot use this Item right now.');
    }

    return;
  } else if (ttype === 'tool') {
    toolAttachPending = { owner, set, num, src: e.target.src };
    showPopup('Select a Pok√©mon in play to attach this Tool.');

    logEvent({
      player: owner,
      text: `Played Tool: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });

    return;
  } else {
    showPopup('Unknown Trainer type.');
    return;
  }
}

/* evolution */
if (meta && meta.evolveFrom) {
  isEvoMode = true;
  evoMeta = meta;
  evoOwner = owner;
  evoHandCard = e.target;
  
  let glow = 0;
  const evolveFromLower = String(meta.evolveFrom).toLowerCase();
  
  // üÜï Fossil mapping - fossils count as their Pokemon for evolution
  const FOSSIL_MAP = {
    'helix fossil': 'omanyte',
    'dome fossil': 'kabuto',
    'old amber': 'aerodactyl',
    'skull fossil': 'cranidos',
    'armor fossil': 'shieldon'
  };
  
  $$('#' + owner + ' .active img, #' + owner + ' .bench img').forEach(img => {
    const cardNameLower = (img.alt || '').toLowerCase();
    
    // Check normal evolution (name includes evolveFrom)
    let matches = cardNameLower.includes(evolveFromLower);
    
    // üÜï Check if this is a fossil that matches the evolveFrom
    if (!matches && FOSSIL_MAP[cardNameLower]) {
      const fossilPokemon = FOSSIL_MAP[cardNameLower];
      matches = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
    }
    
    // üÜï A3b - Eevee ex special evolution rule (can evolve into any Eeveelution)
    if (!matches && cardNameLower.includes('eevee ex')) {
      const EEVEELUTIONS = [
        'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
        'leafeon', 'glaceon', 'sylveon'
      ];
      
      const evoCardName = (meta.name || '').toLowerCase();
      if (EEVEELUTIONS.some(e => evoCardName.includes(e))) {
        matches = true;
        console.log('[Veevee \'volve] Eevee ex can evolve into', meta.name);
      }
    }
    
    if (matches) {
      img.classList.add('glow-evo');
      glow++;
    }
  });
  
  if (glow === 0) {
    showPopup(`No valid ${meta.evolveFrom} to evolve.`);
    isEvoMode = false;
    return;
  }
  
  showPopup(`Select ${meta.evolveFrom} to evolve.`);
  return;
}

/* basic placement */
if (!(meta && String(meta.category || '').toLowerCase() === 'pokemon' &&
     String(meta.stage || '').toLowerCase() === 'basic')) {
  showPopup('Only Basic Pok√©mon can be placed.');
  return;
}

const clone = e.target.cloneNode(true);
clone.dataset.playedTurn = globalThis.turnNumber;
  
  // Assign unique instance ID for ability tracking
  if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
  clone.dataset.instanceId = ++window.pokemonInstanceCounter;
  console.log('[INSTANCE] Assigned instanceId:', clone.dataset.instanceId, 'to', clone.alt || 'Unknown Pokemon');
clone.dataset.set = set;
clone.dataset.num = num;

const act = owner === 'player1' ? p1Active : p2Active;
const bench = owner === 'player1' ? p1Bench : p2Bench;

let placedTo = 'bench';

if (!act.querySelector('img')) {
  const slot = act.querySelector('.card-slot');
  slot.innerHTML = '';
  slot.appendChild(clone);
  markSlot(slot, true);
  placedTo = 'active';
  
  // Update player background when active Pokemon is placed during setup
  const playerNum = owner === 'player1' ? 1 : 2;
  updatePlayerTypeBackground(playerNum);
} else {
  // Find truly empty bench slot (no img element)
  const empty = [...bench.querySelectorAll('.card-slot')].find(s => !s.querySelector('img'));
  if (!empty) {
    showPopup('Bench full.');
    return;
  }
  empty.innerHTML = '';
  empty.appendChild(clone);
  markSlot(empty, true);
  placedTo = 'bench';
}

removeFromHand(owner, set, num);

try {
  const baseHp = parseInt(meta.hp || '0', 10) || 0;
  setHpOnImage(clone, baseHp, baseHp);
} catch {}

renderAllHands();

logEvent({
  player: owner,
  text: `Played Basic Pok√©mon to ${placedTo === 'active' ? 'Active' : 'Bench'}: ${meta.name}.`,
  cardSet: set,
  cardNum: num
});
  // ... rest of your hand interaction code ...
});

/* ========================================
   DEBUG: Add Logging to showAttackMenuFor
======================================== */

// Find your showAttackMenuFor function and add console.logs:
// PTCGL-Style Attack Menu JavaScript
// Replace your existing showAttackMenuFor function with this

// PTCGL-Style Attack Menu - CORRECT VERSION
// Attacks/Abilities overlay ON TOP of the card

// PTCGL-Style Attack Menu - FINAL VERSION
// All requirements met

function showAttackMenuFor(cardImg, meta) {
  console.log('[MENU] showAttackMenuFor called, isRetreatSelection:', isRetreatSelection);
  console.log('[MENU] cardImg instanceId:', cardImg?.dataset.instanceId);
  
  // Don't open menu during retreat selection
  if (isRetreatSelection) {
    console.log('[attack-menu] Blocked - retreat selection in progress');
    return;
  }
  
  console.log('[MENU] Opening menu...');
  closeAttackMenu();

  const slot = cardImg.closest('.card-slot');

  if (!slot || !cardImg || !meta) {
    return;
  }

  // Get activeDiv from cardImg for functions that need it
  const activeDiv = cardImg.closest('.active, .bench');
  
  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';
  const ownerKey = pk;  // Use p1/p2 for consistency with turn reset
  console.log('[PTCGL-OWNER] ownerKey:', ownerKey, '(currentPlayer:', currentPlayer + ')');
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const cardSet = cardImg.dataset.set;
  const cardNum = cardImg.dataset.num;
  const type0 = ((meta.types && meta.types[0]) || 'colorless').toLowerCase();
  console.log('[PTCGL Menu] Card type:', type0, 'from meta.types:', meta.types);

  // NO backdrop - requirement #5

  // Get card slot FIRST (needed for multiple purposes below)
  const cardSlot = cardImg.closest('.card-slot');

  // Create main menu container
  const menu = document.createElement('div');
  menu.className = 'attack-menu ptcgl-style';
  
  // Check if this menu is opening right after a retreat
  // Use longer delay if retreat happened within last 1000ms
  const timeSinceRetreat = Date.now() - lastRetreatTime;
  const delayForRetreat = (isRetreatSelection || timeSinceRetreat < 1000) ? 500 : 100;
  console.log('[MENU] Time since last retreat:', timeSinceRetreat, 'ms, delay:', delayForRetreat, 'ms');
  
  // Click anywhere to close
  menu.addEventListener('click', (e) => {
    if (e.target === menu) {
      closeAttackMenu();
    }
  });
  
  // Mark the card slot as having menu open
  if (cardSlot) {
    cardSlot.classList.add('menu-open');
  }

  // Create card container
  const cardContainer = document.createElement('div');
  cardContainer.className = 'ptcgl-card-container';
  cardContainer.style.position = 'relative'; // Allow absolute positioning for tool

  // Card image
  const cardImgClone = document.createElement('img');
  cardImgClone.src = cardImg.src;
  cardImgClone.alt = meta.name || 'Pokemon';
  cardContainer.appendChild(cardImgClone);
  
  // üÜï Add tool THUMBNAIL if tool is attached
  const toolData = getToolDataFromSlot(cardSlot);
  if (toolData && toolData.src) {
    const toolThumb = document.createElement('img');
    toolThumb.src = toolData.src;
    toolThumb.alt = 'Tool';
    toolThumb.style.cssText = `
      position: absolute;
      top: 120px;
      left: 8px;
      width: 80px;
      height: 112px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,.6);
      border: 1px solid #6e4e9c;
      background-color: #0b0f14;
      z-index: 10;
      object-fit: cover;
      object-position: center 15%;
      clip-path: inset(15% 5% 45% 5%);
      pointer-events: none;
    `;
    cardContainer.appendChild(toolThumb);
  }

  // Close button - SMALL, OUTSIDE card (#1)
  const closeBtn = document.createElement('button');
  closeBtn.className = 'ptcgl-close-btn';
  closeBtn.innerHTML = '√ó';
  closeBtn.addEventListener('click', () => {
    // Animate back to card position
    const cardRect = cardImg.getBoundingClientRect();
    const returnX = cardRect.left + cardRect.width / 2;
    const returnY = cardRect.top + cardRect.height / 2;
    
    menu.style.transition = 'all 0.25s ease-in';
    menu.style.left = returnX + 'px';
    menu.style.top = returnY + 'px';
    menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
    menu.style.opacity = '0';
    
    setTimeout(() => {
      closeAttackMenu();
    }, 500);  // Increased from 250ms to prevent immediate close during retreat
  });
  cardContainer.appendChild(closeBtn);

  // HP + Type combined bar (#2 & #3)
  // Check for Giant Cape or other max HP modifiers
  const modifiedMaxHp = cardSlot?.dataset.maxHp ? parseInt(cardSlot.dataset.maxHp, 10) : null;
  const baseHp = parseInt(cardImg.dataset.hp || meta.hp || '0', 10);
  const maxHp = modifiedMaxHp || baseHp;
  const chp = parseInt(cardImg.dataset.chp || maxHp || '0', 10);
  
  const hpTypeBar = document.createElement('div');
  hpTypeBar.className = 'ptcgl-hp-type-bar';
  
  // Make HP green if Giant Cape is attached
  const hpStyle = modifiedMaxHp ? 'color: #22c55e; font-weight: 700;' : '';
  
  hpTypeBar.innerHTML = `
    <span class="ptcgl-hp-number" style="${hpStyle}">${chp} / ${maxHp}</span>
    <div class="ptcgl-type-icon-inline" style="background-image: url('${energyIconUrl(type0)}')"></div>
  `;
  cardContainer.appendChild(hpTypeBar);

  // Energy pips - show attached energy from the card (cardSlot already declared above)
  const energyPipsContainer = document.createElement('div');
  energyPipsContainer.className = 'ptcgl-energy-pips';
  
  console.log('[energy-pips] cardSlot:', cardSlot);
  
  if (cardSlot) {
    const energyBox = cardSlot.querySelector('.energy-pips');
    console.log('[energy-pips] energyBox found:', energyBox);
    
    if (energyBox) {
      const energyPips = energyBox.querySelectorAll('.energy-pip');
      console.log('[energy-pips] Found', energyPips.length, 'energy pips');
      
      energyPips.forEach(pip => {
        const pipClone = document.createElement('div');
        pipClone.className = 'ptcgl-energy-pip';
        const energyType = pip.dataset.type || 'colorless';
        pipClone.style.backgroundImage = `url('${energyIconUrl(energyType)}')`;
        pipClone.dataset.type = energyType;
        energyPipsContainer.appendChild(pipClone);
        console.log('[energy-pips] Added pip:', energyType);
      });
    }
  }
  
  if (energyPipsContainer.children.length > 0) {
    console.log('[energy-pips] Appending', energyPipsContainer.children.length, 'pips to card');
    cardContainer.appendChild(energyPipsContainer);
  } else {
    console.log('[energy-pips] No energy pips to display');
  }

  // Actions overlay container (bottom of card)
  const actionsOverlay = document.createElement('div');
  actionsOverlay.className = 'ptcgl-actions-overlay';

  // ABILITIES (if exists) - Show ALL abilities (active + passive)
  
  // Find ALL abilities for this card (not just active)
  const allAbilityRows = abilityRows.filter(r => {
    const matches = r.set === cardSet &&
      String(r.number).padStart(3, '0') === String(cardNum).padStart(3, '0');
    
    return matches;
  });

  // Display each ability
  allAbilityRows.forEach(abilityRow => {
    const isPassive = abilityRow.abilityType === 'passive';
    
    // Check if this is an unlimited ability
    const isUnlimited = 
      (abilityRow.param2 && abilityRow.param2.toLowerCase() === 'unlimited') ||
      (abilityRow.text && /as often as you like/i.test(abilityRow.text));
    
    const usedMap = window.usedAbilitiesThisTurn;
    usedMap[ownerKey] = usedMap[ownerKey] || {};
    
    // Use the cardImg that was passed in (has correct instance ID)
    const pokemonImg = cardImg;
    const cardKey = getAbilityCardKey(abilityRow.set, abilityRow.number, pokemonImg);
    const alreadyUsed = !isUnlimited && !!usedMap[ownerKey][cardKey];

    const abilityBox = document.createElement('div');
    abilityBox.className = 'ptcgl-ability-overlay';
    
    // Add type class for background color
    const pokemonType = (type0 || 'colorless').toLowerCase();
    abilityBox.classList.add(`type-${pokemonType}`);
    
    // Style passive abilities differently
    if (isPassive) {
      abilityBox.classList.add('passive-ability');
      abilityBox.style.opacity = '1';  // Keep full opacity
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.cursor = 'default';
    } else if (alreadyUsed) {
      abilityBox.classList.add('used');
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.opacity = '0.5';
      abilityBox.style.cursor = 'not-allowed';
    }

    const abilityHeader = document.createElement('div');
    abilityHeader.className = 'ptcgl-ability-header';
    
    const abilityLeft = document.createElement('div');
    abilityLeft.className = 'ptcgl-ability-left';
    
    // Show "PASSIVE" label for passive abilities
    const labelText = isPassive ? 'PASSIVE' : 'ABILITY';
    abilityLeft.innerHTML = `
      <img src="${ABILITY_BADGE}" style="width:60px"  />      
      <span class="ptcgl-ability-name">${abilityRow.abilityName || 'Ability'}</span>
    `;
    
    abilityHeader.appendChild(abilityLeft);
    abilityBox.appendChild(abilityHeader);
    
    const abilityText = document.createElement('div');
    abilityText.className = 'ptcgl-ability-text';
    abilityText.textContent = abilityRow.text || '';
    abilityBox.appendChild(abilityText);
    
    // Only add click handler for ACTIVE abilities
    if (!isPassive && !alreadyUsed) {
      abilityBox.addEventListener('click', async (e) => {
        e.stopPropagation();
        e.preventDefault();
        
        // Double-check if already used (but allow unlimited)
        if (!isUnlimited && usedMap[ownerKey]?.[cardKey]) {
          showPopup('This ability has already been used this turn.');
          return;
        }
        
        // Only mark as used if NOT unlimited
        if (!isUnlimited) {
          if (!usedMap[ownerKey]) usedMap[ownerKey] = {};
          usedMap[ownerKey][cardKey] = true;
          
          // Gray out the ability box immediately
          abilityBox.classList.add('used');
          abilityBox.style.pointerEvents = 'none';
          abilityBox.style.opacity = '0.5';
          abilityBox.style.cursor = 'not-allowed';
        }
        
        // Set flag to prevent menu from reopening
        abilityJustUsed = true;
        
        // Close menu BEFORE applying effect
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
        }
        
        // Small delay to ensure menu is closed before effect
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Apply the ability effect with source Pokemon image (use captured reference)
        await applyAbilityEffect(abilityRow, ownerKey, pokemonImg);
        
        // Clear flag after a delay
        setTimeout(() => {
          abilityJustUsed = false;
        }, 300);
      });
    }

    actionsOverlay.appendChild(abilityBox);
  });

  // FOSSIL DISCARD OPTION - Fossils have no attacks, only "Discard"
  const isFossil = cardImg.dataset.isFossil === 'true';
  
  if (isFossil) {
    // Create discard button for fossil
    const discardBox = document.createElement('div');
    discardBox.className = 'ptcgl-attack-overlay payable';
    discardBox.classList.add('type-colorless'); // Fossils are colorless
    
    const discardHeader = document.createElement('div');
    discardHeader.className = 'ptcgl-attack-header';
    
    const discardLeft = document.createElement('div');
    discardLeft.className = 'ptcgl-attack-left';
    
    const discardName = document.createElement('span');
    discardName.className = 'ptcgl-attack-name type-colorless';
    discardName.textContent = 'Discard';
    
    discardLeft.appendChild(discardName);
    discardHeader.appendChild(discardLeft);
    discardBox.appendChild(discardHeader);
    
    const discardEffect = document.createElement('div');
    discardEffect.className = 'ptcgl-attack-effect';
    discardEffect.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    discardBox.appendChild(discardEffect);
    
    // Click handler for discard
    discardBox.addEventListener('click', async () => {
      closeAttackMenu();
      
      // Discard the fossil
      const isActive = !!cardImg.closest('#p1Active, #p2Active');
      
      // Move to discard pile
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(cardImg, pk, false); // false = no point given
      } else {
        // Fallback: just remove the card
        slot.innerHTML = '';
        globalThis.markSlot?.(slot, false);
      }
      
      showPopup(`${meta.name} was discarded.`);
      
      // If it was active, promote from bench
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          // Bench out!
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pok√©mon left!');
          return;
        }
        
        // Promote from bench - pk is the fossil owner
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); // pk = fossil owner (p1 or p2)
        }
      }
    });
    
    actionsOverlay.appendChild(discardBox);
  }

  // ATTACKS - (#4 - type-colored names, #7 - should work)
  const attacks = meta.attacks || [];
  attacks.forEach(atk => {
    // üÜï A2 MOVE EFFECT - Check if this specific attack is locked
    const isLocked = cardImg.dataset.lockedAttack === atk.name;
    
    const pips = countPipsOn(slot);
    const canPay = !isLocked && canPayCostFromAPI(slot, atk.cost || [], cardImg);

    const attackBox = document.createElement('div');
    attackBox.className = 'ptcgl-attack-overlay';
    
    // Add locked class if attack is blocked
    if (isLocked) {
      attackBox.classList.add('locked');
      attackBox.style.opacity = '0.5';
      attackBox.style.cursor = 'not-allowed';
    }
    
    // Add Pokemon type class for coloring
    const pokemonType = (type0 || 'colorless').toLowerCase();
    attackBox.classList.add('type-' + pokemonType);
    
    if (canPay) attackBox.classList.add('payable');

    // Create cost icons with CORRECT energy types
    const costHTML = (atk.cost || []).map(energyType => {
      const type = String(energyType).toLowerCase();
      return `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl(type)}')"></div>`;
    }).join('');

    const attackHeader = document.createElement('div');
    attackHeader.className = 'ptcgl-attack-header';
    
    const attackLeft = document.createElement('div');
    attackLeft.className = 'ptcgl-attack-left';
    
    const attackName = document.createElement('span');
    attackName.className = 'ptcgl-attack-name';
    attackName.textContent = atk.name || 'Attack';
    
    // #4 - Color attack name based on type if payable
    if (canPay) {
      attackName.classList.add(`type-${type0.toLowerCase()}`);
    }
    
    // Left side: name and cost
    const attackInfo = document.createElement('div');
    attackInfo.style.display = 'flex';
    attackInfo.style.alignItems = 'center';
    attackInfo.style.gap = '6px';
    
    attackInfo.appendChild(attackName);
    
    const attackCost = document.createElement('div');
    attackCost.className = 'ptcgl-attack-cost';
    attackCost.innerHTML = costHTML;
    attackInfo.appendChild(attackCost);
    
    attackLeft.appendChild(attackInfo);
    
    // Right side: damage
    const damageBox = document.createElement('div');
    damageBox.className = 'ptcgl-attack-damage-box';
    
    const attackDamage = document.createElement('span');
    attackDamage.className = 'ptcgl-attack-damage';
    attackDamage.textContent = atk.damage || '';
    damageBox.appendChild(attackDamage);
    
    attackLeft.appendChild(damageBox);
    
    attackHeader.appendChild(attackLeft);
    
    attackBox.appendChild(attackHeader);

    if (atk.effect) {
      const attackEffect = document.createElement('div');
      attackEffect.className = 'ptcgl-attack-effect';
      attackEffect.textContent = atk.effect;
      attackBox.appendChild(attackEffect);
    }

    // #7 - Attack should actually work
    if (canPay) {
      attackBox.addEventListener('click', () => {
        handleAttackClick(atk, meta, ownerKey, activeDiv);
        closeAttackMenu();
      });
    }

    actionsOverlay.appendChild(attackBox);
  });

  // Add actions overlay to card
  cardContainer.appendChild(actionsOverlay);

  // RETREAT - bottom right corner ONLY (#6)
  // Fossils cannot retreat!
  const retreatCost = computeRetreatCost(activeDiv, meta);
  const pips = countPipsOn(slot);
  
  // Check if retreat is allowed (considering status, locks, etc.)
  // pk already declared above, reuse it
  const retreatAllowed = typeof canRetreat === 'function' ? canRetreat(pk) : true;
  const canPayCost = !isFossil && pips.total >= retreatCost && !hasRetreatedThisTurn;
  const canRetreatFinal = retreatAllowed && canPayCost;

  const retreatCorner = document.createElement('div');
  retreatCorner.className = 'ptcgl-retreat-corner';
  if (!canRetreatFinal) retreatCorner.classList.add('disabled');
  
  // Show "Can't Retreat" for fossils
  if (isFossil) {
    retreatCorner.title = "Fossils cannot retreat";
  }
  
  // Show appropriate message for sleep/paralysis
  if (!retreatAllowed && !isFossil) {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      retreatCorner.title = "Can't retreat - Pok√©mon is asleep";
    } else if (st === 'paralyzed') {
      retreatCorner.title = "Can't retreat - Pok√©mon is paralyzed";
    } else {
      retreatCorner.title = "Can't retreat - Pok√©mon is locked";
    }
  }
  
  // Add type-based coloring if retreat is available
  if (canRetreatFinal) {
    const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
    if (mainType) {
      retreatCorner.setAttribute('data-type', mainType);
      console.log('[RETREAT CORNER] Set data-type:', mainType);
    }
  }

  const costIcons = Array(retreatCost).fill(0).map(() => 
    `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl('colorless')}')"></div>`
  ).join('');

  retreatCorner.innerHTML = `
    <div class="ptcgl-retreat-label">Retreat</div>
    <div class="ptcgl-retreat-cost">${costIcons}</div>
    <div class="ptcgl-retreat-icon">‚Ü©</div>
  `;

  // #7 - Retreat should work
  if (canRetreatFinal) {
    retreatCorner.addEventListener('click', () => {
      handleRetreat(activeDiv, meta, retreatCost);
      // Note: handleRetreat closes menu internally, no need to close again
    });
  }

  cardContainer.appendChild(retreatCorner);

  // Weakness corner (optional - bottom left)
  if (meta.weaknesses && meta.weaknesses.length > 0) {
    const wk = meta.weaknesses[0];
    const wkType = String(wk.type || '').toLowerCase();
    const weaknessCorner = document.createElement('div');
    weaknessCorner.className = 'ptcgl-weakness-corner';
    weaknessCorner.innerHTML = `
      <span class="ptcgl-weakness-label">WEAKNESS</span>
      <div class="ptcgl-weakness-icon" style="background-image: url('${energyIconUrl(wkType)}')"></div>
      <span class="ptcgl-weakness-value">√ó${wk.value || '2'}</span>
    `;
    cardContainer.appendChild(weaknessCorner);
  }

  menu.appendChild(cardContainer);

  // Append to body
  document.body.appendChild(menu);

  // Click outside menu to close with shrink animation
  setTimeout(() => {
    const closeOnClickOutside = (e) => {
      if (!menu.contains(e.target)) {
        if (abilityJustUsed) {
          console.log('[MENU-CLOSE] Blocked close - ability just used');
          return;
        }
        
        document.removeEventListener('click', closeOnClickOutside);
        
        // Animate back to card position (same as close button)
        const cardRect = cardImg.getBoundingClientRect();
        const returnX = cardRect.left + cardRect.width / 2;
        const returnY = cardRect.top + cardRect.height / 2;
        
        menu.style.transition = 'all 0.25s ease-in';
        menu.style.left = returnX + 'px';
        menu.style.top = returnY + 'px';
        menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
        menu.style.opacity = '0';
        
        setTimeout(() => {
          closeAttackMenu();
        }, 250);
      }
    };
    
    // Store reference to listener so it can be removed later
    menu._clickOutsideHandler = closeOnClickOutside;
    document.addEventListener('click', closeOnClickOutside);
    console.log('[MENU] Added closeOnClickOutside listener');
  }, delayForRetreat);  // Variable delay

  // Get card's starting position for animation
  const cardRect = cardImg.getBoundingClientRect();
  const startX = cardRect.left + cardRect.width / 2;
  const startY = cardRect.top + cardRect.height / 2;
  
  // Calculate target position in pixels (30% from left)
  const targetX = window.innerWidth * 0.30;
  const targetY = window.innerHeight * 0.50;
  
  // Set initial position to card's location
  menu.style.left = startX + 'px';
  menu.style.top = startY + 'px';
  menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
  menu.style.opacity = '0';
  
  // Animate DIRECTLY to left position
  requestAnimationFrame(() => {
    menu.style.transition = 'all 0.3s ease-out';
    menu.classList.add('show');
    
    // After a frame, move DIRECTLY to final position (no intermediate)
    requestAnimationFrame(() => {
      menu.style.left = targetX + 'px';
      menu.style.top = targetY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(1)';
      menu.style.opacity = '1';
    });
  });

  openAttackMenu = menu;
  
  // Add escape key handler (#2)
  const escapeHandler = (e) => {
    if (e.key === 'Escape') {
      // Animate back to card position
      const cardRect = cardImg.getBoundingClientRect();
      const returnX = cardRect.left + cardRect.width / 2;
      const returnY = cardRect.top + cardRect.height / 2;
      
      menu.style.transition = 'all 0.25s ease-in';
      menu.style.left = returnX + 'px';
      menu.style.top = returnY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
      menu.style.opacity = '0';
      
      setTimeout(() => {
        closeAttackMenu();
        document.removeEventListener('keydown', escapeHandler);
      }, 250);
    }
  };
  document.addEventListener('keydown', escapeHandler);
  menu._escapeHandler = escapeHandler;
}






/**
 * Apply type-based colors to attack menu items
 * @param {string} type - Pokemon type (e.g., 'psychic', 'fire', 'grass')
 */
function applyTypesToAttackMenu(type) {
  if (!type) return;
  
  const typeLower = type.toLowerCase();
  
  // Apply to ability rows
  const abilityRows = document.querySelectorAll('.attack-ability-row');
  abilityRows.forEach(row => {
    row.setAttribute('data-type', typeLower);
  });
  
  const abilityWrappers = document.querySelectorAll('.attack-ability-wrapper');
  abilityWrappers.forEach(wrapper => {
    wrapper.setAttribute('data-type', typeLower);
  });
  
  // Apply to attack items
  const attackItems = document.querySelectorAll('.attack-item');
  attackItems.forEach(item => {
    item.setAttribute('data-type', typeLower);
  });
}

// Expose to global
globalThis.isActiveBlockedFromAttacking = isActiveBlockedFromAttacking;

/* ========================================
   DEBUG: Check What's Preventing Clicks
======================================== */

// Add this temporarily to see what's blocking:
console.log('[debug] Click handler state:', {
  currentPlayer,
  isEvoMode,
  toolAttachPending,
  selectedEnergy,
  isPromotionPhase,
  gameOver
});

const zoomStatus = document.getElementById("zoomStatus");

/* evolution click */
document.body.addEventListener('click',async e=>{
  if(!isEvoMode)return;
  const target=e.target.closest('img.glow-evo');
  if(!target)return;
  e.stopPropagation();
  await evolveCard(target,evoMeta,evoHandCard,evoOwner,evoHandCard.dataset.set,evoHandCard.dataset.num);
  clearGlow();
});
/* promotion helpers: attachments follow their Pok√©mon */
/* ========================================
   ABILITY HELPER FUNCTIONS
======================================== */

// Global ability cache for faster synchronous lookups
globalThis.abilityCache = {};

// Populate ability cache when abilities are loaded
async function populateAbilityCache() {
  if (!window.ABILITY_EFFECT_ROWS) {
    console.log('[ability-cache] ABILITY_EFFECT_ROWS not yet loaded');
    return false;
  }
  
  globalThis.abilityCache = {}; // Clear before repopulating
  
  for (const row of window.ABILITY_EFFECT_ROWS) {
    const set = row.set;
    const num = row.number;
    
    // Store under multiple formats to handle both "009" and "9"
    const keyPadded = `${set}-${num}`; // e.g., "A2a-009"
    const keyUnpadded = `${set}-${parseInt(num, 10)}`; // e.g., "A2a-9"
    
    globalThis.abilityCache[keyPadded] = row;
    globalThis.abilityCache[keyUnpadded] = row;
  }
  console.log('[ability-cache] Populated with', Object.keys(globalThis.abilityCache).length, 'abilities (with multiple key formats)');
  console.log('[ability-cache] Sample keys:', Object.keys(globalThis.abilityCache).slice(0, 10));
  return true;
}

// Call this after abilities are loaded - with retry mechanism
if (window.ABILITY_EFFECT_ROWS) {
  populateAbilityCache();
} else {
  console.log('[ability-cache] Will retry population...');
  // Retry every 500ms for up to 10 seconds
  let retries = 0;
  const maxRetries = 20;
  const retryInterval = setInterval(() => {
    retries++;
    if (populateAbilityCache()) {
      clearInterval(retryInterval);
    } else if (retries >= maxRetries) {
      console.warn('[ability-cache] Failed to load after', maxRetries, 'retries');
      clearInterval(retryInterval);
    }
  }, 500);
}

// Expose for manual population
globalThis.populateAbilityCache = populateAbilityCache;

// Helper: Check if player has Arceus or Arceus ex in play
function hasArceusInPlay(pk) {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
  
  const activeImg = activeDiv ? activeDiv.querySelector('img') : null;
  const benchImgs = benchDiv ? [...benchDiv.querySelectorAll('img')] : [];
  
  const allPokemon = [activeImg, ...benchImgs].filter(Boolean);
  
  const hasArceus = allPokemon.some(img => {
    const name = (img.alt || '').toLowerCase();
    return name.includes('arceus');
  });
  
  console.log(`[arceus-check-battle] Player ${pk} has ${allPokemon.length} Pokemon`);
  console.log(`[arceus-check-battle] Pokemon names:`, allPokemon.map(img => img.alt));
  console.log(`[arceus-check-battle] Has Arceus: ${hasArceus}`);
  
  return hasArceus;
}

// Expose to effects.js
globalThis.hasArceusInPlay = hasArceusInPlay;

// Helper: Get ability row for a Pokemon (async)
globalThis.getAbilityRow = async function(set, num) {
  const key = `${set}-${num}`;
  if (globalThis.abilityCache && globalThis.abilityCache[key]) {
    return globalThis.abilityCache[key];
  }
  
  // Fallback: search in ABILITY_EFFECT_ROWS
  if (!window.ABILITY_EFFECT_ROWS) return null;
  
  const numPadded = String(num || '').padStart(3, '0');
  const row = window.ABILITY_EFFECT_ROWS.find(r =>
    r.set === set && String(r.number).padStart(3, '0') === numPadded
  );
  
  return row || null;
};

function getPassiveDamageReduction(pk) {
  const img = getActiveImg(pk);
  if (!img) return 0;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = img.dataset.set;
  const numId = String(img.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'reduce_incoming_damage'
  );
  
  if (row) {
    return parseInt(row.param1 || '0', 10);
  }
  
  return 0;
}

function shouldBlockDamageFromEx(pk, attackerImg) {
  if (!attackerImg) return false;
  
  const img = getActiveImg(pk);
  if (!img) return false;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = img.dataset.set;
  const numId = String(img.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'prevent_damage_from_ex'
  );
  
  if (row) {
    // Check if attacker is an ex Pokemon
    const attackerName = (attackerImg.alt || '').toLowerCase();
    const isEx = attackerName.includes(' ex');
    
    if (isEx) {
      console.log('[Safeguard] Blocking damage from', attackerImg.alt);
      return true;
    }
  }
  
  return false;
}

function getCounterattackDamage(pk) {
  const img = getActiveImg(pk);
  if (!img) return 0;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = img.dataset.set;
  const numId = String(img.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'counter_on_hit'
  );
  
  if (row) {
    return parseInt(row.param1 || '0', 10);
  }
  
  return 0;
}

// üÜï A2 PASSIVE ABILITY HELPERS

/**
 * Get passive ability row for a Pokemon
 */
function getPassiveAbility(pokemonImg, effectType) {
  if (!pokemonImg || !effectType) return null;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = pokemonImg.dataset.set;
  const numId = String(pokemonImg.dataset.num || '').padStart(3, '0');
  
  return abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === effectType
  ) || null;
}

/**
 * Check if Pokemon has a passive ability
 */
function checkPassiveAbility(pokemonImg, effectType) {
  return !!getPassiveAbility(pokemonImg, effectType);
}

/**
 * Get Fighting Coach damage boost for a type
 * Returns total boost amount from all Pokemon with Fighting Coach (stacks)
 */
function getFightingCoachBoost(attackerPk, attackerType) {
  if (!attackerType) return 0;
  
  const allAllies = [getActiveImg(attackerPk), ...getBenchImgs(attackerPk)].filter(Boolean);
  let totalBoost = 0;
  
  for (const ally of allAllies) {
    const coachAbility = getPassiveAbility(ally, 'boost_type_damage');
    if (coachAbility) {
      const boostedType = (coachAbility.param1 || '').toLowerCase();
      const boost = parseInt(coachAbility.param2 || '0', 10);
      
      if (attackerType.toLowerCase() === boostedType) {
        console.log(`[Fighting Coach] ${ally.alt} boosting ${attackerType} by +${boost}`);
        totalBoost += boost;
      }
    }
  }
  
  if (totalBoost > 0) {
    console.log(`[Fighting Coach] Total boost: +${totalBoost}`);
  }
  
  return totalBoost;
}

/**
 * Calculate damage reduction from Thick Fat
 * Checks if defender has Thick Fat and attacker is Fire/Water type
 */
function getThickFatReduction(defenderImg, attackerType) {
  if (!defenderImg || !attackerType) return 0;
  
  const thickFat = getPassiveAbility(defenderImg, 'reduce_damage_from_types');
  if (!thickFat) return 0;
  
  const reducedTypes = (thickFat.param1 || '').split(';');
  const reduction = parseInt(thickFat.param2 || '0', 10);
  
  if (reducedTypes.includes(attackerType.toLowerCase())) {
    console.log(`[Thick Fat] Reducing ${reduction} damage from ${attackerType}`);
    return reduction;
  }
  
  return 0;
}

/**
 * Apply Guarded Grill flip reduction
 * Flips coin, if heads reduces damage by 100
 */
function applyGuardedGrill(defenderImg, baseDamage) {
  if (!defenderImg || baseDamage <= 0) return baseDamage;
  
  const grill = getPassiveAbility(defenderImg, 'flip_reduce_damage');
  if (!grill) return baseDamage;
  
  const reduction = parseInt(grill.param1 || '0', 10);
  const flip = Math.random() < 0.5;
  
  console.log(`[Guarded Grill] Flipped: ${flip ? 'Heads' : 'Tails'}`);
  
  if (flip) {
    const newDamage = Math.max(0, baseDamage - reduction);
    showPopup(`Guarded Grill: Heads! Reduced ${reduction} damage.`);
    return newDamage;
  } else {
    showPopup(`Guarded Grill: Tails! No reduction.`);
    return baseDamage;
  }
}

/**
 * Check if defender has Crystal Body (blocks attack effects)
 */
function hasCrystalBody(defenderImg) {
  return checkPassiveAbility(defenderImg, 'block_attack_effects');
}

/**
 * Check if Pokemon has Levitate and should have zero retreat cost
 */
function hasLevitateZeroRetreat(pokemonImg) {
  if (!pokemonImg) return false;
  
  const levitate = getPassiveAbility(pokemonImg, 'zero_retreat_if_energy');
  if (!levitate) return false;
  
  // Check if has any energy
  const slot = pokemonImg.closest('.card-slot');
  if (!slot) return false;
  
  const energyBox = slot.querySelector('.energy-pips');
  const hasEnergy = energyBox && energyBox.querySelectorAll('.energy-pip').length > 0;
  
  if (hasEnergy) {
    console.log(`[Levitate] ${pokemonImg.alt} has energy - retreat cost = 0`);
    return true;
  }
  
  return false;
}

/**
 * Trigger Nightmare Aura when attaching Dark energy
 */
function triggerNightmareAura(pokemonImg, energyType) {
  if (!pokemonImg || !energyType) return;
  
  const aura = getPassiveAbility(pokemonImg, 'damage_on_energy_attach');
  if (!aura) return;
  
  const triggerType = (aura.param1 || '').toLowerCase();
  const damage = parseInt(aura.param2 || '0', 10);
  
  if (energyType.toLowerCase() === triggerType) {
    console.log(`[Nightmare Aura] Triggered! Dealing ${damage} damage`);
    
    // Damage opponent's active Pokemon
    const ownerDiv = pokemonImg.closest('#player1, #player2');
    const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
    const opponent = owner === 'player1' ? 'player2' : 'player1';
    
    setTimeout(async () => {
      const result = await damageActiveOf(opponent, damage, { isDirectAttack: false });
      showPopup(`Nightmare Aura: ${damage} damage!`);
      
      // Check if Nightmare Aura KO'd the opponent
      if (result.knocked && typeof handleKnockOut === 'function') {
        console.log('[nightmare-aura] Opponent knocked out by Nightmare Aura!');
        const oppImg = getActiveImage(opponent);
        if (oppImg) {
          const gameEnded = await handleKnockOut(opponent, oppImg, true);
          if (!gameEnded && typeof beginPromotionFlow === 'function') {
            beginPromotionFlow(opponent);
          }
        }
      }
    }, 300);
  }
}

function isGengarBlocking(player) {
  const opp = player === 'player1' ? 'player2' : 'player1';
  const oppActiveImg = getActiveImage(opp);
  
  if (!oppActiveImg) return false;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = oppActiveImg.dataset.set;
  const numId = String(oppActiveImg.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'block_supporters'
  );
  
  return !!row;
}

// Expose to global
globalThis.getActiveImg = getActiveImg;
globalThis.getPassiveDamageReduction = getPassiveDamageReduction;
globalThis.getCounterattackDamage = getCounterattackDamage;
globalThis.isGengarBlocking = isGengarBlocking;

function detachAttachments(slot){
  if (!slot) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null };
  const energy    = slot.querySelector('.energy-pips');
  const hp        = slot.querySelector('.hp-overlay');
  const toolThumb = slot.querySelector('.tool-thumb');

  if (energy)    energy.remove();
  if (hp)        hp.remove();
  if (toolThumb) toolThumb.remove();

  const toolData = getToolDataFromSlot(slot);
  if (toolData) setToolDataOnSlot(slot, null);
  
  // Also detach maxHp data (for Giant Cape / Leaf Cape)
  const maxHp = slot.dataset.maxHp || null;
  if (maxHp) delete slot.dataset.maxHp;

  return { energy, hp, toolThumb, toolData, maxHp };
}
globalThis.detachAttachments = detachAttachments;

function attachAttachments(slot, pack){
  if (!slot || !pack) return;
  const { energy, hp, toolThumb, toolData, maxHp } = pack;
  if (energy)    slot.appendChild(energy);
  if (hp)        slot.appendChild(hp);
  if (toolThumb) slot.appendChild(toolThumb);
  if (toolData)  setToolDataOnSlot(slot, toolData);
  
  // Restore maxHp data (for Giant Cape / Leaf Cape)
  if (maxHp) {
    slot.dataset.maxHp = maxHp;
  } else {
    // Make sure maxHp is cleared if it wasn't in the pack
    delete slot.dataset.maxHp;
  }
}
globalThis.attachAttachments = attachAttachments;

function beginPromotionFlow(owner){
  isPromotionPhase = true;

  const benchImgs = [...benchFor(owner).querySelectorAll('img')];
  if (!benchImgs.length) {
    const foe = owner === 'player1' ? 'player2' : 'player1';
    showVictory(foe, 'Bench out');
    isPromotionPhase = false;
    return;
  }

  benchImgs.forEach(img => img.classList.add('promote-glow'));
  showPopup('Choose a Benched Pok√©mon to promote.');

  const clickOnce = (e) => {
    if (!isPromotionPhase) return;
    
    // Check if this is a forced promotion (from Sabrina/Cyrus)
    const forcedImg = globalThis.__forcedPromotion;
    let chosenImg;
    
    if (forcedImg) {
      // Forced promotion - use the specified Pokemon
      chosenImg = forcedImg;
      globalThis.__forcedPromotion = null;
    } else {
      // Normal promotion - player clicks to choose
      chosenImg = e.target.closest(`#${owner} .bench img`);
      if (!chosenImg) return;
    }

    e.stopPropagation();
    document.body.removeEventListener('click', clickOnce, true);

    const activeDiv  = activeFor(owner);
    const activeSlot = activeDiv.querySelector('.card-slot');
    const benchSlot  = chosenImg.closest('.card-slot');
    const activeImg  = activeSlot.querySelector('img');

    if (activeImg) {
      clearStatusOnImg(activeImg);
    }
    /* CASE 1 ‚Äî Active slot is empty */
    if (!activeImg) {
      const benchPack = detachAttachments(benchSlot);

      benchSlot.removeChild(chosenImg);
      activeSlot.appendChild(chosenImg);

      attachAttachments(activeSlot, benchPack);

      markSlot(activeSlot, true);
      markSlot(benchSlot, !!benchSlot.querySelector('img'));

      benchImgs.forEach(x => x.classList.remove('promote-glow'));
      isPromotionPhase = false;

      showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      // Update player background based on new active Pokemon
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
      return;
    }

    /* CASE 2 ‚Äî Swap Active <-> Bench */
    const activePack = detachAttachments(activeSlot);
    const benchPack  = detachAttachments(benchSlot);

    activeSlot.removeChild(activeImg);
    benchSlot.removeChild(chosenImg);

    activeSlot.appendChild(chosenImg);
    benchSlot.appendChild(activeImg);

    attachAttachments(activeSlot, benchPack);
    attachAttachments(benchSlot, activePack);

    markSlot(activeSlot, true);
    markSlot(benchSlot, !!benchSlot.querySelector('img'));

    benchImgs.forEach(x => x.classList.remove('promote-glow'));
    isPromotionPhase = false;

    showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      // Update player background based on new active Pokemon
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
  };

  document.body.addEventListener('click', clickOnce, true);
}

// Make core helpers visible to effects.js after their definitions
globalThis.benchFor           = benchFor;
globalThis.activeFor          = activeFor;
globalThis.beginPromotionFlow = beginPromotionFlow;
globalThis.fetchCardMeta      = fetchCardMeta;
globalThis.ENERGY_ICONS       = ENERGY_ICONS;
globalThis.attachEnergyToSlot = attachEnergyToSlot;
globalThis.energyZoneDiv      = energyZoneDiv;
globalThis.renderEnergyZone   = renderEnergyZone;
globalThis.getActiveImage     = getActiveImage;
globalThis.applyAbilityEffectFromCsv = window.applyAbilityEffectFromCsv;

// üÜï Additional exports for trainer effects
globalThis.evolveCard         = evolveCard;
globalThis.handleKnockOut     = handleKnockOut;
globalThis.damageActiveOf     = damageActiveOf;
globalThis.startTurn          = startTurn;

/* ========= TYPE-BASED BACKGROUNDS ========= */
// Update player background based on active Pok√©mon type
async function updatePlayerTypeBackground(playerNum) {
  const playerId = `player${playerNum}`;
  const playerDiv = document.getElementById(playerId);
  
  // Get the active slot for this player
  const activeDiv = playerNum === 1 ? p1Active : p2Active;
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const activeImg = activeSlot?.querySelector('img');
  
  if (!playerDiv) return;
  
  // If no active Pok√©mon, remove type class
  if (!activeImg) {
    playerDiv.className = playerDiv.className.replace(/type-\w+/g, '').trim();
    return;
  }
  
  // Get card metadata
  const set = activeImg.dataset.set;
  const num = activeImg.dataset.num;
  
  if (!set || !num) {
    playerDiv.className = playerDiv.className.replace(/type-\w+/g, '').trim();
    return;
  }
  
  try {
    // Fetch metadata using existing function
    const meta = await fetchCardMeta(set, num);
    
    // Extract type from metadata
    let pokemonType = 'colorless';
    if (meta.types && meta.types[0]) {
      pokemonType = String(meta.types[0]).toLowerCase();
    }
    
    // Remove old type classes
    playerDiv.className = playerDiv.className.replace(/type-\w+/g, '').trim();
    
    // Add new type class
    playerDiv.classList.add(`type-${pokemonType}`);
    
  } catch (error) {
    console.error('Error updating player background:', error);
    playerDiv.className = playerDiv.className.replace(/type-\w+/g, '').trim();
  }
}

globalThis.updatePlayerTypeBackground = updatePlayerTypeBackground;

function updateAllPlayerBackgrounds() {
  updatePlayerTypeBackground(1);
  updatePlayerTypeBackground(2);
}
globalThis.updateAllPlayerBackgrounds = updateAllPlayerBackgrounds;



/* ========= draws / turns ========= */
function drawOne(player){
  const d=playerState[player].deck,
        h=playerState[player].hand;
  if(!d.length) return false;
  h.push(d.shift());
  updateDeckBubbles();
  return true;
}

async function runStatusStartOfTurn(pk) {
  const img = getActiveImg(pk);
  if (!img) return;

  const status = (img.dataset.status || "").toLowerCase();

  // Paralysis: automatically clears at the start of your next turn
  if (status === "paralyzed") {
    clearStatus(pk);
    showPopup("The Active Pok√©mon is no longer paralyzed.", 1800);
  }

  // Poison/Burn are handled in runStatusBetweenTurns()
}

// Check sleep for BOTH players at the end of each turn
async function checkSleepEndOfTurn() {
  // Check both players' active Pokemon for sleep
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;
    
    const status = (img.dataset.status || "").toLowerCase();
    
    if (status === "asleep") {
      const pokemonName = img.alt || "Active Pok√©mon";
      showPopup(`${pokemonName} is asleep. Flipping coin...`, 2000);
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Show visual coin flip and wait for result
      coinEl.classList.add('flip');
      const isHeads = Math.random() < 0.5;
      const front = coinEl.querySelector('.front');
      const back = coinEl.querySelector('.back');
      
      await new Promise(resolve => setTimeout(() => {
        coinEl.classList.remove('flip');
        
        // Display correct side
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform = 'rotateY(0deg)';
          }
        }
        
        // Update result text
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
        
        resolve();
      }, 1500));
      
      if (isHeads) {
        clearStatus(pk);
        showPopup(`${pokemonName} woke up!`, 1800);
      } else {
        showPopup(`${pokemonName} is still asleep.`, 1800);
      }
      
      // Small delay between checking each player
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

async function runStatusStartOfOpponentTurn(pk) {
    const opp = pk === "p1" ? "p2" : "p1";
    const img = getActiveImg(opp);
    if (!img) return;

    const status = (img.dataset.status || "").toLowerCase();

    const base = parseInt(img.dataset.hp || 0, 10);
    let cur = parseInt(img.dataset.chp || base, 10);

    if (status === "poisoned") {
        cur = Math.max(0, cur - 10);
        setHpOverlayForImg(img, base, cur);
        showPopup("Poison deals 10 damage!");
    }

    if (status === "burned") {
        cur = Math.max(0, cur - 20);
        setHpOverlayForImg(img, base, cur);
        showPopup("Burn deals 20 damage!");

        let flip = Math.random() < 0.5 ? "heads" : "tails";
        if (flip === "heads") {
            img.dataset.status = "";
            removeStatusMarker(img);
            showPopup("Burn was healed!");
        } else {
            showPopup("Burn remains.");
        }
    }

    if (cur <= 0) {
        await handleKnockout(opp);
    }
}


async function startTurn(player) {
  // üÜï Check sleep at END of previous turn (for BOTH players)
  // This happens BEFORE the new turn officially starts
  await checkSleepEndOfTurn();
  
  // üÜï A3a/A3b - End of turn passive abilities (BEFORE turn number increments)
  // These trigger at END of the previous player's turn
  const previousPlayer = currentPlayer;
  const previousPk = previousPlayer === 'player1' ? 'p1' : 'p2';
  
  if (previousPlayer) {
    try {
      const prevActiveDiv = previousPlayer === 'player1' ? p1Active : p2Active;
      const prevBenchDiv = previousPlayer === 'player1' ? p1Bench : p2Bench;
      const prevPokemon = [
        ...(prevActiveDiv?.querySelectorAll('img') || []),
        ...(prevBenchDiv?.querySelectorAll('img') || [])
      ];
      
      // Check Snorlax ex - heal_active_end_of_turn
      const prevActiveImg = prevActiveDiv?.querySelector('img');
      if (prevActiveImg) {
        const cacheKey = `${prevActiveImg.dataset.set}-${prevActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'heal_active_end_of_turn') {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          
          if (typeof applyAbilityEffectFromCsv === 'function') {
            await applyAbilityEffectFromCsv(effectState, previousPk, abilityRow, { 
              abilityPokemon: prevActiveImg 
            });
            console.log('[Full-Mouth Manner] Healed at end of turn');
          }
        }
      }
      
      // Check Zeraora - attach_energy_end_of_first_turn (only on turn 1)
      if (globalThis.turnNumber === 1 || globalThis.turnNumber === 2) {
        for (const img of prevPokemon) {
          const cacheKey = `${img.dataset.set}-${img.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          if (abilityRow?.effect_type === 'attach_energy_end_of_first_turn') {
            const effectState = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            
            if (typeof applyAbilityEffectFromCsv === 'function') {
              await applyAbilityEffectFromCsv(effectState, previousPk, abilityRow, { 
                abilityPokemon: img 
              });
              console.log('[Thunderclap Flash] Attached energy at end of turn 1');
            }
          }
        }
      }
    } catch (err) {
      console.error('[startTurn] End of turn abilities failed:', err);
    }
  }
  
  globalThis.turnNumber++;

  logEvent({
    player,
    text: `Turn ${globalThis.turnNumber} started for ${player === 'player1' ? 'Player 1' : 'Player 2'}.`
  });

// Define pk for the CURRENT player (needed for status effects, abilities, etc.)
  const pk = player === 'player1' ? 'p1' : 'p2';
  
  // Clear Silvally supporter flag for CURRENT player (new turn)
  if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
  globalThis.__supporterPlayedThisTurn[pk] = false;
  
  // Clear effects for the PREVIOUS player (whose turn just ended)
  // previousPlayer and previousPk already declared above, reuse them
  clearExpiredEffectsOnTurnStart(previousPk);
  
  // üÜï Clear all temporary turn effects for previous player
  if (typeof clearTurnEffects === 'function') {
    // Initialize globalThis.state if it doesn't exist
    if (!globalThis.state) {
      globalThis.state = { temp: { p1: {}, p2: {} } };
    }
    clearTurnEffects(globalThis.state, previousPk);
    console.log(`[turn] Cleared turn effects for ${previousPk}`);
  }
  
  // üÜï Clear Marshadow Revenge flag for the CURRENT player
  // This clears the flag from the turn BEFORE the previous turn
  // Example: P1 turn -> P2 Pokemon KO'd -> P2 turn (can use Revenge) -> P1 turn (clear P2's flag)
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  // Clear the flag for the current player (since their opponent's turn just ended)
  if (globalThis.state.koLastTurn[pk]) {
    console.log(`[marshadow] Clearing KO flag for ${pk} at start of turn`);
    globalThis.state.koLastTurn[pk] = false;
  }

  currentPlayer = player;

  const turnLabel = `Turn ${globalThis.turnNumber} ‚Äî ${player === 'player1' ? 'Player 1' : 'Player 2'}`;

  const bar = document.createElement("div");
  bar.className = "turn-bar";
  bar.innerHTML = `
      <div class="turn-icon">${globalThis.turnNumber}</div>
      ${turnLabel}
    `;
  logEntriesDiv.appendChild(bar);

  /* ================================
     Reset turn-scoped state
  ================================= */
  hasAttachedEnergyThisTurn = false;
  selectedEnergy = null;
  hasRetreatedThisTurn = false;
  closeAttackMenu();
  hasPlayedSupporterThisTurn[player] = false;

  resetDamageBoostsFor("player1");
  resetDamageBoostsFor("player2");
  
  // Reset abilities for CURRENT player only
  // Reset only THIS player's abilities, not the whole map
  // pk already declared above at line 6577
  window.usedAbilitiesThisTurn[pk] = {};
  // REMOVED: usedAbilitiesThisTurn[pk] = {}; (was duplicate)
  console.log('[TURN] Reset abilities for:', pk);

  // Clear Giovanni boost
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.temp) globalThis.state.temp = {};
  if (!globalThis.state.temp[player]) globalThis.state.temp[player] = {};
  globalThis.state.temp[player].globalDamageBoost = 0;

  /* ================================
     Determine turn PK
  ================================= */
    if (globalThis.resetAbilityUsage) {
    globalThis.resetAbilityUsage(pk);
  }


  /* ================================
     Between-turn effects (Poison/Burn)
  ================================= */
  await runStatusBetweenTurns();

  /* ================================
     Start-of-turn effects (Sleep/Paralysis)
  ================================= */
  await runStatusStartOfTurn(pk);

  /* ================================
     Draw Phase
  ================================= */
  drawOne(player);

  /* ================================
     Update UI
  ================================= */
  renderAllHands();
  renderEnergyZone();
  updateTurnBox();

setTimeout(() => {
  showPopup(`Player ${player === 'player1' ? '1' : '2'}'s turn`);
}, 900);

}


/* starting hand logic */
async function drawStartingHandForPlayer(key){
  const deck=playerState[key].deck;
  if(deck.length<5)throw new Error('Deck too small');

  let tries=0,hand=[],hasBasic=false;

  while(tries<10){
    tries++;
    shuffle(deck);

    hand=deck.slice(0,5);

    const flags=await Promise.all(
      hand.map(c=>isBasicPokemon(c.set,c.number||c.num))
    );

    hasBasic=flags.some(Boolean);
    if(hasBasic) break;
  }

  playerState[key].hand=hand;
  deck.splice(0,5);
}

/* ========= energy zone ========= */
function renderEnergyZone(){
  const types = playerState[currentPlayer]?.energyTypes || [];
  energyZoneDiv.innerHTML = '';

  const disable =
    (globalThis.turnNumber === 1 && currentPlayer === firstPlayer) ||
    hasAttachedEnergyThisTurn;

  for (const t of types) {
    const lw = t.toLowerCase();
    const el = document.createElement('div');
    el.className = 'energy';
    el.style.backgroundImage = `url('${ENERGY_ICONS[lw] || ''}')`;
    el.title = t;

    if (disable) {
      el.style.filter = 'grayscale(100%) brightness(70%)';
      el.style.cursor  = 'not-allowed';
    } else {
      el.onclick = () => {
        selectedEnergy = lw;
        showPopup(`Selected ${lw} energy`);
      };
    }

    energyZoneDiv.appendChild(el);
  }
}

/* ========= coin flip + setup ========= */
function flipCoin(){
  coinEl.classList.add('flip');

  const res = Math.random() < 0.5 ? 'player1' : 'player2';
  const front = coinEl.querySelector('.front');
  const back  = coinEl.querySelector('.back');

  setTimeout(() => {
    coinEl.classList.remove('flip');

    if (res === 'player1') {
      front.style.transform = 'rotateY(0deg)';
      back.style.transform  = 'rotateY(180deg)';
    } else {
      front.style.transform = 'rotateY(180deg)';
      back.style.transform  = 'rotateY(0deg)';
    }

    firstPlayer   = res;
    currentPlayer = res;

    coinResult.textContent = `${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`;
    showPopup(`${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`);

    logEvent({
      player: res,
      text:`Won the coin flip and goes first.`
    });

    updateTurnBox();
    renderEnergyZone();

    drawOne(currentPlayer);
    renderAllHands();

    isSetupPhase = false;
  }, 1500);
}

/* ========= right-click zoom ========= */
document.body.addEventListener('contextmenu', async e => {
  const handImgEl = e.target.closest('.hand img');

  /* Right-click on card in hand */
  if (handImgEl) {
    e.preventDefault();

    const set = handImgEl.dataset.set;
    const num = handImgEl.dataset.num;

    try {
      const meta = await fetchCardMeta(set, num);
      const category = (meta.category || '').toLowerCase();

      if (handBackdrop && handImg) {
        handImg.src = handImgEl.src;
        handBackdrop.classList.add('show');
        handTitle.textContent = meta.name || 'Card';
      }

      if (category === 'pokemon') {
        if (handBackdrop) handBackdrop.classList.remove('show');

        zoomImg.src = handImgEl.src;
        zoomBackdrop.classList.add('show');

        await buildZoomPanel(meta, handImgEl);
        zoomAttacks.querySelectorAll('.zoom-attack').forEach(a => a.classList.add('muted'));
        document.getElementById('zoomRetreatRow')?.classList.add('disabled');
      } else {
        if (handType) {
          handType.textContent = meta.trainerType || meta.category || 'Card';
          handType.style.background = trainerColor(meta.trainerType || meta.category);
        }
        if (handEffect) {
          handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
        }
      }

    } catch {
      showPopup('No data available for this card.');
    }

    return;
  }

  /* Right-click on Pok√©mon in play */
  const img = e.target.closest('.active img, .bench img');
  if (!img) return;

  e.preventDefault();

  zoomImg.src = img.src;
  zoomBackdrop.classList.add('show');

  try {
    const set = img.dataset.set;
    const num = img.dataset.num;
    const meta = await fetchCardMeta(set, num);
    await buildZoomPanel(meta, img);
  } catch {
    zoomTitle.textContent = 'Pok√©mon';
    zoomHp.textContent = '';
    zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
    zoomEnergyCount.textContent = 'x0';
    zoomEnergyIcons.innerHTML = '';
    zoomWeakness.textContent = '‚Äî';
    zoomRetreat.innerHTML = '';
    zoomTools.innerHTML = '<div class="chip">none</div>';
    zoomAbilities.style.display = 'none';
  }
});

/* close zoom */
if (zoomBackdrop) {
  zoomBackdrop.addEventListener('click', e => {
    if (e.target === zoomBackdrop) {
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
    }
  });

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
    }
  });
}

/* ========= discard buttons ========= */
if (p1DiscardBtn) p1DiscardBtn.onclick = () => {
  renderDiscard('player1');
  p1DiscardDrawer.classList.add('show');
};

if (p2DiscardBtn) p2DiscardBtn.onclick = () => {
  renderDiscard('player2');
  p2DiscardDrawer.classList.add('show');
};

document.addEventListener('click', e => {
  if (p1DiscardDrawer?.classList.contains('show') &&
      !p1DiscardDrawer.contains(e.target) &&
      e.target !== p1DiscardBtn) {
    p1DiscardDrawer.classList.remove('show');
  }

  if (p2DiscardDrawer?.classList.contains('show') &&
      !p2DiscardDrawer.contains(e.target) &&
      e.target !== p2DiscardBtn) {
    p2DiscardDrawer.classList.remove('show');
  }
});

/* ========= main button ========= */
if (mainButton) mainButton.onclick = async () => {
  const label = mainButton.textContent;

  try {
    if (label === 'Draw Hands') {
      await Promise.all([
        drawStartingHandForPlayer('player1'),
        drawStartingHandForPlayer('player2')
      ]);

      renderAllHands();
      updateDeckBubbles();
      showPopup('Choose Active & Benched Pok√©mon');

      mainButton.textContent = 'Start Game';

    } else if (label === 'Start Game') {
      if (!p1Active.querySelector('img') || !p2Active.querySelector('img')) {
        showPopup('Both players need an Active Pok√©mon.');
        return;
      }

      flipCoin();
      mainButton.textContent = 'End Turn';

    } else {
      /* Regular turn cycling */
      // üÜï A3b TOOL - Leftovers (heal at end of turn)
      const currentActiveImg = getActiveImage(currentPlayer);
      
      if (currentActiveImg) {
        const slot = currentActiveImg.closest('.card-slot');
        const tool = getToolDataFromSlot(slot);
        
        if (tool && tool.num === '067' && tool.set === 'A3b') {
          const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(currentActiveImg.dataset.hp, 10);
          const curHp = parseInt(currentActiveImg.dataset.chp, 10);
          
          if (curHp < maxHp) {
            const healAmount = 10;
            const newHp = Math.min(maxHp, curHp + healAmount);
            currentActiveImg.dataset.chp = String(newHp);
            
            // Update HP display
            if (typeof setHpOnImage === 'function') {
              setHpOnImage(currentActiveImg, maxHp, newHp);
            }
            
            showPopup(`Leftovers: Healed 10 damage from ${currentActiveImg.alt}!`);
            console.log('[Leftovers] Healed 10 damage at manual end of turn');
          }
        }
      }
      
      const next = currentPlayer === 'player1' ? 'player2' : 'player1';
      startTurn(next);
    }
  } catch (err) {
    console.error('Flow error:', err);
    showPopup('Setup error. Check decks.');
  }
};

/* ========= victory screen actions ========= */
if (playAgainBtn)
  playAgainBtn.addEventListener('click', () => {
    window.location.reload();
  });

if (chooseDecksBtn)
  chooseDecksBtn.addEventListener('click', () => {
    window.location.href = 'index.html';
  });

const victoryShowLogBtn = document.getElementById("victoryShowLogBtn");

if (victoryShowLogBtn) {
  victoryShowLogBtn.onclick = () => {
    if (!fullHistoryLog.length) {
      fullHistoryDiv.innerHTML = '<div class="match-log-entry">No actions logged.</div>';
    } else {
      fullHistoryDiv.innerHTML = fullHistoryLog.map(h => `
        <div class="match-log-entry">
          <div>
            <strong>#${h.id}</strong> ¬∑ ${h.player} ¬∑
            <span style="opacity:.6">${h.ts}</span>
          </div>
          <div>${h.text}</div>
          ${
            h.imgUrl
              ? `<img class="log-thumb" src="${h.imgUrl}"
                  style="margin-top:6px;border-radius:6px;width:52px;height:auto;">`
              : ''
          }
        </div>
      `).join('');
    }
    historyBackdrop.classList.add('show');
  };
}
/* ========= effects bridge ========= */
globalThis.selectPokemon = function (_st, pk, _z) {
  const area = pk === 'p1' ? p1Active : p2Active;
  const img  = area?.querySelector('img');
  if (!img) return null;

  return {
    name: img.alt,
    hp:   parseInt(img.dataset.chp || img.dataset.hp || '0', 10) || 0,
    maxHP: parseInt(img.dataset.hp || '0', 10) || 0
  };
};

globalThis.drawCards = function (_st, pk, n) {
  const owner = pk === 'p1' ? 'player1' : 'player2';

  for (let i = 0; i < (parseInt(n) || 0); i++) {
    if (playerState[owner].deck.length) {
      playerState[owner].hand.push(playerState[owner].deck.shift());
    }
  }

  renderAllHands();
  updateDeckBubbles();
};

globalThis.shuffleIntoDeck = function (hand, deck) {
  if (!Array.isArray(hand) || !Array.isArray(deck)) return;

  deck.push(...hand);
  hand.length = 0;
  shuffle(deck);
};

globalThis.findPokemonByName = function (_st, name) {
  const imgs = $$('#player1 .active img, #player1 .bench img, ' +
                  '#player2 .active img, #player2 .bench img');
  const hit = imgs.find(i => i.alt === name);
  return hit ? { name } : null;
};

// Discard a Pokemon from play (for fossils)
globalThis.discardPokemon = async function(pokemonImg, pk, givePoint = false) {
  if (!pokemonImg) return;
  
  const slot = pokemonImg.closest('.card-slot');
  if (!slot) return;
  
  const pokemonName = pokemonImg.alt || 'Pokemon';
  
  // Get the owner
  const owner = pk === 'p1' ? 'player1' : 'player2';
  
  // Remove all attached energy and tools
  const energyBox = slot.querySelector('.energy-pips');
  if (energyBox) energyBox.remove();
  
  const toolThumb = slot.querySelector('.tool-thumb');
  if (toolThumb) toolThumb.remove();
  
  const hpOverlay = slot.querySelector('.hp-overlay');
  if (hpOverlay) hpOverlay.remove();
  
  // Remove the Pokemon
  pokemonImg.remove();
  
  // Mark slot as empty
  if (globalThis.markSlot) {
    globalThis.markSlot(slot, false);
  }
  
  // Give point to opponent if specified
  if (givePoint) {
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';
    
    if (globalThis.incrementPoints) {
      globalThis.incrementPoints(oppOwner);
      showPopup(`${pokemonName} was knocked out! ${oppOwner === 'player1' ? 'Player 1' : 'Player 2'} takes a point!`);
    }
  }
  
  console.log(`[discardPokemon] ${pokemonName} discarded, point given: ${givePoint}`);
};

globalThis.promoteFromBench = function (_st, oppKey, requireChoice = true) {
  const owner = oppKey === 'p1' ? 'player1' : 'player2';
  const bench = owner === 'player1' ? p1Bench : p2Bench;
  const imgs  = bench.querySelectorAll('img');

  if (requireChoice && imgs.length === 0) return false;

  beginPromotionFlow(owner);
  showPopup(`${owner === 'player1' ? 'Player 1' : 'Player 2'} choose a Benched Pok√©mon to promote.`);
  return true;
};

/* Expose helpers */
globalThis.shuffle = shuffle;
globalThis.renderAllHands = renderAllHands;
globalThis.updateDeckBubbles = updateDeckBubbles;
globalThis.showPopup = showPopup;
globalThis.getToolDataFromSlot = getToolDataFromSlot;
globalThis.setToolDataOnSlot = setToolDataOnSlot;

/* Animation support for Pok√© Ball etc. */
globalThis.animateCardToHand = animateCardToHand;

/* Logging bridge for trainer effects (Misty/Brock/etc.) */
globalThis.addLog = function (pk, htmlText, _imgUrl, cardObj) {
  const owner = pk === 'p1' ? 'player1' : 'player2';

  logEvent({
    player: owner,
    text: htmlText,
    cardSet: cardObj?.set,
    cardNum: cardObj?.number || cardObj?.num
  });
};

/* ========= trainer effect application ========= */
async function applyTrainerEffect(effect, owner, trainerCardImg = null, throwOnError = false) {
  try {
    const key = owner === 'player1' ? 'p1' : 'p2';

    // Use the shared global state so temp buffs (Giovanni) are visible to move effects
    const state = globalThis.state || {};

    // Ensure temp structure exists
    if (!state.temp) {
      state.temp = { p1: {}, p2: {} };
    } else {
      state.temp.p1 = state.temp.p1 || {};
      state.temp.p2 = state.temp.p2 || {};
    }

    // Keep per-player references up to date on the same object
    state.p1 = state.p1 || {};
    state.p2 = state.p2 || {};

    state.p1.deck = playerState.player1.deck;
    state.p1.hand = playerState.player1.hand;
    state.p1.discard = playerState.player1.discard;  // üÜï Add discard for Lusamine

    state.p2.deck = playerState.player2.deck;
    state.p2.hand = playerState.player2.hand;
    state.p2.discard = playerState.player2.discard;  // üÜï Add discard for Lusamine
    
    // üÜï Add trainer card to state for fossil effects
    state.trainerCard = trainerCardImg;

    let handler = TRAINER_EFFECTS[effect.effect_type];

    if (!handler && effect.effect_name && TRAINER_EFFECTS[effect.effect_name]) {
      console.warn('No handler for type:', effect.effect_type, '‚Äî using name instead');
      handler = TRAINER_EFFECTS[effect.effect_name];
    }

    if (!handler) {
      console.warn('No trainer handler for', effect);
      return;
    }

    // Giovanni and others now mutate globalThis.state
    await handler(state, key, { param1: effect.param1, param2: effect.param2 });

    renderAllHands();
    updateDeckBubbles();

  } catch (err) {
    console.error('Trainer effect error:', err);
    if (throwOnError) {
      // Re-throw for items so card stays in hand
      throw err;
    } else {
      // Show popup for tools/supporters
      showPopup('Trainer effect failed.');
    }
  }
}

function addTrainerToDiscard(owner, img) {
  pushCardToDiscard(owner, img);
  const drawer = owner === 'player1' ? p1DiscardDrawer : p2DiscardDrawer;

  if (drawer.classList.contains('show')) {
    renderDiscard(owner);
  }
}

/* ============================================================
   STATUS CONDITION ENGINE (MARKERS + BASIC TICKS)
   Uses bottom-left icons on the active Pok√©mon
   ============================================================ */

/* helper: get active image for pk = "p1" | "p2" */
function getActiveImg(pk) {
  const area = pk === 'p1' ? p1Active : p2Active;
  return area ? area.querySelector('img') : null;
}

function isActiveBlockedFromAttacking(pk) {
  const img = getActiveImg(pk);
  if (!img) return false;
  const st = (img.dataset.status || '').toLowerCase();
  return st === 'asleep' || st === 'paralyzed';
}

/* helper: coin flip result "heads" | "tails" (logic only) */
// Unified visual coin flip for all game logic and effects.js
function doCoinFlip() {
  const isHeads   = Math.random() < 0.5;
  const resultStr = isHeads ? 'heads' : 'tails';

  try {
    if (coinEl) {
      const front = coinEl.querySelector('.front');
      const back  = coinEl.querySelector('.back');

      // Trigger CSS animation
      coinEl.classList.add('flip');

      setTimeout(() => {
        coinEl.classList.remove('flip');

        // Display correct side
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform  = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform  = 'rotateY(0deg)';
          }
        }

        // Update readout text
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
      }, 1500);
    }
  } catch (e) {
    console.warn("[battle] visual coin flip failed", e);
  }

  return resultStr; // synchronous return so effects.js remains compatible
}

// expose for effects.js
globalThis.doCoinFlip = doCoinFlip;


function flipCoinStatus() {
  return new Promise(resolve => {
    coinEl.classList.add('flip');

    const isHeads = Math.random() < 0.5;
    const front = coinEl.querySelector('.front');
    const back  = coinEl.querySelector('.back');

    setTimeout(() => {
      coinEl.classList.remove('flip');

      if (isHeads) {
        // Heads: show front
        front.style.transform = 'rotateY(0deg)';
        back.style.transform  = 'rotateY(180deg)';
        coinResult.textContent = 'Heads';
      } else {
        // Tails: show back
        front.style.transform = 'rotateY(180deg)';
        back.style.transform  = 'rotateY(0deg)';
        coinResult.textContent = 'Tails';
      }

      resolve(isHeads ? 'heads' : 'tails');
    }, 1500);
  });
}

async function visualCoinFlip(messagePrefix = "Flip") {
  return new Promise(resolve => {
    coinEl.classList.add("flip");

    const flip = Math.random() < 0.5 ? "heads" : "tails";

    setTimeout(() => {
      coinEl.classList.remove("flip");

      // Do NOT change who-goes-first visual state
      // Just flash result in popup
      showPopup(`${messagePrefix}: ${flip.toUpperCase()}`);

      resolve(flip);
    }, 1500);
  });
}


/* normalize string from effects ("Poison", "poisoned", etc.) */
function normalizeStatusName(name) {
  const n = String(name || '').toLowerCase().trim();
  if (!n) return '';

  if (n.startsWith('poison')) return 'poisoned';
  if (n.startsWith('sleep'))  return 'asleep';
  if (n.startsWith('burn'))   return 'burned';
  if (n.startsWith('para'))   return 'paralyzed';
  if (n.startsWith('conf'))   return 'confused';

  return n; // already normalized
}

/* draw or update the status icon for this img */
function drawStatusIcon(img, key) {
  const slot = img.closest('.card-slot');
  if (!slot) return;

  let icon = slot.querySelector('.status-icon');
  if (!icon) {
    icon = document.createElement('div');
    icon.className = 'status-icon';
    slot.appendChild(icon);
  }

  const url = STATUS_ICON_URLS[key];
  if (url) {
    icon.style.backgroundImage = `url('${url}')`;
  } else {
    icon.style.backgroundImage = '';
  }

  // If this card is currently zoomed, update the zoom status icon too
  if (currentZoom.img === img && zoomStatusIcon) {
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }
}

/* remove icon and dataset from a single img */
function clearStatusOnImg(img) {
  if (!img) return;
  img.dataset.status = '';

  const slot = img.closest('.card-slot');
  if (slot) {
    const icon = slot.querySelector('.status-icon');
    if (icon) icon.remove();
  }

  // Also clear in zoom, if this is the zoomed Pok√©mon
  if (currentZoom.img === img && zoomStatusIcon) {
    zoomStatusIcon.style.display = 'none';
    zoomStatusIcon.style.backgroundImage = '';
  }
}


/* public: set status on active Pok√©mon pk ("p1" | "p2") */
function setStatus(pk, statusName) {
  const img = getActiveImg(pk);
  if (!img) return;

  // üÜï Check for status protection (Comfey - Flower Shield)
  if (img.dataset.statusProtected) {
    console.log(`[Status] ${img.alt} is protected from status (${img.dataset.statusProtected})`);
    showPopup(`${img.alt} is protected from Special Conditions!`);
    return false;
  }

  const key = normalizeStatusName(statusName);
  if (!key) return;

  img.dataset.status = key;
  drawStatusIcon(img, key);
  return true;
}
globalThis.setStatus = setStatus;


/* public: clear status on active Pok√©mon pk */
function clearStatus(pk) {
  const img = getActiveImg(pk);
  clearStatusOnImg(img);
}

/* status BETWEEN turns (poison/burn damage) */
async function runStatusBetweenTurns() {
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;

    const status = (img.dataset.status || '').toLowerCase();
    if (!status) continue;

    const owner = pk === 'p1' ? 'player1' : 'player2';

    /* Poison: 10 damage between turns (or 20 for heavy poison) */
    if (status === 'poisoned') {
      // üÜï A2a MOVE EFFECT - Heavy poison (Toxicroak Toxic)
      let poisonDamage = parseInt(img.dataset.heavyPoison || '10', 10);
      
      // üÜï A3a - Nihilego More Poison (increase poison damage)
      // Check if ANY player has Nihilego with increase_poison_damage
      try {
        const allPokemon = [
          ...document.querySelectorAll('#player1 .card-img'),
          ...document.querySelectorAll('#player2 .card-img')
        ];
        
        for (const pokemon of allPokemon) {
          const cacheKey = `${pokemon.dataset.set}-${pokemon.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          if (abilityRow?.effect_type === 'increase_poison_damage') {
            const bonus = parseInt(abilityRow.param1 || '10', 10);
            poisonDamage += bonus;
            console.log(`[More Poison] ${pokemon.alt} increased poison damage by ${bonus}`);
          }
        }
      } catch (err) {
        console.error('[poison] More Poison check failed:', err);
      }
      
      const result = await damageActiveOf(owner, poisonDamage, { isDirectAttack: false });
      
      if (poisonDamage === 20 || poisonDamage > 10) {
        showPopup(`${img.alt || 'Active Pok√©mon'} took ${poisonDamage} damage from Poison!`);
      } else {
        showPopup(`${img.alt || 'Active Pok√©mon'} took ${poisonDamage} damage from Poison.`);
      }

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          beginPromotionFlow(owner);
        }
      }
    }

    /* Burn: 20 damage then flip coin; heads = cured */
    if (status === 'burned') {
      const result = await damageActiveOf(owner, 20, { isDirectAttack: false });
      showPopup(`${img.alt || 'Active Pok√©mon'} took 20 damage from Burn.`);

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          beginPromotionFlow(owner);
        }
        continue;
      }

      const r = doCoinFlip();
      if (r === 'heads') {
        clearStatus(pk);
        showPopup('The burn was healed!');
      }
    }

    /* Confusion has no between-turn effect; handled on attack. */
  }
  
  // üÜï A2a PASSIVE ABILITY - damage_during_checkup (Glaceon ex Snowy Terrain)
  // Check both players for Glaceon ex with this ability
  for (const checkPk of ['p1', 'p2']) {
    const activeImg = getActiveImg(checkPk);
    if (!activeImg) continue;
    
    // Check if this Pokemon has damage_during_checkup ability
    const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'damage_during_checkup') {
      const damage = parseInt(abilityRow.param1 || '10', 10);
      const oppPk = checkPk === 'p1' ? 'p2' : 'p1';
      const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';
      
      console.log(`[Glaceon checkup] ${activeImg.alt} dealing ${damage} to opponent`);
      const result = await damageActiveOf(oppOwner, damage, { isDirectAttack: false });
      showPopup(`${activeImg.alt}'s Snowy Terrain: ${damage} damage to opponent!`);
      
      if (result.knocked) {
        const oppImg = getActiveImage(oppOwner);
        if (oppImg) {
          const ended = await handleKnockOut(oppOwner, oppImg);
          if (ended) return;
          beginPromotionFlow(oppOwner);
        }
      }
    }
  }
}

/* expose to effects.js */
globalThis.setStatus  = setStatus;
globalThis.clearStatus = clearStatus;

/* ========= init ========= */
updateDeckBubbles();
updateTurnBox();
updatePointsUI();
renderAllHands();
</script>
</body>
</html>